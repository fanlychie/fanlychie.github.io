[{"title":"springmvc+dubbo+mybatis 接入大众点评 CAT 监控平台","date":"2018-08-04T23:38:36.000Z","path":"post/springmvc-dubbo-mybatis-with-cat.html","text":"CAT（Central Application Tracking）是基于Java开发的实时应用监控平台，包括实时应用监控，业务监控。关于CAT的具体介绍可移步到CAT官网进行查阅。CAT平台的搭建可移步到「搭建大众点评CAT监控平台」。 1. 开发环境Windows Java 8 Maven 3.5 MySQL 5.7 CAT 2.0.0 Dubbo 2.6 Spring 4.3 2. 客户端配置客户端应用程序接入CAT需要在系统的特定路径中部署client.xml配置文件。Windows系统和Linux系统的部署路径不一样，但其内容是一样的。 2.1 Windows 客户端配置如果你的客户端程序是运行在Windows系统中，例如你的应用程序项目所在的目录路径是D:\\application\\workspace\\idea\\springmvc-dubbo-mybatis-with-cat-sample。那么，你需要在此项目所在的盘符（即这里的D盘）创建data\\appdatas\\cat目录，并将client.xml配置文件存放在这个路径中。如作者的客户端配置文件D:\\data\\appdatas\\cat\\client.xml： 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;config mode=\"client\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema\" xsi:noNamespaceSchemaLocation=\"config.xsd\"&gt; &lt;servers&gt; &lt;server ip=\"10.10.10.121\" port=\"2280\" http-port=\"8080\" /&gt; &lt;server ip=\"10.10.10.122\" port=\"2280\" http-port=\"8080\" /&gt; &lt;server ip=\"10.10.10.123\" port=\"2280\" http-port=\"8080\" /&gt; &lt;/servers&gt;&lt;/config&gt; 2.1 Linux 客户端配置如果你的客户端程序是运行在Linux系统中，那么你需要创建/data/appdatas/cat目录，并确保运行程序的用户对此目录有读写权限。然后将client.xml配置文件存放在这个路径中。配置文件的内容与上同。 3. 配置监控的项目名在需要接入CAT监控平台的项目中新建属性配置文件src/main/resources/META-INF/app.properties。其内容如下： 123################## CAT会自动加载此文件 ################### 应用的名称（可以根据此名称在CAT的管理控制台查找对应的信息）app.name=service-article 4. URL 监控埋点客户端程序接入CAT需要依赖cat-client包。由于cat-client没有加入maven远程中央仓库，因此需要指定CAT专用的远程仓库。在需要接入CAT监控平台的web项目的pom.xml中加入如下配置： 123456789101112131415&lt;repositories&gt; &lt;!-- CAT client 仓库 --&gt; &lt;repository&gt; &lt;id&gt;unidal-nexus-repo&lt;/id&gt; &lt;url&gt;http://unidal.org/nexus/content/repositories/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 客户端接入CAT的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt; &lt;artifactId&gt;cat-client&lt;/artifactId&gt; &lt;version&gt;$&#123;cat-client.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 然后在web项目的web.xml配置文件中加入如下配置即可： 12345678910&lt;filter&gt; &lt;filter-name&gt;cat-filter&lt;/filter-name&gt; &lt;filter-class&gt;com.dianping.cat.servlet.CatFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;cat-filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 接入后，在Transaction中会生成URL信息。效果图（缩略图，可右键在新标签页打开图片查看）： 5. mybatis 接入项目地址：https://github.com/fanlychie/cat-client-mybatis 你可以检出项目手工执行安装到本地的maven仓库。或者使用博主托管在github的maven仓库： 123456789101112131415&lt;!-- CAT mybatis和dubbo 仓库 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;fanlychie-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- mybatis接入CAT的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt; &lt;artifactId&gt;cat-client-mybatis&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 接入方式（这里仅给出 spring 的 xml 配置参考方式）： 123456789101112&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"typeAliasesPackage\" value=\"org.fanlychie.entity\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:mapper/*.xml\"/&gt; &lt;!-- MyBatis 接入 CAT --&gt; &lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;bean class=\"com.wanda.cat.sample.plugins.CatMybatisPlugin\"&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 接入后，在Transaction中会生成SQL信息。效果图（缩略图，可右键在新标签页打开图片查看）： 6. dubbo 接入 (生产者端)项目地址：https://github.com/fanlychie/cat-dubbo-monitor 你可以检出项目手工执行安装到本地的maven仓库。或者使用博主托管在github的maven仓库： 123456789101112131415&lt;!-- CAT mybatis和dubbo 仓库 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;fanlychie-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- dubbo接入CAT的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.dubboclub&lt;/groupId&gt; &lt;artifactId&gt;cat-dubbo-monitor&lt;/artifactId&gt; &lt;version&gt;0.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 接入方式：只需要声明依赖包，不需要做任何配置。接入后，在cat中会出现cross报表，dependency，服务端的matrix以及调用链路的trace信息。 效果图（缩略图，可右键在新标签页打开图片查看）： 7. dubbo 接入 (web消费者端)项目地址：https://github.com/fanlychie/cat-client-dubbo 你可以检出项目手工执行安装到本地的maven仓库。或者使用博主托管在github的maven仓库： 123456789101112131415&lt;!-- CAT mybatis和dubbo 仓库 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;fanlychie-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 客户端dubbo接入CAT --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;cat-client-dubbo&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 接入方式为，在web项目的消费者端dubbo配置文件中加入如下配置： 1&lt;dubbo:consumer filter=\"CatClientFilter\"/&gt; 接入后，在Transaction的URL中会生成dubbo调用链路的trace信息。 接入前的效果图（缩略图，可右键在新标签页打开图片查看）： 接入后的效果图（缩略图，可右键在新标签页打开图片查看）： 8. log4j 接入异常日志信息接入将异常日志上报到CAT服务器，方便查看异常日志。 1234log4j.rootCategory = INFO, ...xxx... , CAT# 异常日志上报到CATlog4j.appender.CAT = com.dianping.cat.log4j.CatAppenderlog4j.appender.CAT.Threshold = ERROR 9. 项目启动报错问题当启动两个或以上依赖cat-client包的项目的时候，会报出如下错误，致使服务无法正常提供服务： 122018-08-05 23:14:01:326 [main] ERROR [Server:102] - [DUBBO] qos-server can not bind localhost:22222, dubbo version: 2.6.0, current host: 127.0.0.1java.net.BindException: Address already in use: bind 这是dubbo的qos服务端口冲突引起的，其默认使用22222端口。可以在项目的dubbo.properties属性配置文件中修改此端口： 12# 避免端口冲突, 默认端口22222dubbo.qos.port=20221 完整示例项目链接：springmvc-dubbo-mybatis-with-cat-sample参考文档文献链接：https://github.com/dianping/cat","tags":[{"name":"监控","slug":"监控","permalink":"http://yoursite.com/tags/监控/"}]},{"title":"搭建大众点评CAT监控平台","date":"2018-07-27T23:38:36.000Z","path":"post/cat-setup.html","text":"CAT（Central Application Tracking）是基于Java开发的实时应用监控平台，包括实时应用监控，业务监控。关于CAT的具体介绍可移步到CAT官网进行查阅。 1. 环境清单CentOS 7 Java 8 Maven 3.5 MySQL 5.7 CAT 2.0.0 Tomcat 7.0 2. 安装 CAT下载CAT安装包： 1# wget -O cat-home-2.0.0.war http://unidal.org/nexus/service/local/repositories/releases/content/com/dianping/cat/cat-home/2.0.0/cat-home-2.0.0.war 将cat-home-2.0.0.war部署到tomcat并重命名为cat.war： 1$ mv cat-home-2.0.0.war tomcat-7.0.90/webapps/cat.war 2.1 配置 CAT在Linux系统安装时，CAT应用要求对/data/appdatas/cat和/data/applogs/cat路径有读写权限。 1# mkdir -p /data/appdatas/cat &amp;&amp; mkdir -p /data/applogs/cat CAT服务端应用会对这两个目录进行读写操作，因此需要首先创建这两个目录。并且应确保启动CAT应用的用户对这两个目录有读写权限。 下载CAT的源码包： 1$ wget -O cat-2.0.0.tar.gz https://codeload.github.com/dianping/cat/tar.gz/v2.0.0 解压缩： 1# tar zxvf cat-2.0.0.tar.gz 解压缩完成后得到cat-2.0.0目录。其中cat-2.0.0/script目录中存放的是CAT客户端和服务端安装所需的一些配置文件： 文件 说明 client.xml 所有的CAT客户端都需要配置这个配置文件。它用于配置CAT部署的服务端信息。只有客户端配置了这个配置文件，客户端才能正确连接到CAT服务器端。该文件的部署路径是/data/appdatas/cat（该部署路径不能更改，并且启动客户端的程序的用户需要对此目录有读写权限）。特殊的，部署CAT应用的服务端同时也是一个客户端，也需要配置该配置文件。 server.xml CAT服务端的配置文件。即安装CAT应用的服务器才需要配置。该文件的部署路径是/data/appdatas/cat（该部署路径不能更改，并且启动CAT应用的用户需要对此目录有读写权限）。 datasources.xml CAT服务端的配置文件。即安装CAT应用的服务器才需要配置。该配置文件用于配置CAT链接MySQL数据库的信息。该文件的部署路径是/data/appdatas/cat（该部署路径不能更改）。 Cat.sql CAT应用所需的MySQL数据库脚本。需将此脚本导入MySQL数据库中。 将cat-2.0.0/script目录中的client.xml、datasources.xml、server.xml配置文件复制到目录/data/appdatas/cat中： 1$ cp client.xml server.xml datasources.xml /data/appdatas/cat/ 客户端client.xml的配置内容如下： 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;config mode=\"client\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema\" xsi:noNamespaceSchemaLocation=\"config.xsd\"&gt; &lt;servers&gt; &lt;!-- ip：部署CAT应用的服务器IP port：CAT服务端接收客户端数据的端口（不允许更改） http-port：CAT应用部署到的容器的端口（tomcat的端口） --&gt; &lt;server ip=\"10.10.10.121\" port=\"2280\" http-port=\"8080\" /&gt; &lt;/servers&gt;&lt;/config&gt; 服务端server.xml的配置内容如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- local-mode：是否为本地开发模式。建议在开发环境以及生产环境都设置为false hdfs-machine：是否启用HDFS存储 job-machine：是否为报告工作机（开启生成汇总报告和统计报告，只需要一台服务机开启此功能） alert-machine：是否为报警机（开启各类报警监听, 只需要一台服务机开启此功能）--&gt;&lt;config local-mode=\"false\" hdfs-machine=\"false\" job-machine=\"true\" alert-machine=\"false\"&gt; &lt;!-- local-base-dir：本地数据存储目录, 建议不要修改 local-report-storage-time：本地报告文件存放时长, 单位为（天） local-logivew-storage-time：本地日志文件存放时长, 单位为（天） --&gt; &lt;storage local-base-dir=\"/data/appdatas/cat/bucket/\" local-report-storage-time=\"7\" local-logivew-storage-time=\"7\"/&gt; &lt;console default-domain=\"Cat\" show-cat-domain=\"true\"&gt; &lt;!-- 远程服务端HTTP服务列表, 用于同步更新 --&gt; &lt;remote-servers&gt;10.10.10.121:8080&lt;/remote-servers&gt; &lt;/console&gt;&lt;/config&gt; 数据源datasources.xml的配置内容如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;data-sources&gt; &lt;data-source id=\"cat\"&gt; &lt;maximum-pool-size&gt;8&lt;/maximum-pool-size&gt; &lt;connection-timeout&gt;3s&lt;/connection-timeout&gt; &lt;idle-timeout&gt;10m&lt;/idle-timeout&gt; &lt;statement-cache-size&gt;1000&lt;/statement-cache-size&gt; &lt;properties&gt; &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt; &lt;!-- 数据库 --&gt; &lt;url&gt;&lt;![CDATA[jdbc:mysql://10.10.10.121:3306/cat_schema]]&gt;&lt;/url&gt; &lt;!-- 用户名 --&gt; &lt;user&gt;root&lt;/user&gt; &lt;!-- 密码 --&gt; &lt;password&gt;123654&lt;/password&gt; &lt;connectionProperties&gt;&lt;![CDATA[useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;socketTimeout=120000]]&gt;&lt;/connectionProperties&gt; &lt;/properties&gt; &lt;/data-source&gt; &lt;data-source id=\"app\"&gt; &lt;maximum-pool-size&gt;8&lt;/maximum-pool-size&gt; &lt;connection-timeout&gt;3s&lt;/connection-timeout&gt; &lt;idle-timeout&gt;10m&lt;/idle-timeout&gt; &lt;statement-cache-size&gt;1000&lt;/statement-cache-size&gt; &lt;properties&gt; &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt; &lt;!-- 数据库 --&gt; &lt;url&gt;&lt;![CDATA[jdbc:mysql://10.10.10.121:3306/cat_schema]]&gt;&lt;/url&gt; &lt;!-- 用户名 --&gt; &lt;user&gt;root&lt;/user&gt; &lt;!-- 密码 --&gt; &lt;password&gt;123654&lt;/password&gt; &lt;connectionProperties&gt;&lt;![CDATA[useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;socketTimeout=120000]]&gt;&lt;/connectionProperties&gt; &lt;/properties&gt; &lt;/data-source&gt;&lt;/data-sources&gt; 创建cat_schema数据库： 1CREATE DATABASE IF NOT EXISTS cat_schema DEFAULT CHARSET utf8 COLLATE utf8_general_ci 选择数据库cat_schema： 1USE cat_schema 导入Cat.sql到cat_schema数据库： 1SOURCE /home/fanlychie/cat-2.0.0/script/Cat.sql 编辑tomcat配置文件： 1$ vim tomcat-7.0.90/conf/server.xml 找到Connector的配置行，添加URIEncoding=&quot;utf-8&quot;。如下： 1234&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" URIEncoding=\"utf-8\" /&gt; 2.2 启动 CAT启动tomcat： 1$ ./tomcat-7.0.90/bin/startup.sh 访问：http://10.10.10.121:8080/cat 配置操作需要用户登入系统，每次的登录账户名和密码保持一致即可。如catadmin/catadmin。 2.3 客户端路由设置依次打开配置 --&gt; 全局告警配置 --&gt; 客户端路由修改id为CAT部署的服务器ip： 3. 集群搭建上面介绍的是CAT应用的单点模式部署。接下来介绍CAT的集群模式搭建方式。 3.1 部署概览 IP 角色 10.10.10.121 控制台、告警端、任务机 10.10.10.122 消费机 10.10.10.123 消费机 10.10.10.121作为前端控制台，如果使用了域名，只需将域名解析到此IP地址。 按以上搭建单点模式的方式，分别在10.10.10.121、10.10.10.122、10.10.10.123部署CAT。部署完成后，先不要启动tomcat。接下来做集群配置。 3.2 客户端client.xml配置10.10.10.121、10.10.10.122、10.10.10.123的client.xml配置一样，具体如下： 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;config mode=\"client\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema\" xsi:noNamespaceSchemaLocation=\"config.xsd\"&gt; &lt;servers&gt; &lt;!-- ip：部署CAT应用的服务器IP port：CAT服务端接收客户端数据的端口（不允许更改） http-port：CAT应用部署到的容器的端口（tomcat的端口） --&gt; &lt;server ip=\"10.10.10.121\" port=\"2280\" http-port=\"8080\" /&gt; &lt;server ip=\"10.10.10.122\" port=\"2280\" http-port=\"8080\" /&gt; &lt;server ip=\"10.10.10.123\" port=\"2280\" http-port=\"8080\" /&gt; &lt;/servers&gt;&lt;/config&gt; 3.3 服务端server.xml配置10.10.10.121的server.xml配置，具体如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- local-mode：是否为本地开发模式。建议在开发环境以及生产环境都设置为false hdfs-machine：是否启用HDFS存储 job-machine：是否为报告工作机（开启生成汇总报告和统计报告，只需要一台服务机开启此功能） alert-machine：是否为报警机（开启各类报警监听, 只需要一台服务机开启此功能）--&gt;&lt;config local-mode=\"false\" hdfs-machine=\"false\" job-machine=\"true\" alert-machine=\"true\"&gt; &lt;!-- local-base-dir：本地数据存储目录, 建议不要修改 local-report-storage-time：本地报告文件存放时长, 单位为（天） local-logivew-storage-time：本地日志文件存放时长, 单位为（天） --&gt; &lt;storage local-base-dir=\"/data/appdatas/cat/bucket/\" local-report-storage-time=\"7\" local-logivew-storage-time=\"7\"/&gt; &lt;console default-domain=\"Cat\" show-cat-domain=\"true\"&gt; &lt;!-- 远程服务端HTTP服务列表, 用于同步更新 --&gt; &lt;remote-servers&gt;10.10.10.121:8080,10.10.10.122:8080,10.10.10.123:8080&lt;/remote-servers&gt; &lt;/console&gt;&lt;/config&gt; 10.10.10.122、10.10.10.123的server.xml配置一样，具体如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- local-mode：是否为本地开发模式。建议在开发环境以及生产环境都设置为false hdfs-machine：是否启用HDFS存储 job-machine：是否为报告工作机（开启生成汇总报告和统计报告，只需要一台服务机开启此功能） alert-machine：是否为报警机（开启各类报警监听, 只需要一台服务机开启此功能）--&gt;&lt;config local-mode=\"false\" hdfs-machine=\"false\" job-machine=\"false\" alert-machine=\"false\"&gt; &lt;!-- local-base-dir：本地数据存储目录, 建议不要修改 local-report-storage-time：本地报告文件存放时长, 单位为（天） local-logivew-storage-time：本地日志文件存放时长, 单位为（天） --&gt; &lt;storage local-base-dir=\"/data/appdatas/cat/bucket/\" local-report-storage-time=\"7\" local-logivew-storage-time=\"7\"/&gt; &lt;console default-domain=\"Cat\" show-cat-domain=\"true\"&gt; &lt;!-- 远程服务端HTTP服务列表, 用于同步更新 --&gt; &lt;remote-servers&gt;10.10.10.121:8080,10.10.10.122:8080,10.10.10.123:8080&lt;/remote-servers&gt; &lt;/console&gt;&lt;/config&gt; 服务端server.xml的配置主要是job-machine和alert-machine属性值配置的不同。 3.4 启动 CAT分别启动10.10.10.121、10.10.10.122、10.10.10.123的tomcat： 1$ ./tomcat-7.0.90/bin/startup.sh 10.10.10.121作为控制台服务，只需访问：http://10.10.10.121:8080/cat 3.5 客户端路由设置10.10.10.121作为控制台服务，只需配置这台即可。 依次打开配置 --&gt; 全局告警配置 --&gt; 客户端路由修改id为CAT部署的服务器ip：","tags":[{"name":"监控","slug":"监控","permalink":"http://yoursite.com/tags/监控/"}]},{"title":"MySQL 查询优化","date":"2018-04-04T12:11:23.000Z","path":"post/mysql-select-optimization.html","text":"MySQL版本： 123456SELECT VERSION();+------------+| VERSION() |+------------+| 5.7.21-log |+------------+ 建表语句： 1234567CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `agent_id` int(11) DEFAULT NULL COMMENT '代理商ID', `name` varchar(16) DEFAULT NULL COMMENT '姓名', `score` int(11) DEFAULT '0' COMMENT '积分', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='用户表'; 1234567CREATE TABLE `agent` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `name` varchar(16) DEFAULT NULL COMMENT '名称', `level` int(11) DEFAULT NULL COMMENT '级别', PRIMARY KEY (`id`), KEY `idx_level` (`level`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='代理商'; 为用户表建立索引： 1CREATE INDEX idx_agentid ON user(agent_id); 为用户表建立索引： 1CREATE INDEX idx_score_name ON user(score, name); 为代理商建立索引： 1CREATE INDEX idx_level ON agent(level); 用户表索引列表： 123456789SHOW INDEX FROM user;+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| user | 0 | PRIMARY | 1 | id | A | 19285676 | NULL | NULL | | BTREE | | || user | 1 | idx_agentid | 1 | agent_id | A | 5952 | NULL | NULL | YES | BTREE | | || user | 1 | idx_score_name | 1 | score | A | 28654 | NULL | NULL | YES | BTREE | | || user | 1 | idx_score_name | 2 | name | A | 19970922 | NULL | NULL | YES | BTREE | | |+-------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 代理商索引列表： 1234567SHOW INDEX FROM agent;+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| agent | 0 | PRIMARY | 1 | id | A | 5 | NULL | NULL | | BTREE | | || agent | 1 | idx_level | 1 | level | A | 2 | NULL | NULL | YES | BTREE | | |+-------+------------+-----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1. ORDER BY 优化MySLQ官方文档给出了能够使用索引加速ORDER BY排序以及无法通过使用索引加速ORDER BY排序的场景案例，下面来一一列举。 1.1 使用索引加速排序1.1.1 案例1使用复合索引（多列索引）中的一个或多个列进行排序。要遵循最左前缀匹配原则。如果是使用复合索引中的多个列进行排序，这些列排序的顺序要么都是升序，要么都是降序，否则无法使用索引加速排序操作。 1SELECT * FROM t1 ORDER BY key_part1, key_part2; 1SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC; 123456EXPLAIN SELECT * FROM user ORDER BY score, name;+----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+----------------+| 1 | SIMPLE | user | NULL | ALL | NULL | NULL | NULL | NULL | 20434945 | 100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+----------------+ 从执行计划的结果来看，Extra出现了Using filesort，这就是通常说的Filesort排序。Filesort排序并不代表是通过磁盘文件进行的排序，而只是说数据库服务器需要对数据进行一次额外的排序。凡是不是通过索引直接返回排序结果的排序，都叫Filesort排序。Filesort排序算法首先是尝试将取出的数据一次性加载到内存中进行排序，排序最大能使用的内存空间大小是由系统变量sort_buffer_size决定的。如果内存空间无法容下所有取出的数据，那么排序就会分解成多个更小的排序，然后每次只排序其中一小部分的数据，并将每次排序的结果存储到磁盘临时文件中，最后再将临时文件中的数据进行一次排序和合并结果输出。每将各个有序的小数据块合并成一个有序的结果集就会增加Sort_merge_passes的数值。因此，如果数据库服务器的Sort_merge_passes的数值过大，可以考虑适当增加sort_buffer_size的数值以加速Filesort排序的操作。但是需要注意，系统变量sort_buffer_size配置的内存空间是每个线程独占的，不宜设置过大，应该综合考虑数据库连接数量和服务器内存的总大小。 # 查看系统 sort_merge_passes 状态的值123456SHOW GLOBAL STATUS LIKE 'sort_merge_passes';+-------------------+-------+| Variable_name | Value |+-------------------+-------+| Sort_merge_passes | 2461 |+-------------------+-------+ # 查看系统 sort_buffer_size 变量的值123456SHOW VARIABLES LIKE 'sort_buffer_size';+------------------+--------+| Variable_name | Value |+------------------+--------+| sort_buffer_size | 262144 |+------------------+--------+ # 设置系统 sort_buffer_size 变量的值, 1M1set GLOBAL sort_buffer_size=1024*1024*1; 使用覆盖索引的方式改写上面的查询语句： 123456EXPLAIN SELECT id FROM user ORDER BY score, name;+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-------------+| 1 | SIMPLE | user | NULL | index | NULL | idx_score_name | 56 | NULL | 20434945 | 100.00 | Using index |+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-------------+ 从执行计划的结果来看，Extra出现了Using index，已经没有Using filesort了。 1.1.2 案例2使用复合索引（多列索引）中的一部分列做等值查询，一部列做排序操作。要遵循最左前缀匹配原则。如果是使用复合索引中的多个列进行排序，这些列排序的顺序要么都是升序，要么都是降序，否则无法使用索引加速排序操作。 1SELECT * FROM t1 WHERE key_part1 = constant ORDER BY key_part2; 1SELECT * FROM t1 WHERE key_part1 = constant ORDER BY key_part1 DESC, key_part2 DESC; 123456EXPLAIN SELECT * FROM user WHERE score = 100 ORDER BY name;+----+-------------+-------+------------+------+----------------+----------------+---------+-------+-------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+----------------+----------------+---------+-------+-------+----------+-----------------------+| 1 | SIMPLE | user | NULL | ref | idx_score_name | idx_score_name | 5 | const | 38268 | 100.00 | Using index condition |+----+-------------+-------+------------+------+----------------+----------------+---------+-------+-------+----------+-----------------------+ 1.1.3 案例3使用复合索引（多列索引）中的一部分列做比较值查询，一部列做排序操作。要遵循最左前缀匹配原则。如果是使用复合索引中的多个列进行排序，这些列排序的顺序要么都是升序，要么都是降序，否则无法使用索引加速排序操作。 1SELECT * FROM t1 WHERE key_part1 &gt; constant ORDER BY key_part1 ASC; 1SELECT * FROM t1 WHERE key_part1 &lt; constant ORDER BY key_part1 DESC; 123456EXPLAIN SELECT * FROM user WHERE score &lt; 10 ORDER BY score;+----+-------------+-------+------------+-------+----------------+----------------+---------+------+--------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+----------------+----------------+---------+------+--------+----------+-----------------------+| 1 | SIMPLE | user | NULL | range | idx_score_name | idx_score_name | 5 | NULL | 417240 | 100.00 | Using index condition |+----+-------------+-------+------------+-------+----------------+----------------+---------+------+--------+----------+-----------------------+ 比较值的场景下，优化器不一定会选择采用索引的方式，主要还得看表数据量的大小以及MySQL估算查询要扫描的行数来决定是否选择走索引。 1.2 无法使用索引加速排序1.2.1 案例1使用多个不同的单列索引进行排序。 1SELECT * FROM t1 ORDER BY key1, key2; 123456EXPLAIN SELECT id FROM user ORDER BY id, agent_id;+----+-------------+-------+------------+-------+---------------+-------------+---------+------+----------+----------+-----------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+----------+----------+-----------------------------+| 1 | SIMPLE | user | NULL | index | NULL | idx_agentid | 5 | NULL | 20434945 | 100.00 | Using index; Using filesort |+----+-------------+-------+------------+-------+---------------+-------------+---------+------+----------+----------+-----------------------------+ 为了确保查询走索引，这里采用了覆盖索引的方式。 1.2.2 案例2使用复合索引（多列索引）的多个列进行排序时，不遵循最左前缀匹配原则。 1SELECT * FROM t1 WHERE key2=constant ORDER BY key_part1, key_part3; 123456EXPLAIN SELECT id FROM user ORDER BY name, score;+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-----------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-----------------------------+| 1 | SIMPLE | user | NULL | index | NULL | idx_score_name | 56 | NULL | 20434945 | 100.00 | Using index; Using filesort |+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-----------------------------+ 本文没有建立三个列的复合索引，这里采用覆盖索引的方式来实现，达到的效果是一样的。 1.2.3 案例3使用复合索引（多列索引）的多个列进行排序时，同时存在升序和降序的混合排序。 1SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC; 123456EXPLAIN SELECT id FROM user ORDER BY score, name DESC;+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-----------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-----------------------------+| 1 | SIMPLE | user | NULL | index | NULL | idx_score_name | 56 | NULL | 20434945 | 100.00 | Using index; Using filesort |+----+-------------+-------+------------+-------+---------------+----------------+---------+------+----------+----------+-----------------------------+ 为了确保查询走索引，这里采用了覆盖索引的方式。 2. LIMIT 优化2.1 案例查询代理商ID为2下面的所有用户信息，每页展示20条数据，起始值从200万行开始。为保证优化前和优化后返回相同的数据列表，这里增加了根据主键排序的条件： 123456EXPLAIN SELECT * FROM user WHERE agent_id = 2 ORDER BY id LIMIT 2000000, 20;+----+-------------+-------+------------+------+---------------+-------------+---------+-------+---------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-------------+---------+-------+---------+----------+-----------------------+| 1 | SIMPLE | user | NULL | ref | idx_agentid | idx_agentid | 5 | const | 5221432 | 100.00 | Using index condition |+----+-------------+-------+------------+------+---------------+-------------+---------+-------+---------+----------+-----------------------+ 在一张数据量为2000万行的表中，真实的查询耗时为3 min 0.54 sec。 2.2 优化思路：采用覆盖索引的方式先取出已经通过索引加速排序好的分页数据的行记录ID，然后再通过行记录ID关联回表查询所需的所有数据。这样可以减少全表扫描的行数，提升查询效率。 12345678EXPLAIN SELECT * FROM user INNER JOIN (SELECT id FROM user WHERE agent_id = 2 ORDER BY id LIMIT 2000000, 20) tmp USING(id);+----+-------------+------------+------------+--------+---------------+-------------+---------+--------+---------+----------+--------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+--------+---------------+-------------+---------+--------+---------+----------+--------------------------+| 1 | PRIMARY | &lt;derived2&gt; | NULL | ALL | NULL | NULL | NULL | NULL | 2000020 | 100.00 | NULL || 1 | PRIMARY | user | NULL | eq_ref | PRIMARY | PRIMARY | 4 | tmp.id | 1 | 100.00 | NULL || 2 | DERIVED | user | NULL | ref | idx_agentid | idx_agentid | 5 | const | 5221432 | 100.00 | Using where; Using index |+----+-------------+------------+------------+--------+---------------+-------------+---------+--------+---------+----------+--------------------------+ 在一张数据量为2000万行的表中，真实的查询耗时为0.42 sec。优化后的查询时间是毫秒级别的，速度提升了约180倍。 3. IN 优化3.1 案例查询二级代理商下的所有用户信息，因测试数据量过大，此处只查询前20条数据。为保证优化前和优化后返回相同的数据列表，这里增加了根据主键排序的条件： 1234567EXPLAIN SELECT * FROM user WHERE agent_id IN (SELECT id FROM agent WHERE level = 2) ORDER BY id LIMIT 20;+----+-------------+-------+------------+------+-------------------+-------------+---------+---------------+------+----------+----------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+-------------------+-------------+---------+---------------+------+----------+----------------------------------------------+| 1 | SIMPLE | agent | NULL | ref | PRIMARY,idx_level | idx_level | 5 | const | 3 | 100.00 | Using index; Using temporary; Using filesort || 1 | SIMPLE | user | NULL | ref | idx_agentid | idx_agentid | 5 | test.agent.id | 3433 | 100.00 | NULL |+----+-------------+-------+------------+------+-------------------+-------------+---------+---------------+------+----------+----------------------------------------------+ 代理商表6行数据，用户表2000万行数据，真实的查询耗时为13 min 14.73 sec，极慢，无法忍受。 通过trace分析优化器是如何选择执行计划的： 可以看到，MySQL优化器认为使用JOIN的方式能够更高效率的查找到数据行，因此内部将查询语句改写成了SEMI JOIN（半连接）。也由此可见，在MySQL中，半连接优化的效率也未必高。 3.2 优化思路：IN查询的性能很糟糕，建议使用EXISTS来等效的改写查询以获得更好的查询性能。 1234567EXPLAIN SELECT * FROM user WHERE EXISTS (SELECT 1 FROM agent WHERE level = 2 AND user.agent_id = agent.id) ORDER BY id LIMIT 20;+----+--------------------+-------+------------+--------+-------------------+---------+---------+--------------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+--------------------+-------+------------+--------+-------------------+---------+---------+--------------------+------+----------+-------------+| 1 | PRIMARY | user | NULL | index | NULL | PRIMARY | 4 | NULL | 20 | 100.00 | Using where || 2 | DEPENDENT SUBQUERY | agent | NULL | eq_ref | PRIMARY,idx_level | PRIMARY | 4 | test.user.agent_id | 1 | 60.00 | Using where |+----+--------------------+-------+------------+--------+-------------------+---------+---------+--------------------+------+----------+-------------+ 代理商表6行数据，用户表2000万行数据，真实的查询耗时为0.02 sec，提升效率是显而易见的。 3.3 案例上面是涉及关联子查询的情况，如果IN后面是常量而非子查询的情况，效率是很客观的： 123456EXPLAIN SELECT * FROM user WHERE agent_id IN(2, 3) ORDER BY id LIMIT 20;+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+| 1 | SIMPLE | user | NULL | index | idx_agentid | PRIMARY | 4 | NULL | 41 | 48.58 | Using where |+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+ 在一张数据量为2000万行的表中，真实的查询耗时基本为0.00 sec（没有查询缓存）。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"MySQL 索引","date":"2018-03-25T04:01:42.000Z","path":"post/mysql-index.html","text":"1. 索引索引是数据库查询优化最常用的方式之一，合理的建立索引能够加速数据库数据的读取效率，但这不意味着索引越多越好。索引越多，更新（增删改）数据的速度越慢，如果索引建立的不合理可能会适得其反拖慢数据库的响应速度。常见的索引类型有： 索引类型 描述 普通索引 它没有任何的限制条件，是最基础的索引类型。 唯一索引 它要求字段的值必须是唯一的。 主键索引 它是一种特殊的唯一索引，不允许为空，MySQL会自动的为表的主键创建主键索引。 复合索引（多列索引） 它可以为表的多个列创建一个索引，一个复合索引最多可以包含16个列。 1.1 创建索引数据库版本： 123456SELECT VERSION();+------------+| version() |+------------+| 5.7.21-log |+------------+ 数据库建表语句： 12345678910CREATE TABLE `emp` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '主键', `dept_id` int(11) DEFAULT NULL COMMENT '部门ID', `name` varchar(32) DEFAULT NULL COMMENT '姓名', `tel` char(11) DEFAULT NULL COMMENT '电话', `email` varchar(64) DEFAULT NULL COMMENT '邮件', `salary` int(11) DEFAULT NULL COMMENT '薪资', `birthday` date DEFAULT NULL COMMENT '生日', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=gbk COMMENT='员工表'; 1.1.1 普通索引语法：CREATE INDEX index_name ON tb_name(index_col_name) 1CREATE INDEX idx_deptid ON emp(dept_id); 1.1.2 唯一索引语法：CREATE UNIQUE INDEX index_name ON tb_name(index_col_name) 1CREATE UNIQUE INDEX idx_unique_tel ON emp(tel); 1.1.2 复合索引语法：CREATE INDEX index_name ON tb_name(index_col_name, ...) 1CREATE INDEX idx_name_email ON emp(name, email); 1.2 删除索引语法：DROP INDEX index_name ON tb_name 1DROP INDEX idx_deptid ON emp; 1.3 查看索引语法：SHOW INDEX FROM tb_name 123456789SHOW INDEX FROM emp;+-------+------------+--------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+-------+------------+--------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| emp | 0 | PRIMARY | 1 | id | A | 1989769 | NULL | NULL | | BTREE | | || emp | 0 | idx_unique_tel | 1 | tel | A | 1989769 | NULL | NULL | YES | BTREE | | || emp | 1 | idx_name_email | 1 | name | A | 1986892 | NULL | NULL | YES | BTREE | | || emp | 1 | idx_name_email | 2 | email | A | 1989769 | NULL | NULL | YES | BTREE | | |+-------+------------+--------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1.4 使用索引下面列举几种MySQL查询优化器可以选择使用索引的常见场景。为排除其它索引项的干扰，下面每在分析一条查询语句的执行计划前都假设表还没有建立过索引，相应的建索引语句也将在分析前依次给出。 1.4.1 最左前缀最左前缀匹配原则是相对于复合索引（多列索引）而言的。假设现有查询SQL如下： 1SELECT * FROM tbl_name WHERE col1 = val1 AND col2 = val2 AND col3 = val3; 如果在col1列和col2列和col3列分别建立单独的索引，由于MySQL在执行查询时通常只会使用到一个索引项，因此它会尝试使用索引合并或选择一个最严格的可以排除更多的行以得到更少结果的索引来优化查询。 1CREATE INDEX idx_name ON emp(name); 1CREATE INDEX idx_deptid ON emp(dept_id); 1CREATE INDEX idx_birthday ON emp(birthday); 123456EXPLAIN SELECT * FROM emp WHERE name = '秋田函' AND dept_id = 2 AND birthday = '1994-09-02';+----+-------------+-------+------------+-------------+-----------------------------------+-----------------------+---------+------+------+----------+-----------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------------+-----------------------------------+-----------------------+---------+------+------+----------+-----------------------------------------------------+| 1 | SIMPLE | emp | NULL | index_merge | idx_name,idx_deptid,idx_birthday | idx_name,idx_birthday | 66,3 | NULL | 1 | 21.32 | Using intersect(idx_name,idx_birthday); Using where |+----+-------------+-------+------------+-------------+-----------------------------------+-----------------------+---------+------+------+----------+-----------------------------------------------------+ 如果在col1列和col2列和col3列上建立一个复合索引 (col1, col2, col3)，根据最左前缀匹配原则，过滤筛选条件只要是在 (col1)、(col1, col2)、(col1, col2, col3) 列上的都会具有索引检索的功能。 1CREATE INDEX idx_name_deptid_birthday ON emp(name, dept_id, birthday); 123456EXPLAIN SELECT * FROM emp WHERE name = '秋田函' AND dept_id = 2 AND birthday = '1994-09-02';+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------------------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_name_deptid_birthday | idx_name_deptid_birthday | 73 | const,const,const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------------------+------+----------+-------+ 复合索引可以看成是一个有序的数组，最左前缀匹配原则是只有在匹配 (col1) 列的前提下，才可以继续匹配下一个有序项 (col2) 。它不能直接匹配 (col2) 或 (col2, col3)。如果条件检索的列不能满足最左前缀匹配原则，则不会使用索引进行结果查找。 123456EXPLAIN SELECT * FROM emp WHERE dept_id = 2 AND birthday = '1994-09-02';+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 1952590 | 1.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 1.4.2 全值匹配全值匹配原则是相对于复合索引（多列索引）而言的。即索引中的所有列在WHERE子句中都有对应的字段检索条件。在此前提下，即便没有满足复合索引的最左前缀匹配原则，MySQL的查询优化器也会自动的对WHERE子句中的字段检索条件顺序做出相应的调整以至于能够使用合适的索引。 1CREATE INDEX idx_name_deptid_birthday ON emp(name, dept_id, birthday); 123456EXPLAIN SELECT * FROM emp WHERE dept_id = 2 AND name = '秋田函' AND birthday = '1994-09-02';+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------------------+------+----------+-------+| 1 | SIMPLE | emp | NULL | ref | idx_name_deptid_birthday | idx_name_deptid_birthday | 73 | const,const,const | 1 | 100.00 | NULL |+----+-------------+-------+------------+------+--------------------------+--------------------------+---------+-------------------+------+----------+-------+ 1.4.3 范围查询对索引的值进行范围查找，常见于&gt;、&gt;=、&lt;、&lt;=、!=、IN、BETWEEN。 123456EXPLAIN SELECT * FROM emp WHERE id &gt; 2;+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+| 1 | SIMPLE | emp | NULL | range | PRIMARY | PRIMARY | 4 | NULL | 994884 | 100.00 | Using where |+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+ 1.4.4 覆盖索引如果查询的列正好都是索引列，这就意味着，查询所需的数据直接从索引树中就能够获得，而不需要再通过索引回表查询。这样可以减少I/O，提升效率。如果一个查询只需要访问索引树就能获得查询所需的所有数据，我们就称使用了覆盖索引。 1CREATE INDEX idx_name ON emp(name); 以下查询语句中因使用了条件!=，导致MySQL进行全表扫描而放弃走索引： 123456EXPLAIN SELECT * FROM emp WHERE name != '秋田函';+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_name | NULL | NULL | NULL | 1989769 | 100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 将SELECT *改为SELECT 索引列后，MySQL走上了索引，其Extra中的Using index就是覆盖索引扫描，通过条件过滤检索出来的结果不需要再回表获取额外的数据。 123456EXPLAIN SELECT id FROM emp WHERE name != '秋田函';+----+-------------+-------+------------+-------+---------------+----------+---------+------+---------+----------+--------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+---------+----------+--------------------------+| 1 | SIMPLE | emp | NULL | index | idx_name | idx_name | 67 | NULL | 1989769 | 100.00 | Using where; Using index |+----+-------------+-------+------------+-------+---------------+----------+---------+------+---------+----------+--------------------------+ 1.4.5 列前缀匹配列前缀匹配是指检索条件中使用了索引的开始一部分内容进行查找，形式通常是LIKE &#39;限定字符%&#39;。 1CREATE INDEX idx_name ON emp(name); 123456EXPLAIN SELECT * FROM emp WHERE name LIKE '秋田%';+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | emp | NULL | range | idx_name | idx_name | 67 | NULL | 6 | 100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 1.5 索引失效下面列举几种索引存在但是不能被MySQL查询优化器选择使用的常见场景。 1.5.1 以%开头的LIKE查询1CREATE INDEX idx_name ON emp(name); 以%限定字符或%限定字符%进行的LIKE查询都会导致查询无法使用索引： 123456EXPLAIN SELECT * FROM emp WHERE name LIKE '%秋田';+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 1989769 | 11.11 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 使用覆盖索引扫描进行优化： 1234567EXPLAIN SELECT * FROM emp WHERE id IN (SELECT id FROM emp WHERE name LIKE '%秋田');+----+-------------+-------+------------+--------+---------------+----------+---------+-------------+---------+----------+--------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+--------+---------------+----------+---------+-------------+---------+----------+--------------------------+| 1 | SIMPLE | emp | NULL | index | PRIMARY | idx_name | 67 | NULL | 1989769 | 11.11 | Using where; Using index || 1 | SIMPLE | emp | NULL | eq_ref | PRIMARY | PRIMARY | 4 | test.emp.id | 1 | 100.00 | NULL |+----+-------------+-------+------------+--------+---------------+----------+---------+-------------+---------+----------+--------------------------+ 在一张200万条数据的表中，原查询耗时5.21 sec，优化后的查询耗时2.23 sec。 1.5.2 数据类型出现隐式转换时1CREATE UNIQUE INDEX idx_unique_tel ON emp(tel); 特别是字符串类型，如果缺少引号就会导致查询出现数据类型的隐式转换，致使无法正常使用索引： 123456EXPLAIN SELECT * FROM emp WHERE tel = 15873225085;+----+-------------+-------+------------+------+----------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+----------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_unique_tel | NULL | NULL | NULL | 1989769 | 10.00 | Using where |+----+-------------+-------+------------+------+----------------+------+---------+------+---------+----------+-------------+ 给字符串常量加上引号之后，就可以正确的使用索引了： 123456EXPLAIN SELECT * FROM emp WHERE tel = '15873225085';+----+-------------+-------+------------+-------+----------------+----------------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+----------------+----------------+---------+-------+------+----------+-------+| 1 | SIMPLE | emp | NULL | const | idx_unique_tel | idx_unique_tel | 23 | const | 1 | 100.00 | NULL |+----+-------------+-------+------------+-------+----------------+----------------+---------+-------+------+----------+-------+ 1.5.3 不满足最左前缀匹配原则1CREATE INDEX idx_name_deptid_birthday ON emp(name, dept_id, birthday); 在复合索引（多列索引）的场景下，如果检索的列不能满足最左前缀匹配原则，则不会使用复合索引： 123456EXPLAIN SELECT * FROM emp WHERE dept_id = 2 AND birthday = '1994-09-02';+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 1952590 | 1.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 1.5.4 出现OR条件查询如果查询语句中出现OR，除非OR前后的列都是索引项，否则不能使用索引： 1CREATE UNIQUE INDEX idx_unique_tel ON emp(tel); 123456EXPLAIN SELECT * FROM emp WHERE tel = '18993283686' or name = '秋田函';+----+-------------+-------+------------+------+----------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+----------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_unique_tel | NULL | NULL | NULL | 1989769 | 10.00 | Using where |+----+-------------+-------+------------+------+----------------+------+---------+------+---------+----------+-------------+ 如果为name列也加上一个单独的索引（或使用复合索引），查询就可以正常使用索引： 1CREATE INDEX idx_name ON emp(name); 123456XPLAIN SELECT * FROM emp WHERE tel = '18993283686' or name = '秋田函';+----+-------------+-------+------------+-------------+-------------------------+-------------------------+---------+------+------+----------+---------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------------+-------------------------+-------------------------+---------+------+------+----------+---------------------------------------------------+| 1 | SIMPLE | emp | NULL | index_merge | idx_unique_tel,idx_name | idx_unique_tel,idx_name | 23,67 | NULL | 4 | 100.00 | Using union(idx_unique_tel,idx_name); Using where |+----+-------------+-------+------------+-------------+-------------------------+-------------------------+---------+------+------+----------+---------------------------------------------------+ 1.5.5 在索引列上做计算或函数操作如果在索引列上进行运算或对索引列使用函数操作，也会导致索引失效： 1CREATE INDEX idx_birthday ON emp(birthday); 123456EXPLAIN SELECT * FROM emp WHERE DATE_FORMAT(birthday, '%Y') - DATE_FORMAT(NOW(), '%Y') = 18;+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 1989769 | 100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 1.5.6 使用!=判断条件如果在索引列上使用!=进行条件判断，也会导致索引失效： 1CREATE INDEX idx_name ON emp(name); 123456EXPLAIN SELECT * FROM emp WHERE name != '秋田函';+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_name | NULL | NULL | NULL | 1989769 | 100.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 1.5.7 如果MySQL估算全表扫描比索引快时当MySQL估算全表扫描比索引快时，则不会使用索引： 1CREATE INDEX idx_deptid ON emp(dept_id); 123456EXPLAIN SELECT * FROM emp WHERE dept_id &lt; 2;+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_deptid | NULL | NULL | NULL | 1989769 | 23.21 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 通过开启optimizer_trace可以跟踪优化器在整个执行计划中是如何选择最优方案的。 查看optimizer_trace相关参数配置： 12345678910SHOW VARIABLES LIKE '%optimizer_trace%';+------------------------------+----------------------------------------------------------------------------+| Variable_name | Value |+------------------------------+----------------------------------------------------------------------------+| optimizer_trace | enabled=off,one_line=off || optimizer_trace_features | greedy_search=on,range_optimizer=on,dynamic_range=on,repeated_subselect=on || optimizer_trace_limit | 1 || optimizer_trace_max_mem_size | 16384 || optimizer_trace_offset | -1 |+------------------------------+----------------------------------------------------------------------------+ 可以看到optimizer_trace选项的enabled=off，默认是关闭的。开启optimizer_trace： 1SET optimizer_trace=\"enabled=on\"; 开启之后，首先先执行一个查询SQL的执行计划： 123456EXPLAIN SELECT * FROM emp WHERE dept_id &lt; 2;+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+| 1 | SIMPLE | emp | NULL | ALL | idx_deptid | NULL | NULL | NULL | 1989769 | 23.21 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+ 然后查看优化器在整个执行计划中是如何选择最优方案的： 1SELECT * FROM information_schema.optimizer_trace\\G 下面是全表扫描估计要访问的记录行数以及代价计算： 1234\"table_scan\": &#123; \"rows\": 1989769, \"cost\": 410416&#125; 下面是索引扫描估计要访问的记录行数以及代价计算： 12345678910111213141516\"range_scan_alternatives\": [ &#123; \"index\": \"idx_deptid\", \"ranges\": [ \"NULL &lt; dept_id &lt; 2\" ], \"index_dives_for_eq_ranges\": true, \"rowid_ordered\": false, \"using_mrr\": false, \"index_only\": false, \"rows\": 461886, \"cost\": 554264, \"chosen\": false, \"cause\": \"cost\" &#125;] 索引的代价计算（cost）为554264，全表扫描的代价计算（cost）为410416。可见，索引的代价计算要高于全表扫描的代价。因此，优化器更倾向于选择全表扫描。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"MySQL Explain 分析 SQL 的执行计划","date":"2018-03-23T15:52:17.000Z","path":"post/mysql-explain.html","text":"explain提供了MySQL是如何执行语句的详细信息，开发人员可以根据这些信息对执行的语句进行性能方面的优化。explain可以与SELECT、INSERT、UPDATE、DELETE语句一起使用。 1. MySQL 版本123456mysql&gt; select version();+------------+| version() |+------------+| 5.7.21-log |+------------+ 2. explain 格式123456mysql&gt; explain select * from emp;+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+| 1 | SIMPLE | emp | NULL | ALL | NULL | NULL | NULL | NULL | 503106 | 100.00 | NULL |+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+ 字段 描述 id 查询语句标识符。数值越大优先级别越高，就越先执行。如果数值一样，则由上至下依次执行。NULL值表示这是一个结果集，不需要参与查询。 select_type 查询类型。常见的有：1) SIMPLE&nbsp;简单的SELECT查询。没有UNION或子查询。2) PRIMARY&nbsp;最外层的SELECT语句。3) UNION&nbsp;UNION语句中的第二个或后面的查询。4) DEPENDENT UNION&nbsp;UNION语句中的第二个或后面的查询。取决于外层的查询。5) UNION RESULT&nbsp;UNION的结果集。6) SUBQUERY&nbsp;子查询中的第一个SELECT。7) DEPENDENT SUBQUERY&nbsp;子查询中的第一个SELECT。取决于外层的查询。8) DERIVED&nbsp;FROM子句中出现的子查询。也叫派生表。 table 查询的表名。1) 如果查询使用了别名，则显示该别名；2) 如果不涉及对数据表的操作，则显示NULL；3) &lt;unionM,N&gt; 表示引用id为M和N的执行计划UNION的结果；4) &lt;derivedN&gt; 表示引用id为N的执行计划中派生的表（临时表）；5) &lt;subqueryN&gt; 表示引用id为N的子查询的结果； partitions 使用的表分区。如果没有分区，则显示NULL。 type 关联类型。MySQL会认为任何查询都是关联查询，其性能从最好到最差依次为：1) system&nbsp;表中仅有一行数据。它是const的一个特列。2) const&nbsp;表中最多只有一个与之匹配的行。常见于使用唯一索引和常量值进行比较时。3) eq_ref&nbsp;当多表链接使用非空唯一索引作为关联条件的时候。 4) ref&nbsp;当使用唯一索引的最左前缀或非唯一索引时。5) fulltext&nbsp;使用全文索引进行关联。6) ref_or_null&nbsp;和ref相似，另外MySQL还会检索值为NULL的行。7) index_merge&nbsp;使用了索引合并优化。8) unique_subquery&nbsp;发生在IN子查询中，且子查询使用唯一索引。其形式为：&nbsp;value IN (SELECT primary_key FROM single_table WHERE some_expr)9) index_subquery&nbsp;与unique_subquery关联类型相似，其子查询使用的是非唯一索引，其形式为：&nbsp;value IN (SELECT key_column FROM single_table WHERE some_expr)10) rang&nbsp;只检索给定范围的行。常见于：&nbsp;=，&lt;&gt;，&gt;，&gt;=，&lt;，&lt;=，BETWEEN，IN11) index&nbsp;该关联类型与ALL相同，它扫描整个索引树，但通常比ALL要快。12) ALL&nbsp;全表扫描，这是最慢的一种关联类型。 possible_keys 查询中可能用到的索引。这些索引实际中可能并没有用到。如果值是NULL，则表明查询没有用到索引，此时可以检查WHERE子句中哪些列适合加索引以提高查询的性能。 key 查询中实际用到的索引。如果值是NULL，则表明MySQL找不到更有效的索引来执行查询。 key_len 使用到的索引的长度。 ref 使用哪些列或常量可以与索引列一起从表中选择行。 rows MySQL认为执行此查询需要检查的行数。对于InnoDB表来说，这是一个估算值，并不准确。该值越小越好。 filtered 通过条件过滤出的行数的百分比估计值。 Extra 显示MySQL是如何解析查询语句的其它信息。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"MySQL 查询缓存","date":"2018-03-23T14:33:13.000Z","path":"post/mysql-query-cache.html","text":"1. 版本信息123456SELECT VERSION();+------------+| version() |+------------+| 5.7.21-log |+------------+ 2. 查询缓存参数可以使用以下命令来查看MySQL查询缓存相关的系统参数配置： 1234567891011SHOW VARIABLES LIKE '%query_cache%';+------------------------------+---------+| Variable_name | Value |+------------------------------+---------+| have_query_cache | YES || query_cache_limit | 1048576 || query_cache_min_res_unit | 4096 || query_cache_size | 1048576 || query_cache_type | OFF || query_cache_wlock_invalidate | OFF |+------------------------------+---------+ 参数 描述 have_query_cache 表明查询缓存是否可用。当使用标准的MySQL二进制文件时，该项的值始终会显示YES，即使查询缓存已经关闭。 query_cache_limit 缓存单条查询结果的最大空间容量值。超出则不会缓存此次查询的结果。默认是1M (1048576(B)/1024/1024=1M)。 query_cache_min_res_unit 分配缓存区大小的最小单位。当查询的结果被缓存时，MySQL不会一次性将结果缓存到一个大的块中，而是每次分配一块该值大小的空间，使用完之后再分配另外一块，以此类推。默认是4KB (4096(B)/1024=4KB)。注意事项：1) 该参数值如果设置的过大，可能会造成大量的空间未能被完全使用，而产生内存碎片。2) 该参数值如果设置的太小，又可能会增加内存分配次数，进而产生时间上的消耗。 query_cache_size 查询缓存空间的大小。该值设置的如果不是1024的整数倍，MySQL自动调整降低最小量以达到1024的倍数。如果设置为0，则会禁用查询缓存。 query_cache_type 查询缓存的类型。可以用来控制查询缓存的开和关。 1) 0或OFF表示关闭查询缓存；2) 1或ON表示开启查询缓存；3) 2或DEMAND时：&nbsp;a) 当SELECT语句中出现SQL_NO_CACHE关键字时则不缓存；&nbsp;select SQL_NO_CACHE id, name from tb;&nbsp;b) 当出现SQL_CACHE关键字则缓存（默认是SQL_CACHE）。&nbsp;select SQL_CACHE id, name from tb; query_cache_wlock_invalidate 当写锁发生在表上的时，是否先失效该表相关的查询缓存。1) 设置为true，失效该表相关的查询缓存；2) 设置为false，仍然允许读取该表相关的查询缓存； 3. 查询缓存性能参数可以使用以下命令来查看查询缓存的性能参数： 12345678910111213SHOW STATUS LIKE 'Qcache%';+-------------------------+---------+| Variable_name | Value |+-------------------------+---------+| Qcache_free_blocks | 1 || Qcache_free_memory | 1029312 || Qcache_hits | 2 || Qcache_inserts | 2 || Qcache_lowmem_prunes | 0 || Qcache_not_cached | 1 || Qcache_queries_in_cache | 2 || Qcache_total_blocks | 6 |+-------------------------+---------+ 参数 描述 Qcache_free_blocks 查询缓存中的空闲内存块的数量。如果数值较大，说明有内存碎片产生。可以使用FLUSH QUERY CACHE命令对查询缓存中的内存块进行整理。 Qcache_free_memory 查询缓存中的空闲内存大小。 Qcache_hits 缓存命中的次数。每次命中，该数值+1。 Qcache_inserts 添加到查询缓存中的查询数量。每新缓存一个查询结果，该数值+1。 Qcache_lowmem_prunes 查询缓存可用空间不足时而删除的已缓存的查询的数量。如果数值较大，说明查询缓存的内存空间不足，或产生了大量的内存碎片。 Qcache_not_cached 非缓存查询的数量。每个查询的结果如果不能被缓存，该数值+1。 Qcache_queries_in_cache 查询缓存中的总的查询数量。 Qcache_total_blocks 查询缓存中的块的数量。 4. 查询缓存的开启和关闭MySQL5.7 默认没有开启查询缓存。如果需要开启查询缓存，找到安装目录下的my.ini(Windows)配置文件，添加如下配置，然后重启 MySQL 服务。 1234[mysqld]... ...... ...query_cache_type=1 或者使用命令行方式，该方式需要退出客户端再登录，才看得见状态改变： 1SET GLOBAL query_cache_type=1; set GLOBAL的变更是全局的，如果只想将变更应用于当前的会话，可是使用set SESSION的方式： 1SET SESSION query_cache_type=1; 5. 使用查询缓存MySQL 的查询缓存对查询语句的大小写是敏感的，只有当两个查询语句完全一致时，才会命中缓存。 第一次查询一张100万条数据的表，耗时1.63秒： 1234567SELECT COUNT(*) FROM emp;+----------+| count(*) |+----------+| 1000000 |+----------+1 row in set (1.63 sec) 第二次查询同一张表，耗时为0，可见是直接命中查询缓存： 1234567SELECT COUNT(*) FROM emp;+----------+| count(*) |+----------+| 1000000 |+----------+1 row in set (0.00 sec) 第三次查询将SELECT改写成select，耗时1.57秒，可见并没有命中缓存： 1234567select COUNT(*) FROM emp;+----------+| count(*) |+----------+| 1000000 |+----------+1 row in set (1.57 sec) 6. 整理查询缓存用于对查询缓存的内存块进行整理，减少内存碎片： 1FLUSH QUERY CACHE; 6. 清除查询缓存用于清除所有缓存的查询缓存结果： 1RESET QUERY CACHE;","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"解决命令行无法关闭和启动MySQL服务的问题","date":"2018-03-18T03:06:03.000Z","path":"post/mysql57-resolve-cmd-net-command.html","text":"命令行关闭和启动服务以管理员身份运行cmd，关闭MySQL服务，提示服务名无效： 1234&gt; net stop mysql服务名无效。 请键入 NET HELPMSG 2185 以获得更多的帮助。 以管理员身份运行cmd，启动MySQL服务，提示服务名无效： 1234&gt; net start mysql服务名无效。 请键入 NET HELPMSG 2185 以获得更多的帮助。 找到操作系统的服务列表：win + r –&gt; 输入services.msc回车。或： Win10系统 –&gt; 计算机管理 –&gt; 服务和应用程序 –&gt; 服务。 按字母键m搜索MySQL相关的服务，然后确认服务的名称和服务的路径。 启动服务的命令： 1&gt; net start 服务名称 关闭服务的命令： 1&gt; net stop 服务名称 如启动MySQL57的服务： 123&gt; net start MySQL57MySQL57 服务正在启动 ...MySQL57 服务已经启动成功。 如果在系统的服务列表中没有找到相应的服务。可按如下步骤进行安装服务。 如果是同一台机器上安装了多个MySQL服务，首先，先检查系统的PATH环境变量中是否配置了MySQL路径，如果有，先将其删除。 以管理员身份运行cmd，进入相应的MySQL安装的bin目录，执行mysqld --install 服务名称： 12D:\\application\\setup\\MySQL55\\bin&gt;mysqld --install MySQL55Service successfully installed 安装完成之后，你可以在操作系统的服务列表中找到一个名称为MySQL55的服务。可按上面步骤确认该服务的路径是否正确。确认无误后执行启动命令： 123&gt; net start MySQL55MySQL57 服务正在启动 ...MySQL57 服务已经启动成功。 如果想要卸载某个服务，可执行命令mysqld --remove 服务名称 12D:\\application\\setup\\MySQL55\\bin&gt;mysqld --remove MySQL55Service successfully removed.","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"MySQL5.7 安装","date":"2018-03-18T01:17:17.000Z","path":"post/mysql57-setup.html","text":"1. 安装包到MySQL官网下载安装应用包。点此下载 mysql-installer-community-5.7.21.0.msi 2. 安装 同意协议，进入下一步： 选择自定义安装，进入下一步： 选择需要安装的应用，这里只安装数据库服务，后续如果想添加应用可以重新执行安装包文件进行添加： 修改应用的安装路径： 然后点击下一步，开始安装： 安装完成后，对MySQL进行配置： 按默认选择，下一步： 按默认选择，下一步： 设置 root 账户的密码： 按默认选择，下一步： 按默认选择，下一步： 安装配置： 安装完配置之后，会跳回之前安装的界面： 配置已经完成，下一步： 完成安装： 3. 环境配置配置环境变量，将bin目录的路径加入系统的PATH变量中： 1PATH=;D:\\application\\setup\\MySQL57\\bin 检查链接是否成功：","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"程序员必知必会的 Linux Shell 命令","date":"2017-11-11T03:00:12.000Z","path":"post/linux-commands.html","text":"1. cd 命令change directory（更改目录）。 用于切换工作目录。是最基本的 Linux 操作系统命令。 1) 使用cd不带任何参数，可进入当前用户的主目录： 12[fanlychie@129host apache-tomcat-8.0.45]$ cd[fanlychie@129host ~]$ 2) 使用cd ~也可进入当前用户的主目录： 12[fanlychie@129host apache-tomcat-8.0.45]$ cd ~[fanlychie@129host ~]$ 3) 使用cd ..返回上级目录（..用于表示上级目录，如返回上两级目录则应为cd ../..）： 12[fanlychie@129host webapps]$ cd ..[fanlychie@129host apache-tomcat-8.0.45]$ 4) 使用cd -返回进入当前目录之前所在的目录： 123[fanlychie@129host apache-tomcat-8.0.45]$ cd -/home/fanlychie/apache-tomcat-8.0.45/webapps[fanlychie@129host webapps]$ 2. pwd 命令print work directory（打印工作目录）。 用于查看当前工作目录的路径，通常不需要带参数。 12$ pwd/home/fanlychie/apache-tomcat-8.0.45 3. mkdir 命令make directory（创建目录）。 用于创建文件系统的目录（文件夹）。 1) 创建一个名称为“dirname”的目录： 1$ mkdir dirname 2）使用-p, --parents选项，当创建的目录的父目录不存在时，父目录也会一起被创建： 1$ mkdir -p pathname/dirname 该命令用于创建“dirname”目录，如果其父目录“pathname”尚未存在，则“pathname”目录会被一起创建。 3) 使用{..}可以批量创建目录，如创建2018-01-01…2018-01-15…2018-01-31共31个目录： 1$ mkdir 2018-01-&#123;01..31&#125; 4) 使用{,}可以批量创建目录，如创建2018-01-01、2018-01-15、2018-01-31共3个目录： 1$ mkdir 2018-01-&#123;01,15,31&#125; 4. ls 命令list（列表信息）。 用于显示目录内容的列表信息。 1) 使用ls命令查看当前工作目录的列表信息： 12$ lsCatalina catalina.policy catalina.properties context.xml logging.properties server.xml tomcat-users.xml tomcat-users.xsd web.xml 2) 使用ll命令查看当前工作目录的列表信息： 1234567891011$ lltotal 220drwxr-xr-x. 3 fanlychie fanlychie 4096 2017-11-11 17:05:03 Catalina-rw-------. 1 fanlychie fanlychie 13688 2017-06-26 20:09:48 catalina.policy-rw-------. 1 fanlychie fanlychie 7299 2017-06-26 20:09:48 catalina.properties-rw-------. 1 fanlychie fanlychie 1577 2017-06-26 20:09:48 context.xml-rw-------. 1 fanlychie fanlychie 3387 2017-06-26 20:09:48 logging.properties-rw-------. 1 fanlychie fanlychie 6458 2017-11-11 17:24:47 server.xml-rw-------. 1 fanlychie fanlychie 2155 2017-11-11 18:23:43 tomcat-users.xml-rw-------. 1 fanlychie fanlychie 2634 2017-06-26 20:09:48 tomcat-users.xsd-rw-------. 1 fanlychie fanlychie 168496 2017-06-26 20:09:48 web.xml ll是ls -l命令的别名（-l选项是用长格式方式显示信息，其每一个内容项都占据一行）序号示例描述第一列drwxr-xr-x文件或目录的权限位描述符第二列3如果是一个文件，则表示文件的个数（数值必然是1）如果是一个目录，则表示其子目录（包含隐藏的）总数第三列fanlychie文件或目录的属主（即所有者）第四列fanlychie文件或目录的属组第五列4096文件的大小，单位是B第六列2017-11-11文件或目录最后变更的日期第七列17:05:03文件或目录最后变更的时间第八列Catalina文件或目录的名称其中，第一列drwxr-xr-x的第一位表示文件系统对象类型，剩下的九位以每三位为一组表示：常见的 Linux 文件系统对象类型有：类型描述-普通文件d目录（文件夹）l符号连接（包括软链接和硬链接），它实质指向另一个文件 3) 使用-a, --all选项，会把以.和..开头的隐藏文件或目录信息也罗列显示出来： 12345678910111213$ ll -atotal 228drwxr-xr-x. 3 fanlychie fanlychie 4096 2018-04-25 07:18:36 .drwxrwxr-x. 9 fanlychie fanlychie 4096 2017-11-11 17:04:10 ..drwxrwxr-x. 3 fanlychie fanlychie 4096 2017-11-11 17:05:03 Catalina-rw-------. 1 fanlychie fanlychie 13688 2017-06-26 20:09:48 catalina.policy-rw-------. 1 fanlychie fanlychie 7299 2017-06-26 20:09:48 catalina.properties-rw-------. 1 fanlychie fanlychie 1577 2017-06-26 20:09:48 context.xml-rw-------. 1 fanlychie fanlychie 3387 2017-06-26 20:09:48 logging.properties-rw-------. 1 fanlychie fanlychie 6458 2017-11-11 17:24:47 server.xml-rw-------. 1 fanlychie fanlychie 2155 2017-11-11 18:23:43 tomcat-users.xml-rw-------. 1 fanlychie fanlychie 2634 2017-06-26 20:09:48 tomcat-users.xsd-rw-------. 1 fanlychie fanlychie 168496 2017-06-26 20:09:48 web.xml 4) 罗列指定路径（文件或目录路径）下的内容信息，如查看“Catalina”目录下的内容信息： 123$ ll Catalinatotal 4drwxrwxr-x. 2 fanlychie fanlychie 4096 2018-04-24 11:21:47 localhost 5) 使用-t选项，可以按文件或目录的修改时间排序（最新的排在最前面, 即降序）： 1234567891011$ ll -ttotal 220-rw-------. 1 fanlychie fanlychie 2155 2017-11-11 18:23:43 tomcat-users.xml-rw-------. 1 fanlychie fanlychie 6458 2017-11-11 17:24:47 server.xmldrwxrwxr-x. 3 fanlychie fanlychie 4096 2017-11-11 17:05:03 Catalina-rw-------. 1 fanlychie fanlychie 13688 2017-06-26 20:09:48 catalina.policy-rw-------. 1 fanlychie fanlychie 7299 2017-06-26 20:09:48 catalina.properties-rw-------. 1 fanlychie fanlychie 1577 2017-06-26 20:09:48 context.xml-rw-------. 1 fanlychie fanlychie 3387 2017-06-26 20:09:48 logging.properties-rw-------. 1 fanlychie fanlychie 2634 2017-06-26 20:09:48 tomcat-users.xsd-rw-------. 1 fanlychie fanlychie 168496 2017-06-26 20:09:48 web.xml 6) 使用-r, --reverse选项，可以反向排序，默认是按文件或目录名称： 1234567891011$ ll -rtotal 220-rw-------. 1 fanlychie fanlychie 168496 2017-06-26 20:09:48 web.xml-rw-------. 1 fanlychie fanlychie 2634 2017-06-26 20:09:48 tomcat-users.xsd-rw-------. 1 fanlychie fanlychie 2155 2017-11-11 18:23:43 tomcat-users.xml-rw-------. 1 fanlychie fanlychie 6458 2017-11-11 17:24:47 server.xml-rw-------. 1 fanlychie fanlychie 3387 2017-06-26 20:09:48 logging.properties-rw-------. 1 fanlychie fanlychie 1577 2017-06-26 20:09:48 context.xml-rw-------. 1 fanlychie fanlychie 7299 2017-06-26 20:09:48 catalina.properties-rw-------. 1 fanlychie fanlychie 13688 2017-06-26 20:09:48 catalina.policydrwxrwxr-x. 3 fanlychie fanlychie 4096 2017-11-11 17:05:03 Catalina 7) 组合-r选项，按文件或目录的修改时间升序排序： 1234567891011$ ll -rttotal 220-rw-------. 1 fanlychie fanlychie 168496 2017-06-26 20:09:48 web.xml-rw-------. 1 fanlychie fanlychie 2634 2017-06-26 20:09:48 tomcat-users.xsd-rw-------. 1 fanlychie fanlychie 3387 2017-06-26 20:09:48 logging.properties-rw-------. 1 fanlychie fanlychie 1577 2017-06-26 20:09:48 context.xml-rw-------. 1 fanlychie fanlychie 7299 2017-06-26 20:09:48 catalina.properties-rw-------. 1 fanlychie fanlychie 13688 2017-06-26 20:09:48 catalina.policydrwxrwxr-x. 3 fanlychie fanlychie 4096 2017-11-11 17:05:03 Catalina-rw-------. 1 fanlychie fanlychie 6458 2017-11-11 17:24:47 server.xml-rw-------. 1 fanlychie fanlychie 2155 2017-11-11 18:23:43 tomcat-users.xml 8) 使用-S选项，可以按文件或目录的大小排序（最大的排在最前面，即降序）： 1234567891011$ ll -Stotal 220-rw-------. 1 fanlychie fanlychie 168496 2017-06-26 20:09:48 web.xml-rw-------. 1 fanlychie fanlychie 13688 2017-06-26 20:09:48 catalina.policy-rw-------. 1 fanlychie fanlychie 7299 2017-06-26 20:09:48 catalina.properties-rw-------. 1 fanlychie fanlychie 6458 2017-11-11 17:24:47 server.xmldrwxrwxr-x. 3 fanlychie fanlychie 4096 2017-11-11 17:05:03 Catalina-rw-------. 1 fanlychie fanlychie 3387 2017-06-26 20:09:48 logging.properties-rw-------. 1 fanlychie fanlychie 2634 2017-06-26 20:09:48 tomcat-users.xsd-rw-------. 1 fanlychie fanlychie 2155 2017-11-11 18:23:43 tomcat-users.xml-rw-------. 1 fanlychie fanlychie 1577 2017-06-26 20:09:48 context.xml 9) 使用-h, --human-readable选项，以易读方式来显示文件或目录的大小（默认大小是以B作为单位，-h, --human-readable选项会自动的将其转换为K或M或G单位来显示）： 1234567891011$ ll -htotal 220Kdrwxrwxr-x. 3 fanlychie fanlychie 4.0K 2017-11-11 17:05:03 Catalina-rw-------. 1 fanlychie fanlychie 14K 2017-06-26 20:09:48 catalina.policy-rw-------. 1 fanlychie fanlychie 7.2K 2017-06-26 20:09:48 catalina.properties-rw-------. 1 fanlychie fanlychie 1.6K 2017-06-26 20:09:48 context.xml-rw-------. 1 fanlychie fanlychie 3.4K 2017-06-26 20:09:48 logging.properties-rw-------. 1 fanlychie fanlychie 6.4K 2017-11-11 17:24:47 server.xml-rw-------. 1 fanlychie fanlychie 2.2K 2017-11-11 18:23:43 tomcat-users.xml-rw-------. 1 fanlychie fanlychie 2.6K 2017-06-26 20:09:48 tomcat-users.xsd-rw-------. 1 fanlychie fanlychie 165K 2017-06-26 20:09:48 web.xml 10) 使用-R, --recursive选项，可以递归显示路径下的子目录下的树信息： 1234567891011121314151617181920$ ll -R.:total 220drwxrwxr-x. 3 fanlychie fanlychie 4096 2017-11-11 17:05:03 Catalina-rw-------. 1 fanlychie fanlychie 13688 2017-06-26 20:09:48 catalina.policy-rw-------. 1 fanlychie fanlychie 7299 2017-06-26 20:09:48 catalina.properties-rw-------. 1 fanlychie fanlychie 1577 2017-06-26 20:09:48 context.xml-rw-------. 1 fanlychie fanlychie 3387 2017-06-26 20:09:48 logging.properties-rw-------. 1 fanlychie fanlychie 6458 2017-11-11 17:24:47 server.xml-rw-------. 1 fanlychie fanlychie 2155 2017-11-11 18:23:43 tomcat-users.xml-rw-------. 1 fanlychie fanlychie 2634 2017-06-26 20:09:48 tomcat-users.xsd-rw-------. 1 fanlychie fanlychie 168496 2017-06-26 20:09:48 web.xml ./Catalina:total 4drwxrwxr-x. 2 fanlychie fanlychie 4096 2018-04-24 11:21:47 localhost ./Catalina/localhost:total 4-rw-------. 1 fanlychie fanlychie 426 2018-04-24 11:21:47 context.xml 5. rm 命令remove（移除）。 用于删除文件或目录。 1) 使用-f, --force选项，强行执行删除操作，即使删除的文件不存在也不会出现警告。 1$ rm -f catalina.2017-11-12.log 2) 使用-r, -R, --recursive选项，可以删除一个目录（该目录下的所有文件和子目录都会被删除）： 1$ rm -r logs/ 3) 使用-v, --verbose选项，可以回显执行过程： 12$ rm -v catalina.2017-11-11.logremoved `catalina.2017-11-11.log` 6. mv 命令move（移动）。 用于移动文件或目录到另外一个目录中，也可用于重命名文件或目录。 1) 将源文件“zoo_sample.cfg”的名称重命名为“zoo.cfg”： 1$ mv zoo_sample.cfg zoo.cfg 2) 将源目录“config”的名称重命名为“conf”： 1$ mv config/ conf 3) 将“zoo_sample.cfg”文件移动到子目录“conf”中： 1$ mv zoo_sample.cfg conf/ 若“conf”中已存在一个名为“zoo_sample.cfg”的文件，则新的文件会直接覆盖老的文件。 4) 将文件“zoo_sample.cfg”移动到子目录“conf”中，并将文件重命名为“zoo.cfg”： 1$ mv zoo_sample.cfg conf/zoo.cfg 5) 将目录“node1”中的子目录“conf/”移动到目录“node2/”中： 1$ mv node1/conf/ node2/ 如果“node2”目录中已经存在一个名称为“conf”的子目录并且该子目录的内容不为空，则会报出警告，不能成功的进行移动。除非先把“node2”目录中的“conf”子目录删除或者使用-b选项（如果移动的文件或目录在目标目录中已经存在，则移动前会自动进行备份，备份的文件或目录默认是以原名称+~结束）进行移动：mv -b node1/conf/ node2/。 7. chmod 命令change mode（改变模式）。 用于变更文件或目录的权限。 Linux 系统的文件或目录是由读取(r)、写入(w)、执行(x)三种权限共同来决定。执行ll（ls -l）命令展示出来的第一列就是文件或目录的权限信息（参考「ls 命令」）。 属主 &nbsp;(u) ：文件或目录的创建者，或被指定的文件或目录的所有者； 属组 &nbsp;(g) ：文件或目录的所属用户组； 其它人 (o) ：既不是属主又不是属组里面的其它用户； 文件或目录的读取(r)、写入(w)、执行(x)权限控制： 字符 数值 描述 r 4 读取权限（如果是目录，那就是查看目录里面内容的权限） w 2 写入权限 x 1 执行权限（如果是目录，那就是切换（cd）到目录的权限） - 0 没有权限 假设现有一文件“my.sh”，其初始权限如下： 1-rw-r--r--. 1 fanlychie fanlychie 601 2018-04-25 09:43:38 my.sh 1) 给文件或目录赋权，属主u=r|w|x，属组g=r|w|x，其他人o=r|w|x，所有a=r|w|x： 1234$ chmod u=rwx my.sh $ lltotal 4-rwxr--r--. 1 fanlychie fanlychie 601 2018-04-25 09:43:38 my.sh 如果想要同时为多个所属组赋权，使用英文逗号分隔： 1234$ chmod g=rx,o=rx my.sh $ lltotal 4-rwxr-xr-x. 1 fanlychie fanlychie 601 2018-04-25 09:43:38 my.sh 2) 变更文件或目录的权限，属主u±r|w|x，属组g±r|w|x，其他人o±r|w|x，所有a±r|w|x（其中+为增加相应的权限，-为删除相应的权限）： 1234$ chmod o-x my.sh $ lltotal 4-rwxr-xr--. 1 fanlychie fanlychie 601 2018-04-25 09:43:38 my.sh 如果想要同时变更多个所属组权限，使用英文逗号分隔： 1234$ chmod u-x,g-x my.sh $ lltotal 4-rw-r--r--. 1 fanlychie fanlychie 601 2018-04-25 09:43:38 my.sh 3) 使用数值代码变更文件或目录的权限，如将“my.sh”的文件权限修改为“755”（“rwxr-xr-x”）： 1234$ chmod 755 my.sh $ lltotal 4-rwxr-xr-x. 1 fanlychie fanlychie 601 2018-04-25 09:43:38 my.sh 4) 使用-R, --recursive选项，可以修改一个目录以及该目录下所有的文件的权限： 123456789$ chmod -R 750 conf/$ ll -R.:total 4drwxr-x---. 2 fanlychie fanlychie 4096 2018-04-25 10:10:23 conf ./conf:total 4-rwxr-x---. 1 fanlychie fanlychie 601 2018-04-25 09:43:38 my.sh 8. chown 命令change owner（改变所有者）。 用于变更文件或目录的属主和属组。只有文件或目录的创建者或管理员用户才有权限操作。 ll（ls -l）命令展示出的第三和第四列分别就是文件或目录的属主和属组信息（参考「ls 命令」）。 1drwxr-xr-x. 3 root root 4096 2018-04-25 09:58:44 test 1) 变更文件或目录的属主和属组，chown 属主:属组 文件或目录： 12345678910111213# chown fanlychie:fanlychie test/# ll -R.:total 4drwxr-xr-x. 3 fanlychie fanlychie 4096 2018-04-25 09:58:44 test ./test:total 4drwxr-x---. 2 root root 4096 2018-04-25 10:10:23 conf ./test/conf:total 4-rwxr-x---. 1 root root 601 2018-04-25 09:43:38 my.cfg 使用-R, --recursive选项，可以变更目录以及该目录下所有内容的属主和属组： 12345678910111213# chown -R fanlychie:fanlychie test/# ll -R.:total 4drwxr-xr-x. 3 fanlychie fanlychie 4096 2018-04-25 09:58:44 test ./test:total 4drwxr-x---. 2 fanlychie fanlychie 4096 2018-04-26 05:30:17 conf ./test/conf:total 4-rwxr-x---. 1 fanlychie fanlychie 601 2018-04-25 09:43:38 my.cfg 9. cp 命令copy（复制）。 用于复制文件或目录。 1) 将“index.html”文件复制到“WEB-INF”目录中： 1$ cp index.html WEB-INF/ 2) 将“index.html”文件复制到“WEB-INF”目录中，并重命名为“index.htm”： 1$ cp index.html WEB-INF/index.htm 3) 使用-R, -r, --recursive选项，可以将一个目录中的所有内容复制到另外一个目录中。&nbsp;如将“jsp”目录（包括该目录以及该目录下的所有内容）复制到“WEB-INF”目录中： 1$ cp -r jsp/ WEB-INF/ 4) 如果复制的源文件或目录在目标目录中已经存在，则默认会覆盖目标目录中的文件或目录。&nbsp;使用-b选项可以备份目标目录中的文件或目录。备份的文件或目录的默认后缀名是是带~结尾。 1234567891011$ cp -b index.html WEB-INF/$ ll WEB-INF/total 44drwxr-xr-x. 20 fanlychie fanlychie 4096 2017-11-11 17:04:10 classes-rw-r--r--. 1 fanlychie fanlychie 1126 2018-04-26 06:06:21 index.html-rw-r--r--. 1 fanlychie fanlychie 1126 2018-04-26 06:04:57 index.html~drwxr-xr-x. 22 fanlychie fanlychie 4096 2018-04-26 06:03:07 jspdrwxr-xr-x. 2 fanlychie fanlychie 4096 2017-11-11 17:04:10 jsp2drwxr-xr-x. 2 fanlychie fanlychie 4096 2017-11-11 17:04:10 libdrwxr-xr-x. 2 fanlychie fanlychie 4096 2017-11-11 17:04:10 tags-rw-r--r--. 1 fanlychie fanlychie 14554 2017-06-26 20:09:51 web.xml 如果没有-b选项，则源文件“index.html”会直接覆盖“WEB-INF”目录中的“index.html”文件；若使用了-b选项，源文件“index.html”在覆盖“WEB-INF”目录中的“index.html”文件之前，“WEB-INF”目录中的“index.html”文件会自动做一个备份，备份的文件名称就是为“index.html~”； 10. scp 命令secure copy（安全复制）。 用于远程文件或目录的安全拷贝。它和cp命令类似，但cp命令只能在本机内对文件或目录进行拷贝。而scp命令能够在两台服务器之间跨服务器拷贝文件或目录。 1) 将“192.168.139.129”服务器中的“index.html”拷贝到“192.168.139.130”服务器中：&nbsp;语法：scp 本机源文件 远程登录主机的用户名@远程主机IP:复制到远程主机的目标路径 1$ scp index.html fanlychie@192.168.139.130:/home/fanlychie/test/ 如果远程目标机中已经存在该文件，则执行完命令之后，目标机中的文件将会被覆盖掉。 2) 使用-P选项，可以指定远程主机的端口号，默认是22端口，如果不是，可以使用该项来指定。 1$ scp -P 33 index.html fanlychie@192.168.139.130:/home/fanlychie/test/ 3) 使用-r选项，可以将本机的一个目录拷贝到另一台远程主机的目标目录中： 1$ scp -r jsp/ fanlychie@192.168.139.130:/home/fanlychie/test/ 如果远程目标机中已经存在该目录，则执行完命令之后，目标机中的目录将会被覆盖掉。 4) 除此之外，还可以反过来，在本机执行命令，将远程主机中的文件或目录拷贝到本机：&nbsp;语法：scp 远程登录主机的用户名@远程主机IP:远程主机的源文件 本机目录 1$ scp fanlychie@192.168.139.130:/home/fanlychie/test/index.html ./index.htm 远程拷贝目录与拷贝文件的方式相似，只需要加-r选项。 5) 将“192.168.139.129”中的“index.html”拷贝到“192.168.139.130”并重命名为“idx.html”： 1$ scp index.html fanlychie@192.168.139.130:/home/fanlychie/test/idx.html 拷贝目录与拷贝文件的方式相似，只需要加-r选项。 11. cat 命令concatenate（串联）。 用于将文件内容打印到标准输出设备上。适合用于查看小文件的内容。 1) 使用-n, --number选项，会对文件里面的每一行内容用数字进行编号： 12345678910111213141516171819202122$ cat -n zoo.cfg 1 # The number of milliseconds of each tick 2 tickTime=2000 3 4 # The number of ticks that the initial 5 # synchronization phase can take 6 initLimit=10 7 8 # The number of ticks that can pass between 9 # sending a request and getting an acknowledgement 10 syncLimit=5 11 12 # the directory where the snapshot is stored. 13 # do not use /tmp for storage, /tmp here is just 14 # example sakes. 15 dataDir=/home/fanlychie/zookeeper/data 16 17 18 dataLogDir=/home/fanlychie/zookeeper/logs 19 20 # the port at which the clients will connect 21 clientPort=2181 2) 使用-b, --number-nonblank选项，会对文件内容的非空白行用数字进行编号： 12345678910111213141516171819202122$ cat -b zoo.cfg 1 # The number of milliseconds of each tick 2 tickTime=2000 3 # The number of ticks that the initial 4 # synchronization phase can take 5 initLimit=10 6 # The number of ticks that can pass between 7 # sending a request and getting an acknowledgement 8 syncLimit=5 9 # the directory where the snapshot is stored. 10 # do not use /tmp for storage, /tmp here is just 11 # example sakes. 12 dataDir=/home/fanlychie/zookeeper/data 13 dataLogDir=/home/fanlychie/zookeeper/logs 14 # the port at which the clients will connect 15 clientPort=2181 3) 使用-s, --squeeze-blank选项，如果连续出现的多个空行就会压缩成一行显示： 123456789101112131415161718192021$ cat -s zoo.cfg # The number of milliseconds of each ticktickTime=2000 # The number of ticks that the initial# synchronization phase can takeinitLimit=10 # The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5 # the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/home/fanlychie/zookeeper/data dataLogDir=/home/fanlychie/zookeeper/logs # the port at which the clients will connectclientPort=2181 4) 去掉空白行： 12345678910111213141516$ cat zoo.cfg | grep -v ^$# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/home/fanlychie/zookeeper/datadataLogDir=/home/fanlychie/zookeeper/logs# the port at which the clients will connectclientPort=2181 其中，|是管道。^$是正则表达式，用于匹配空格。grep的用法可参考xxx。 5) 去掉“#”注释行： 12345678910111213$ cat zoo.cfg | grep -v ^#tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/fanlychie/zookeeper/data dataLogDir=/home/fanlychie/zookeeper/logs clientPort=2181 其中，|是管道。^#是正则表达式，用于匹配“#”开头的行。grep的用法可参考xxx。 6) 去掉空白行和注释行： 1234567$ cat zoo.cfg | grep -v ^$ | grep -v ^#tickTime=2000initLimit=10syncLimit=5dataDir=/home/fanlychie/zookeeper/datadataLogDir=/home/fanlychie/zookeeper/logsclientPort=2181 12. more 命令用于以分页的形式来展示文本文件的内容。适合用于查看较大文件的内容。 该命令每次显示一屏的内容，在屏幕的左下方会出现--More--(n%)的内容浏览进度条提示。此外，该命令还支持按键操作响应事件，常用的按键操作有： 按键 描述 回车键 前进一行（向下滚动一行） 空格键 前进一屏（向下滚动一屏） f 前进一屏（向下滚动一屏） b 后退一屏（向上滚动一屏） = 显示当前行的行号 q 退出命令 /pattern 搜索字符，匹配的字符不高亮，只能向下（向文件尾）搜索（按“n”键搜索下一个） 1) 使用-s选项，如果文件内容中连续出现的多个空行则会压缩成一行显示： 1$ more -s catalina.out 2) 使用+n选项，可以从指定的第n行开始显示，如从第37行开始显示： 1$ more +37 catalina.out 3) 使用-n选项，可以定义每屏显示的行数，如每屏显示10行： 1$ more -10 catalina.out 4) 使用+/pattern选项，可以从匹配到的搜索串处开始显示，如从“Exception”出现的地方开始显示： 1$ more +/Exception catalina.out 13. less 命令与more命令相似，但功能比more命令更强。用于以分页的形式来展示文本文件的内容。适合用于查看较大文件的内容。 该命令每次显示一屏的内容，同时它还支持按键操作响应事件，常用的按键操作有： 按键 描述 回车键 前进一行（向下滚动一行） 空格键 前进一屏（向下滚动一屏） f 前进一屏（向下滚动一屏） b 后退一屏（向上滚动一屏） d 前进半屏（向下滚动半屏） u 后退半屏（向上滚动半屏） q 退出命令 PgUp（↑） 向上翻一屏 PgDn（↓） 向下翻一屏 /pattern 向下搜索，匹配的字符高亮，按n在同一个方向搜索下一个，按N反方向搜索上一个 ?pattern 向上搜索，匹配的字符高亮，按n在同一个方向搜索下一个，按N反方向搜索上一个 1) 使用-s选项，如果文件内容中连续出现的多个空行则会压缩成一行显示： 1$ less -s catalina.out 2) 使用+n选项，可以从指定的第n行开始显示，如从第37行开始显示： 1$ less +37 catalina.out 3) 使用-n选项，可以定义每屏显示的行数，如每屏显示10行： 1$ less -10 catalina.out 4) 使用+/pattern选项，可以从匹配到的搜索串处开始显示，如从“Exception”出现的地方开始显示： 1$ less +/Exception catalina.out 5) 使用-N选项，显式文件内容的行号： 1less -N catalina.out 6) 使用-m选项，在右下角显示文件浏览进度的百分比数： 1less -m catalina.out 14. head 命令用来查看文件的前几行（默认是前10行）的内容。 1) 查看“catalina.out”文件（查看前10行）： 1$ head catalina.out 如果想查看指定的前几行，可以使用-n参数，例如查看前20行： 1$ head -20 catalina.out 15. tail 命令用来查看文件末尾的内容（默认是末尾10行）。 1) 查看“catalina.out”文件（查看末尾的10行）： 1$ tail catalina.out 如果想查看指定的末尾几行，可以使用-n参数，例如查看末尾20行： 1$ tail -20 catalina.out 2) 使用-f, --follow选项，可以跟随读取文件（常用于查看日志文件）： 1$ tail -f catalina.out 16. tar 命令tape archive（最初是用来在磁带上创建档案）。 用于将一个文件或目录打包压缩成一个文件，或用于将一个文件或目录从压缩包里解压缩出来。打包：它仅仅是将一个文件或一个目录下的所有内容汇总成一个总的文件；压缩：则是指通过某些算法（如gzip、bzip2），将一个文件压缩成一个体积更小的文件； 1) 将“logs”目录打包并压缩成“logs.tar.gz”文件： 1$ tar zcvf logs.tar.gz logs/ tar命令是汇总成“*.tar”文件。z选项是采用“gzip”算法压缩成“*.gz”文件。 2) 查看“*.tar.gz”压缩包文件里面的内容： 1$ tar ztvf logs.tar.gz 3) 解压缩“*.tar.gz”压缩包文件里面的内容： 1$ tar zxvf logs.tar.gz 17. ping 命令用于测试两台主机之间网络的连通性。 1) ping 主机 IP“192.168.1.100”的网络连通性： 12345$ ping 192.168.1.100PING 192.168.1.100 (192.168.1.100) 56(84) bytes of data.64 bytes from 192.168.1.100: icmp_seq=1 ttl=128 time=0.801 ms64 bytes from 192.168.1.100: icmp_seq=2 ttl=128 time=0.610 ms64 bytes from 192.168.1.100: icmp_seq=3 ttl=128 time=0.581 ms 按ctrl + c组合键中断。 2) ping 公网域名“baidu.com”的外网连通性（如果能ping通表明主机能正常访问外网，反之则不能）： 12345$ ping baidu.comPING baidu.com (220.181.57.216) 56(84) bytes of data.64 bytes from 220.181.57.216: icmp_seq=1 ttl=128 time=40.9 ms64 bytes from 220.181.57.216: icmp_seq=2 ttl=128 time=39.5 ms64 bytes from 220.181.57.216: icmp_seq=3 ttl=128 time=40.2 ms 3) 使用-c选项，可以指定 ping 的次数。如 ping 测试3次： 1$ ping -c 3 192.168.1.100 17. ssh 命令用于在一台Linux主机远程登录到另外一台Linux主机。 1) 用“fanlychie”账户登录到远程主机“192.168.139.129”，语法ssh 远程主机用户名@远程主机IP： 1$ ssh fanlychie@192.168.139.129 如果当前Linux主机是首次远程登录到目标主机，它会询问你“Are you sure you want to continue connecting (yes/no)?”键入“yes”敲回车即可。然后它会要求你输入远程主机用户名登录到主机IP的密码“fanlychie@192.168.139.129’s password:”键入密码敲回车即可。如果当前Linux主机也是以“fanlychie”账户登录的，则可以去掉登录远程主机的用户名： 1$ ssh 192.168.139.129它默认是以当前Linux主机登录的用户名登录远程IP主机。 2) 使用p选项，可以指定登录远程主机的端口（默认是22端口），例如指定33端口： 1$ ssh -p 33 fanlychie@192.168.139.129 18. 管道命令管道|，它能将上一个命令的正确执行的输出传递给下一个命令，作为下一个命令的标准输入。 1) 查看当前目录下的文件，按大小排序，然后分页查看： 123456$ ll -Sh | less总用量 79M-rw-rw-r-- 1 fanlychie fanlychie 5.5M 2018-05-10 09:07:23 webtest.log.2018-05-10-rw-rw-r-- 1 fanlychie fanlychie 3.9M 2018-05-09 12:22:33 servicetest.log.2018-05-09-rw-rw-r-- 1 fanlychie fanlychie 3.5M 2018-05-12 17:43:42 apptest.log.2018-05-12... ... 19. ps 命令process status（进程状态）。 用于查看当前系统运行的进程状态信息。该命令选项非常多，这里仅介绍常用的组合选项。 1) 使用-ef组合选项，可以查看当前系统所有的进程信息： 1234$ ps -efUID PID PPID C STIME TTY TIME CMD500 2878 1 0 12:37 pts/0 00:00:24 /usr/local/jdk1.8.0_144/bin/java -Djava.util.logging.config.file=/home/fanlychie/applications/apache-tomcat-8.0.45/conf/logging.properties... ... 如果想查看进程的PID或PPID可以选用该组合选项。其各字段的概述：字段描述UID进程所属的用户IDPID进程IDPPID进程的父IDCCPU使用比率STIME进程的启动时间TTY开始此进程的终端设备。“?”表示是系统启动的。“tty1”至“tty6”表示是本机上登录者程序。“pts/0”等，则表示为由网络连接进主机的程序。TIME进程使用的CPU总时间CMD启动进程的命令和参数 2) 使用aux组合选项（注意前面没有-），可以查看当前系统所有的进程信息： 1234$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND500 2878 0.1 18.3 2161124 89300 pts/0 Sl 12:37 0:27 /usr/local/jdk1.8.0_144/bin/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins... ... 如果想查看进程占用系统的内存和CPU信息可以选用该组合选项。其各字段的概述：字段描述USER进程的拥有者PID进程ID%CPU进程占用的CPU百分比%MEM进程占用的内存的百分比VSZ进程使用的虚拟内存大小，单位：KBRSS进程占用的固定内存大小，单位：KBTTY开始此进程的终端设备。“?”表示是系统启动的。“tty1”至“tty6”表示是本机上登录者程序。“pts/0”等，则表示为由网络连接进主机的程序。STAT进程的状态。常见的状态有：R：正在运行或可运行状态；S：处于休眠状态，等待被唤醒；Z：僵尸进程，程序已终止，进程无法正常退出；T：已停止或处于被追踪状态；D：不可中断，一般是在等待I/O；&lt;：优先级高的进程；N：优先级低的进程；s：进程领导者，在它之下有子进程；l：多线程的；START进程的启动时间TIME进程使用的CPU总时间COMMAND启动进程的命令和参数 3) 使用-eo选项，可以自定义显示的进程信息字段： 12345$ ps -eo pid,pcpu,pmem,cmd PID %CPU %MEM CMD 1 0.3 0.0 -bash 2 0.1 3.1 /usr/local/jdk1.7.0_72/bin/java ... ... 字段描述pid进程的IDpcpu进程的CPU百分占比%CPUpmem进程的内存百分占比%MEMcmd进程启动的命令CMD 4) 使用--sort选项，可以对指定的字段进行排序显示： 1234$ ps aux --sort -pmemUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 24742 0.1 3.1 2327664 123064 ? Sl 3月26 105:28 /usr/local/jdk1.7.0_72/bin/javaroot 648 0.0 0.7 331532 27592 ? Ssl 3月25 0:47 /usr/bin/python -pmem表示对进程的内存百分占比%MEM降序排序。-是降序，+升序（默认是升序）。 5) 找出最占内存的10个进程： 1$ ps aux --sort -pmem | head 20. kill 命令用于杀死一个进程。 该命令可以将给定的信号发送给指定的进程，如果没有给定明确的信号，则默认是发送15信号，该信号会终止进程。常用的信号有： 信号 描述 2 中断信号（ctrl + c） 9 强制终止 15 终止信号 19 暂停信号（ctrl + z） 1) 强制杀掉进程ID为“2878”的进程（可以结合ps命令来查看进程ID）： 1$ kill -9 2878 kill 9与kill -9的区别：kill 9：发送一个信号给进程并告诉进程，你需要终止运行。进程收到信号之后，并不会立刻停止运行，而是先释放占用的资源或者做一些其它的事情，并不会立即响应该信号，此进程仍然可能继续运行。kill -9：发送一个信号给进程并告诉进程，你需要立刻终止运行。该信号不能被捕获和忽略，进程收到后会立刻停止并退出。 21. top 命令用于查看进程占用系统资源的实时动态列表信息。 1$ top 该命令输出的内容信息比较丰富，默认是每隔3秒自动刷新一次列表信息： 第一行（系统整体的统计信息）： 22:35:29系统当前时间； up 26 days, 13:33系统连续运行的时间； 1 user当前登录系统的用户数； load average: 0.04, 0.03, 0.05系统分别在1、5、15分钟内的平均负载； 第二行（进程的统计信息）： 133 total进程的总数； 1 running正在运行的进程数； 132 sleeping休眠的进程数； 0 stopped停止的进程数； 0 zombie僵尸进程数； 第三行（CPU的统计信息）： 0.2 us用户占用的CPU百分比； 0.2 sy内核占用的CPU百分比； 99.6 id空闲的CPU百分比； 其余不一一列举了… 第四行（内存的统计信息）： 12139564 total物理内存的总大小； 1866952 free空闲可用的物理内存总大小； 6600492 used已经使用的物理内存总大小； 3672120 buff/cache缓冲内存的总大小； 第五行（交换分区的统计信息）： 2097148 total交换分区的总大小； 2062220 free空闲可用的交换分区的大小； 34928 used已经使用的交换分区的大小； 有时候，我们可能会看到CPU的使用率占比超过100%。这其实是因为top命令是按照单个CPU核数来计算的。也就是说，如果一台服务器的CPU核数为4核，那么该服务器的CPU使用率占比理论上最高可达到400%。当系统物理内存剩余量不是很富余的时候，那就应该引起注意了。Linux系统有一个OOM-killer（Out Of Memory killer）机制。当Linux内核检测到系统内存不足的时候，就会触发OOM-killer来挑选一个最耗内存的进程并杀掉这个进程以求释放一些内存出来。除此之外，top命令第一行的load average也很直观的反应出当前系统的性能指标，当数值是在0.00~1.00之间，则表示系统当前的状况良好。超过1.00则表示系统已经超出负荷。而实际上，我们也可能会看到服务器平均负载超过1.00的情况。这也跟服务器的CPU核数有关。如果一台服务器的CPU核数为4核，那么，该服务器的平均负载能力理论上可达到4.00。当系统平均负载达到总的70%左右时，就应该有所行动，在事情变得更糟糕之前，去分析其造成的原因。分析的焦点应放在后两项的数值，因为第一项是1分钟内的平均负载，时间太短，一瞬间的高并发导致该值大幅度上涨是很有可能的。 进程信息区，部分字段的描述概要： 字段 描述 PID 进程ID USER 进程所属者 VIRT 进程使用的虚拟内存总大小（KB） RES 进程使用的物理内存大小（KB） SHR 进程使用的共享内存的大小（KB） %CPU 上次更新到现在的CPU时间占用百分比 %MEM 进程使用的物理内存百分比 COMMAND 进程启动的命令名或命令行 top命令支持按键操作响应事件，常用的按键操作有： 按键 描述 P（shift + p） 按%CPU降序排序结果 M（shift + m） 按%MEM降序排序结果 N（shift + n） 按PID降序排序结果 1（数字键1） 查看每个核的CPU使用情况 s 刷新的时间间隔（默认是5秒） q 退出命令 1) 使用-d命令，可以指定列表信息刷新的时间间隔（默认是5秒）： 1$ top -d 2 2) 使用-p命令，可以指定特定的进程ID，只查看该进程的信息： 1$ top -p 12223 22. grep 命令用于搜索文本内容。它能帮助你从大量的数据中快速找到你想要的数据。 1) 查看“catalina.out”日志文件中，出现“ERROR”文本的行： 1$ grep ERROR catalina.out 2) 使用-n, --line-number选项，会对搜索匹配的行标记出其行号： 1$ grep -n ERROR catalina.out 3) 使用-e, --regexp选项，可以一次指定搜索多个文本： 1$ grep -n -e WARN -e ERROR catalina.out 用于搜索“catalina.out”文件中，出现“WARN”或“ERROR”文本的行。 4) 使用--color选项，可以在结果行中高亮显示搜索的文本： 1$ grep --color catalina.out 5) 使用-E, --extended-regexp选项（等效于egrep），可以使用正则表达式来搜索文本： 1$ egrep '\\b2018-05-17 11:[0-9]+' catalina.out 用于搜索以“2018-05-17 11:”开头的行（即用于查看2018-05-17日11时的日志信息）。常用的正则表达式表格：元字符描述^匹配搜索字符串开始的位置。如“^abc”用于匹配以“abc”字符串开头的行。如果用于中括号里面的第一个字符，则表示对字符集求反，如“[^abc]”用于匹配除了以“a”或“b”或“c”以外的其它字符开头的行。$匹配搜索字符串结尾的位置。如“abc$”用于匹配以“abc”字符串结尾的行。\\b锚定词首或词尾。如“\\bhello”表示以“hello”开始的词。.匹配除换行符“\\n”之外的任何单个字符。如“a.c”可以匹配“abc”或“a2c”等。?匹配零次或一次前面的字符或子表达式，等效于“{0,1}”。如“ab?c”可以匹配“abc”和“ac”。匹配零次或多次前面的字符或子表达式，等效于“{0,}”。如“abc”可以匹配“abc”和“ac”和“abbc”等。+匹配一次或多次前面的字符或子表达式，等效于“{1,}”。如“ab+c”可以匹配“abc”和“abbc”等。[ ]匹配中括号的开始和结尾。如“[abc]”匹配“plain”中的“a”。如“[a-z]”匹配26个小写英文字母。如“[0-9]”匹配0到9的数字。{n}匹配前面的字符或子表达式正好n次。如“ab{2}c”匹配“abbc”。{n,}匹配前面的字符或子表达式至少n次。如“ab{2,}c”匹配“abbc”和“abbbc”等。{,m}匹配前面的字符或子表达式至多n次。如“ab{,2}c”匹配“ac”和“abc”和“abbc”。{n,m}匹配前面的字符或子表达式至少n次，至多m次。如“ab{2,3}c”匹配“abbc”和“abbbc”。\\w匹配字母和数字，相当于“[0-9A-Za-z]”\\W匹配非字母和数字，相当于“[^0-9A-Za-z]” 6) 使用-v, --invert-match选项，可以反转查找： 1$ ps -ef | grep java | grep -v grep 查看“java”进程信息，并且将grep java行的信息排除掉。 7) 使用-R, -r, --recursive选项，可以从一个目录中的所有文件中搜索： 1$ grep -r ERROR logs/ 23. find 命令用于查找系统的文件。它能帮助你快速的定位和找到你想要的文件。语法：find [查找的目录] [选项] [参数] 1) 使用-name选项，可以按文件的名称进行查找： 1$ find . -name '*.log' 在当前目录（“.”表示当前目录，find命令查找时，会对给定的目录以及该目录下所有的子目录都进行查找）下，查找“*.log”文件。find命令支持通配（*），为避免*被bash进行扩展，因此需要加引号。 2) 使用-type选项，可以按文件类型进行查找： 1$ find . -type d 常见的文件类型有：文件类型描述f普通文件d目录l符号链接 3) 使用-mmin选项（last modified minutes），可以查找在指定时间被更改过的文件或目录： 1$ find . -name '*.log' -mmin -3 -3表示查找3分钟前。 4) 使用-exec command {} \\;选项，可以执行一个任意的command命令： 1$ find . -name '*.log' -exec cat &#123;&#125; \\; &gt; logs.txt 该命令是用于将当前目录下的所有的log文件的内容拼接成一个数据流重定向到logs.txt文件中。其中的{}是与-exec选项搭配使用的一个特殊符，它最终会被替换为find命令匹配到的每个文件的文件名称。 24. su 命令用于切换用户身份。用户身份变更时，需要输入变更的用户账户密码。特殊的，root用户切换到其它用户账户时，不需要密码。用户身份切换可以通过ctrl + d发送一个 exit 信号，用于快捷退出当前登录的用户账户，以返回切换前的用户身份。 su [user]可以切换当前的用户身份。默认su是切换为root用户： 1$ su 它等效于： 1$ su root 切换为“testusr”用户： 1$ su testusr 切换用户身份后，不会改变用户所在的当前目录。如切换用户前是在“/home/fanlychie/myconfig”目录下，切换用户后还是在“/home/fanlychie/myconfig”目录下。 su - [user]切换当前的用户身份，并将工作目录改变为目标用户的“home”目录： 1$ su - testusr 例如切换用户前是在“/home/fanlychie/myconfig”目录下，切换用户后是在“/home/testusr”目录下。 25. 前台和后台任务后台进程也叫守护进程，是运行在系统后台的一种特殊的进程，它脱离了终端控制台的控制。前台进程是用户使用有控制终端的进程，它通常以窗口或对话框的形式展现。 如果想要将一个进程放到后台去运行，只需在命令的末尾加&amp;： 1$ java -jar spring-boot-application.jar &amp; 一般情况下，当用户退出终端时，用户启动的后台进程也会跟着退出。为了使进程可靠的在后台不间断的运行，可以使用nohup command &amp;。 1$ nohup java -jar spring-boot-application.jar &amp; 默认情况下，nohup命令会将标准输出和标准错误输出重定向到当前目录下的“nohub.out”文件中。nohup并不能让进程在后台运行，但能让进程忽略挂断信号。用户退出终端或网络断开的情况下，nohup进程不会退出。 当我们使用nohup command &amp;命令启动一个后台进程时，我们可能并不希望日志信息输出到前台或“nohub.out”文件中，特别是在使用脚本启动一个后台进程时。 1$ nohup java -jar spring-boot-application.jar &gt;/dev/null 2&gt;&amp;1 &amp; &gt;/dev/null中的：&gt;表示重定向到某个地方。默认是标准输出，即&gt;等效于1&gt;。/dev/null是系统的空设备文件，经常被用来当做垃圾箱使用。也有人把它比作“黑洞”，因为所有输出到这里的东西都会消失的无影无踪，在终端上也不会显示任何信息。 2&gt;&amp;1中的：&gt;&amp;是等同于的意思。2&gt;&amp;1则是表示将标准错误重定向到与标准输出相同的地方。 总的来说，这条命令的言外之意就是在后台启动一个服务，服务启动输出的信息和错误信息都不要显示在终端。 上面涉及到的“1”和“2”是文件描述符，文件描述符是用来描述输入和输出的整数。最常见的文件描述符： 文档类型 说明 文件描述符 stdin 标准输入 0 stdout 标准输出 1 stderr 标准错误 2 后台的任务（或称进程，或称作业）可以使用jobs命令来查看： 123$ jobs[1]- Running nohup java -jar spring-boot-application.jar &gt; /dev/null 2&gt;&amp;1 &amp;[2]+ Stopped tail -f nohup.out 其中，[num]里面的数字表示的是任务序号，+号表示默认选择的任务。-号的任务需要通过任务序号来选择。 使用fg [num]命令可以将一个后台进程切换到前台，若fg命令后面没有指定任务序号，表示切换至默认的任务，即带+号的任务： 1$ fg 其等效于： 1$ fg 2 通过使用组合键ctrl + z也可以将一个前台进程暂停并且放到后台中。比如通过vi编辑文件或通过tail查看文件的时候，ctrl + z将其放入后台后，可以非常方便的切换回来。 命令bg [num]可以让一个后台暂停的进程变为继续运行。同样的，若bg命令后面没有指定任务序号，表示默认选择带+号的任务： 1$ bg 其等效于： 1$ bg 2 后台进程可以先切换至前台然后按ctrl + c强制中断杀死进程。也可以通过kill %num来杀死。 1$ kill %2 26. 磁盘空间系统的磁盘空间是一种有限的存储介质资源。当系统磁盘空间使用快要爆满时，我们需要删除或移走部分文件以腾出更多可用的磁盘空间。掌握如何去查看服务器的磁盘空间的使用情况这就显得很重要了。df和du是 Linux 系统中用于查看系统磁盘使用情况的两个重要命令。 df（disk free，磁盘可用空间），用于查看服务器磁盘空间的使用情况： 12345$ df -hFilesystem Size Used Avail Use% Mounted on/dev/sda2 19G 3.1G 15G 18% /tmpfs 238M 0 238M 0% /dev/shm/dev/sda1 291M 34M 242M 13% /boot 参数-h, –human-readable是使用易读格式（人类更易懂的）, 将数值自动转换为常见 M、G 等单位显示。 其中，Size 是磁盘总的容量，Used 是已用的空间，Avail 是剩余可用的空间（重要），Use% 是已用的空间的百分比。 du（disk usage，磁盘使用），用于查看文件或目录占用的磁盘空间大小： 123$ du -h logs81M logs/app149M logs 参数-h, –human-readable是使用易读格式（人类更易懂的）, 将数值自动转换为常见 M、G 等单位显示。 可以看出，logs目录总共占149M的磁盘空间。其中，logs/app目录共占81M，剩余的68M被logs根目录下的文件占用。如果想要查看各个文件占用的磁盘空间，可以追加使用-a, –all参数： 12345678$ du -ha logs332K logs/demo1.log20K logs/demo2.log68M logs/demo3.log49M logs/app/app-demo2.log33M logs/app/app-demo1.log81M logs/app149M logs 参数-s，--summarize仅显示总计，如统计当前路径下所有的文件或目录占用的磁盘空间： 123$ du -sh *1.2G apps149M logs 如果只是想统计当前路径占用的磁盘空间可以使用du -sh（等效于：du -sh .）： 12$ du -sh1.3G . 27. 内存空间free命令可用于查看系统内存的使用情况。 1234$ free -h total used free shared buff/cache availableMem: 11G 6.7G 155M 75M 4.7G 4.4GSwap: 2.0G 20M 2.0G 参数-h, –human-readable是使用易读格式（人类更易懂的）, 将数值自动转换为常见 M、G 等单位显示。 参数 描述 total 总的内存。 used 已使用的内存。 free 可用的内存。 shared 多个进程共享的内存。 buff/cache 缓冲区和缓存使用的内存。 available 可用的内存。当系统内存不足（没有足够的free内存可用时），就会从buff/cache中回收部分空间，以满足应用程序的需求。这是一个理想的值，它往往存在一些误差。 第一行Mem表示物理内存。第二行Swap是交换空间，它是磁盘上的一块区域。当系统的物理内存吃紧时，Linux 就会将内存中不常用的数据存储到 swap 分区上，这样就能腾出一些内存空间来为其他应用程序服务。当系统需要用到 swap 分区上存储的数据时，Linux 再将这些数据调入内存中。这就是换入和换出。swap 分区可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。 28. wc 命令word count（单词统计）。 用于统计文件或从标准设备读入的数据的行数、单词数和字符数。 参数-c, --bytes用于统计字符数： 12$ wc -c zookeeper.out 60669 zookeeper.out 参数-w, --words用于统计单词数： 12$ wc -w zookeeper.out 4169 zookeeper.out 参数-l, --lines用于统计行数： 12$ wc -l zookeeper.out 491 zookeeper.out 29. netstat 命令用于查看系统的网络状态信息。 使用-ant组合选项，可以查看所有的TCP连接状态信息： -a, –all显示所有的socket链接-n, –numeric使用数字类型的IP地址显示-t, –tcp只显示TCP传输协议的链接 1234567$ netstat -antProto Recv-Q Send-Q Local Address Foreign Address Statetcp6 0 0 :::20818 :::* LISTENtcp6 0 0 :::20809 :::* LISTENtcp6 0 0 10.10.10.171:20818 10.10.10.170:55648 ESTABLISHEDtcp6 0 0 10.10.10.171:20818 10.10.10.170:34580 ESTABLISHEDtcp6 0 0 10.10.10.171:20809 10.10.10.176:26379 ESTABLISHED 字段描述Local Address本地地址和端口信息Foreign Address远程地址和端口信息State状态信息。常见的状态有：LISTEN：本地监听的端口；ESTABLISHED：远程访问本机服务的地址和端口信息；TIME_WAIT：链接已挂断，socket在网络上等待结束； 使用-lntp组合选项，可以查看系统监听端口的所有进程信息： -l, –listening只显示监听中的socket链接-n, –numeric使用数字类型的IP地址显示-t, –tcp只显示TCP传输协议的链接-p, –program显示正在使用此socket的进程PID和进程名称 12345$ netstat -lntpProto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp6 0 0 :::20811 :::* LISTEN 20369/java tcp6 0 0 :::20813 :::* LISTEN 20465/java tcp6 0 0 :::20815 :::* LISTEN 20489/java 查找某个端口被哪个进程占用： 12$ netstat -lntp | grep 8080tcp6 0 0 :::8080 :::* LISTEN 7596/java 由此可见，8080端口被进程PID为7596的程序占用。然后可以通过ps命令查找出该进程所属的程序： 12$ ps -ef | grep 7596joinpay 7596 1 0 7月09 ? 00:04:26 /usr/local/jdk1.7.0_72/... 统计某个端口的服务当前的链接数量。如统计“20818”端口： 12$ netstat -ant | grep \":20818\" | wc -l21 30. vi 命令vi是 Linux 系统中的一个强大的编辑器。可用于文本的写入、替换、删除、查找等。vi编辑器的三种模式：1．命令模式：可以控制光标移动、字符或行等的删除或复制等操作；2．插入模式：顾名思义就是插入文本，只有在该模式下才可以输入字符；3．底行模式：可以设置编辑器环境、字符查找、文件保存和退出等操作； 在命令模式下可以通过按键进行： 按键 说明 j 光标向下移动（ ↓ ） k 光标向上移动（ ↑ ） h 光标向左移动（←） l 光标向右移动（→） gg 文首 G 文尾 nG n是一个数字，定位到第n行 0 行首（数字0） ^ 行首 $ 行尾 dd 删除光标所在的行 yy 复制光标所在的行 x 从光标高亮处（包括高亮处）开始向后（右）删除字符 X 从光标高亮处（不包括高亮处）开始向前（左）删除字符 p 将复制的内容粘贴在光标所在行的下一行 P 将复制的内容粘贴在光标所在行的上一行 u 还原动作 . 重复动作 ?word 向上查找word字符串 /word 向下查找word字符串 n 同方向搜索（如果是“?”则是向上搜索，如果是“/”则是向下搜索） N 反方向搜索（如果是“?”则是向下搜索，如果是“/”则是向上搜索） 在命令模式下，通过以下的操作可以进入插入模式： 按键 说明 i 在光标高亮处之前插入 I 在光标所在行的行首插入 a 在光标高亮处之后追加 A 在光标所在行的行尾插入 o 在光标所在行的下一行插入一个空行 O 在光标所在行的上一行插入一个空行 Esc 退出插入模式，回到命令模式 在命令模式下，通过以下的操作可以进入底行模式： 按键 说明 :w 保存 :q 退出 :w! 强制写入保存 :q! 强制退出 :wq 保存退出 :wq! 强制保存退出 :set nu 显示行号 :set nonu 不显示行号 :nohl 退出匹配的高亮显示 :s/表达式/替换字符/ 替换当前行匹配到的第一个处 :s/表达式/替换字符/g 替换当前行匹配到的所有处 :%s/表达式/替换字符/g 替换文档中匹配到的所有处 ZZ 保存退出 ZQ 不保存退出 编辑“hello.txt”文件： 1$ vi hello.txt 其文件内容如下： 1hello world输入:%s/o/O/g可将全部的“o”替换成“O”。 vi命令除了可以用来编辑文件之外，使用它来查看日志文件也是一个利器： 1$ vi -R my.log -R是只读模式，为避免不小心编辑到日志文件，最好加上此参数项。在vi编辑器里，你可以利用它强大的命令快捷的查看日志文件的内容。 N. rpm 命令RedHat Package Manager（RedHat Linux操作系统的软件包管理工具）。 用于对“*.rpm”软件包进行安装、查询、卸载等。 N. vi 命令01. 命令执行控制使用;，||，&amp;&amp;分隔符，可以在一个命令行中执行多条命令。 [ ; ] 1$ command1 ; command2 [ ; command3 ...] command1执行不管成功与否，command2总是会继续执行。它相当于： 12$ command1$ command2 示例：进入目录，罗列指定字符开头的文件。 1$ cd logs/ ; ll spring-boot-demo* [ || ] 1$ command1 || command2 [ || command3 ...] command1执行失败时，command2才执行。command1执行成功时，command2不执行。即或逻辑。 示例：关闭防火墙，如果操作失败，输出 fail。 1$ service iptables stop || echo \"fail\" [ &amp;&amp; ] 1$ command1 &amp;&amp; command2 [ &amp;&amp; command3 ...] command1执行成功时，command2才执行。command1执行失败时，command2不执行。即与逻辑。 示例：启动 Tomcat 应用，启动命令执行成功后，打开控制台查看日志。 1$ ./bin/startup.sh &amp;&amp; tail -f logs/catalina.out 02. 后台进程如果想要将一个进程放到后台去运行，只需在命令的末尾加&amp;。 示例：启动服务，并让其在后台运行。 1$ java -jar spring-boot-application.jar &amp; 一般情况下，当用户退出终端时，用户启动的后台进程也会跟着退出。为了使进程可靠的在后台不间断的运行，可以使用nohup command &amp;。 示例：启动服务，并让其在后台不间断的运行。 1$ nohup java -jar spring-boot-application.jar &amp; 默认情况下，nohup命令会将标准输出和标准错误输出重定向到当前目录下的nohub.out文件中。nohup并不能让进程在后台运行，但能让进程忽略挂断信号。用户退出终端或网络断开的情况下，nohup进程不会退出。 03. 文件描述符文件描述符是用来描述输入和输出的整数。最常见的文件描述符： 文档类型 说明 文件描述符 stdin 标准输入 0 stdout 标准输出 1 stderr 标准错误 2 示例：启动服务，并让其在后台不挂断的运行。 1$ nohup java -jar spring-boot-application.jar &gt;/dev/null 2&gt;&amp;1 &amp; 上面已经介绍了nohup command &amp;。我们这里主要来分析&gt;/dev/null 2&gt;&amp;1片段的含义和作用： 第一部分：&gt;是重定向到某个地方。默认是标准输出，即&gt;等效于1&gt;。 第二部分：/dev/null是系统的空设备文件，经常被用来当做垃圾箱使用。也有人把它比作“黑洞”，为所有输出到这里的东西都会消失的无影无踪，在终端上也不会显示任何信息。 第三部分：&gt;&amp;是等同于的意思。2&gt;&amp;1则是将标准错误重定向到与标准输出相同的地方。 综上所述，这条命令的中心思想是：在后台运行服务，启动输出的信息和错误信息都不要显示在终端。 04. 前后台任务互切上面介绍了&amp;将进程放到后台去运行，使用jobs命令可查看后台进程： 123$ jobs[1]- Running nohup java -jar spring-boot-application.jar &gt; /dev/null 2&gt;&amp;1 &amp;[2]+ Stopped tail -f nohup.out []里面的数字表示的是任务序号，+号表示默认选择的任务。-号的任务需要通过任务序号来选择。 fg [任务序号]可以将一个后台进程切换到前台，若fg命令后面没有指定任务序号，表示切换至默认的任务，即带+号的任务： 1$ fg 1 组合键ctrl + z也可以将一个前台进程放到后台并且暂停。比如通过vi编辑文件或通过tail查看文件的时候，ctrl + z将其放入后台后，可以非常方便的切换回来。 bg [任务序号]可以让一个后台暂停的进程变为继续运行。同样的，若bg命令后面没有指定任务序号，表示默认选择带+号的任务： 1$ bg 1 后台进程可以先切换至前台然后按ctrl + c强制中断杀死进程。也可以通过kill %任务序号来杀死。 1$ kill %2 05. 管道管道“|”可以将上一个命令的标准输出传递到下一个命令，并作为下一个命令的标准输入。 1$ command1 | command2 [ | command3 ...] 查看目录下的文件，并显示行号： 12345$ ll | cat -n 1 total 40 2 drwxr-xr-x. 2 fanlychie fanlychie 4096 Nov 5 00:24 Desktop 3 drwxr-xr-x. 2 fanlychie fanlychie 4096 Nov 5 00:23 Documents 4 drwxr-xr-x. 2 fanlychie fanlychie 4096 Nov 5 00:23 Downloads 06. 空格在 shell 编程中，空格是一个分隔符。一个常见的错误是： 123#!/bin/bashname = fanlychieecho $name 执行的时候就会报：line 2: name: command not found。原因是=两边有空格，shell 会认为空格前面是一个命令，因此会报命令找不到的错误。 在 shell 编程中，空格的用法常见的有： 命令和选项之间必须有空格； 赋值符号=两边不能有空格； 测试语句[的两边要有空格，]的左边要有空格。如if [ condition ]； 分隔符;、||、&amp;&amp;两边的空格可有可无； 管道|两边的空格可有可无； 07. 引号当操作一个字符串时，如果该字符串中含有空格，那么，空格前面的字符就会被当成命令来执行。被引号包裹起来的字符串，shell 会将它当成一个普通的字符串对待，而不会去解析成命令来执行。 单引号 单引号&#39;&#39;包裹的内容是所见即所得。 123#!/bin/bashsayhi='hello world'echo $sayhi 执行结果：hello world 单引号里面引用的变量无效（所见即所得，任何变量都不会被替换）。 123#!/bin/bashsayhi='hello world'echo 'You have one new message: $sayhi' 执行结果：You have one new message: $sayhi 双引号 双引号&quot;&quot;包裹的内容，可以引用外部定义的变量。 123#!/bin/bashsayhi=\"hello world\"echo \"You have one new message: $sayhi\" 执行结果：You have one new message: hello world 反引号 反引号``（键盘左上角Esc正下方的键）包裹的内容，可以用于存储命令的输出，即命令替换。 1$ echo \"curr time: `date`\" 执行结果：curr time: Sat Nov 11 14:17:15 UTC 2017 10. 文本搜索文本搜索能力很重要。它能帮助你从大量的数据中快速定位和找到你想要的数据。常用的是通过grep命令完成。语法：grep [OPTIONS] PATTERN [FILE...] 示例：查找日志文件中，所有出现“ERROR”字符串的地方： 1$ grep ERROR access.log 示例：查找日志文件中，所有出现“ERROR”字符串的地方，并打印行号： 参数：-n, --line-number 释义：搜索的结果显示文本在文件中的行号 1$ grep -n ERROR access.log 示例：查找日志文件中，所有出现“ERROR”字符串的地方，并打印行号高亮显示： 参数：--color 释义：匹配的文本会被不同颜色高亮显示 1$ grep -n --color ERROR access.log 示例：查找目录下所有的日志文件中，所有出现“ERROR”字符串的地方，并打印行号高亮显示： 1$ grep -n --color ERROR *.log 示例：查找日志文件中，所有出现“ERROR”或“WARN”字符串的地方，并打印行号高亮显示： 参数：-e, --regexp 释义：允许指定多个不同的搜索字符串 1$ grep -n --color -e ERROR -e WARN access.log 示例：查找日志文件中，所有出现“Exception”字符串的地方，并打印行号高亮显示： 参数：-E, --extended-regexp 释义：允许搜索串中使用正则表达式 1$ grep -En --color '\\b\\w+Exception\\b' access.log egrep等效于grep -E。可以在搜索串中使用正则表达式来匹配。 1$ egrep -n --color '\\b\\w+Exception\\b' access.log 示例：查找日志文件中，最近出现“Exception”字符串的10个地方，并打印行号： 1$ egrep -n '\\b\\w+Exception\\b' access.log | tail 附正则表达式表： 元字符 描述 ^ 匹配搜索字符串开始的位置。如“^abc”用于匹配以“abc”字符串开头的行。如果用于中括号里面的第一个字符，则表示对字符集求反，如“[^abc]”用于匹配除了以“a”或“b”或“c”以外的其它字符开头的行。 $ 匹配搜索字符串结尾的位置。如“abc$”用于匹配以“abc”字符串结尾的行。 . 匹配除换行符“\\n”之外的任何单个字符。如“a.c”可以匹配“abc”或“a2c”等。 ? 匹配零次或一次前面的字符或子表达式，等效于“{0,1}”。如“ab?c”可以匹配“abc”和“ac”。 * 匹配零次或多次前面的字符或子表达式，等效于“{0,}”。如“ab*c”可以匹配“abc”和“ac”和“abbc”等。 + 匹配一次或多次前面的字符或子表达式，等效于“{1,}”。如“ab+c”可以匹配“abc”和“abbc”等。 [] 匹配中括号的开始和结尾。如“[abc]”匹配“plain”中的“a”。如“[a-z]”匹配26个小写英文字母。如“[0-9]”匹配0到9的数字。 {n} 匹配前面的字符或子表达式正好n次。如“ab{2}c”匹配“abbc”。 {n,} 匹配前面的字符或子表达式至少n次。如“ab{2,}c”匹配“abbc”和“abbbc”等。 {,m} 匹配前面的字符或子表达式至多n次。如“ab{,2}c”匹配“ac”和“abc”和“abbc”。 {n,m} 匹配前面的字符或子表达式至少n次，至多m次。如“ab{2,3}c”匹配“abbc”和“abbbc”。 \\w 匹配字母和数字，相当于“[0-9A-Za-z]” \\W 匹配非字母和数字，相当于“[^0-9A-Za-z]” 示例：从标准输入中搜索出现“java”字符的地方： 123$ ps -ef | grep javaroot 1807 1 0 Nov11 ? 00:01:38 /usr/local/jdk1.8.0_144/bin/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins -jar /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --daemon --httpPort=8080 --debug=5 --handlerCountMax=100 --handlerCountMaxIdle=20500 4621 4164 0 00:23 pts/2 00:00:00 grep java ps是用来查看进程信息，后续会讲到。看回上面输出的最后一行，通常情况下，它不是我们想要的，我们可以使用-v（--invert-match，反转匹配。即除了匹配外的其他所有行）参数将它过滤掉： 12$ ps -ef | grep java | grep -v greproot 1807 1 0 Nov11 ? 00:01:38 /usr/local/jdk1.8.0_144/bin/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins -jar /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --daemon --httpPort=8080 --debug=5 --handlerCountMax=100 --handlerCountMaxIdle=20 示例：递归搜索目录下的所有文件中出现“Exception”的地方，并打印行号高亮显示： 参数：-R, -r, --recursive 释义：从给定的目录开始递归所有的子目录 1$ egrep -rn --color '\\b\\w+Exception\\b' 11. 文件搜索文件搜索的能力也很重要。它能帮助你快速的找到你想要的文件。常用的是通过find命令完成的。 示例：查找目录下的某个文件： 参数：-name 释义：根据文件的名称搜索 12$ find . -name 'logging.properties'./conf/logging.properties 示例：使用通配符查找目录下的所有的.properties文件： 1$ find . -name '*.properties' 示例：查看目录下的所有的子目录： 参数：-type 释义：根据文件的类型搜索，常用的d（directory，目录）、f（regular file，文件） 1$ find . -type d 示例：查看目录下的所有的文件： 1$ find . -type f 示例：查找3分钟之内有流量进来的日志文件： 参数：-mmin（最后一次修改文件的时间） 释义：最近一次文件内容被修改的时间 1$ find . -name '*.log' -mmin -3 示例：高级用法，执行一个命令。 参数：-exec command {} \\; 释义：执行一个任意的command命令。 备注：{}是一个与-exec搭配使用的特殊符，它会被替换为find命令匹配到的每个文件的文件名称。 1$ find . -type f -name '*.log' -exec cat &#123;&#125; \\; &gt; demo.txt 达到的效果就是，将当前所有的log文件的内容拼接成一个数据流重定向到demo.txt文件中。 12. 进程信息当前系统运行的所有进程信息都可以用ps命令来查看，搭配kill命令可以随时杀死某个进程。 示例：查看当前系统所有的进程信息，常用的组合参数是-ef或aux（注意参数前面没有-）： 123$ ps -efUID PID PPID C STIME TTY TIME CMD500 2878 1 0 12:37 pts/0 00:00:24 /usr/local/jdk1.8.0_144/bin/java -Djava.util.logging.config.file=/home/fanlychie/applications/apache-tomcat-8.0.45/conf/logging.properties 字段 描述 UID 进程所属的用户ID PID 进程ID PPID 进程的父ID C CPU 使用比率 STIME 进程的启动时间 TTY 开始此进程的终端设备。“?”表示是系统启动的与终端无关。“tty1”至“tty6”表示是本机上登录者程序。“pts/0”等，则表示为由网络连接进主机的程序。 TIME 进程使用的 CPU 总时间 CMD 启动进程的命令和参数 123$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND500 2878 0.1 18.3 2161124 89300 pts/0 Sl 12:37 0:27 /usr/local/jdk1.8.0_144/bin/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins 字段 描述 USER 进程的拥有者 PID 进程ID %CPU 进程占用的 CPU 百分比 %MEM 进程占用的内存的百分比 VSZ 进程使用的虚拟内存大小，单位：KB RSS 进程占用的固定内存大小，单位：KB TTY 开始此进程的终端设备。“?”表示是系统启动的与终端无关。“tty1”至“tty6”表示是本机上登入者程序。“pts/0”等，则表示为由网络连接进主机的程序。 STAT 进程的状态。常见的状态有：R：正在运行或可运行状态；S：处于休眠状态，等待被唤醒；Z：僵尸进程，程序已终止，进程无法正常退出；T：已停止或处于被追踪状态；D：不可中断，一般是在等待I/O；&lt;：优先级高的进程；N：优先级低的进程；s ：进程领导者，在它之下有子进程；l：多线程的； START 进程的启动时间 TIME 进程使用的 CPU 总时间 COMMAND 启动进程的命令和参数 小结：ps命令的参数项非常多，掌握常用的参数组合项即可。如果只是查看进程的PID或PPID信息可选用ps -ef；如果要查看进程的PID和占用系统的内存和CPU信息可选用ps aux。 &nbsp; 示例：使用ps命令列出的进程信息会比较多，可以通过管道结合more或less命令翻页查看： 提示：less命令可以通过键盘的PageUp键（↑）和PageDown键（↓）上下翻页，按q键退出。 1$ ps -ef | less 示例：自定义显示的进程信息的字段，参数组合-eo： 释义：pid,pcpu,pmem,cmd是别名，分别对应PID,%CPU,%MEM,CMD。 1234$ ps -eo pid,pcpu,pmem,cmdPID %CPU %MEM CMD 1 0.0 0.1 /sbin/init 2 0.0 0.0 [kthreadd] 示例：查看所有的进程并按CPU降序排序： 参数：--sort 释义：排序字段 排序：-pcpu表示按%CPU降序，+pcpu表示按%CPU升序，由于+是默认的，因此可简写为pcpu 1$ ps aux --sort -pcpu 示例：自定义显示的进程信息的字段并按CPU降序排序： 1$ ps -eo pid,pcpu,pmem,cmd --sort -pcpu 示例：找出最耗CPU的10个进程信息： 1$ ps aux --sort -pcpu | head 示例：查看所有的进程并按内存降序排序： 疑惑：像%CPU一样用别名来排序无效，这里借助管道通过sort命令来排序 参数：此为sort的参数，-r降序（若没有此参数，sort默认采用升序的顺序来排序），-n按数值来排序，-k列的索引（第一列的索引值为1，以此类推） 1$ ps aux | sort -nrk 4 示例：自定义显示的进程信息的字段并按内存降序排序： 1$ ps -eo pid,pcpu,pmem,cmd | sort -nrk 3 示例：找出最耗内存的10个进程信息： 1$ ps -eo pid,pcpu,pmem,cmd | sort -nrk 3 | head 12. 杀死进程通常情况下，残忍的杀死一个进程我们经常会使用kill命令。 1$ kill -9 2878 该命令的中心思想是用来强行杀死PID为2878的进程。kill是用来终止进程的信号。-9是一个信号编号，表示强行杀死。除此之外，常见的信号编号还有： 信号编号 描述 2 当按下组合键“Ctrl + c”时会发出该信号 9 强行杀死 15 终止进程默认发送的信号 20 当按下组合键“Ctrl + z”时会发出该信号 13. top 命令top命令可以实时的监控系统中各个进程的资源占用情况，经常用于服务器性能监控和分析。 1$ top top列出的信息内容非常丰富（部分信息与ps相似，不再赘述），默认每隔3秒钟自动刷新一次： top命令在运行中的时候，可以通过一些按键来控制显示的信息结果，常用的有： 信号编号 描述 Shift + p 按%CPU排序结果 Shift + m 按%MEM排序结果 Shift + n 按PID排序结果 1 数字1，查看每个核的CPU使用情况 首先来看前5行信息的内容： 第一行，系统的统计信息： 22:35:29 up 26 days, 13:33表示系统连续运行的时间； 1 user表示当前登录系统的用户数； load average: 0.04, 0.03, 0.05表示系统分别在1、5、15分钟内的平均负载； 第二行，进程的统计信息： 133 total表示进程的总数； 1 running表示正在运行的进程数； 132 sleeping表示休眠的进程数； 0 stopped表示停止的进程数； 0 zombie表示僵尸进程数； 第三行，CPU的统计信息： 0.2 us表示用户占用的CPU百分比； 0.2 sy表示内核占用的CPU百分比； 99.6 id表示空闲的CPU百分比； 其余不一一列举了… 第四行，内存的统计信息： 12139564 total表示物理内存的总大小； 1866952 free表示空闲可用的物理内存总大小； 6600492 used表示已经使用的物理内存总大小； 3672120 buff/cache表示缓冲内存的总大小； 第五行，交换分区的统计信息： 2097148 total表示交换分区的总大小； 2062220 free表示空闲可用的交换分区的大小； 34928 used表示已经使用的交换分区的大小； 示例：单独跟踪某个进程的运行状态： 参数：-d 释义：每隔多少秒刷新一次 参数：-p 释义：进程的ID 1$ top -d 1 -p 12515 有时候，我们经常会看到CPU的使用率占比超过100%。你莫要惊慌，这是因为top是按照单个CPU核数来计算的。如果一台服务器的CPU核数为4核，那么，该服务器的CPU使用率占比最高可达到400%。 &nbsp; 内存是真内存！你看到剩余多少就是多少，没有更多了。如果系统剩余物理内存不是很足了，那就要引起注意了。Linux系统有一个OOM-killer（Out Of Memory killer）机制。当Linux内核检测到系统内存不足的时候，就会触发OOM-killer来挑选一个最耗内存的进程并杀掉这个进程以求释放一些内存出来。 &nbsp; 除了内存和CPU，top还有一个地方很直观的反应出当前系统的性能指标，那就是第一行的load average系统平均负载。0.00~1.00之间的数值表示系统状况良好。超过1.00表示系统已经超出负荷快要不堪重负了。而实际上，我们也经常会看到服务器平均负载超过1.00的情况。这也跟服务器的CPU核数有关。如果一台服务器的CPU核数为4核，那么，该服务器的平均负载能力可达到4.00。事实上，当系统平均负载达到70%左右时，你就应该有所行动，在事情变得更糟糕之前，去分析其造成的原因。分析的焦点应放在后两项的数值，因为第一项是1分钟内的平均负载，时间太短，一瞬间的高并发导致该值大幅度上涨是很有可能的。作为一个程序猿，对top的心得言尽于此。 14. 硬盘使用情况掌握如何去查看服务器的硬盘空间使用情况以及在硬盘空间捉襟见肘如何去查找大文件也很重要。特别是对于一些吃硬盘的应用，比如文件系统、索引检索应用等。 示例：查看服务器硬盘空间使用情况： 命令：df 释义：disk free，磁盘可用空间 参数：-h, --human-readable 释义：易读格式, 指的是数值后面的单位，如：M、G 等 12345$ df -hFilesystem Size Used Avail Use% Mounted on/dev/sda2 19G 3.1G 15G 18% /tmpfs 238M 0 238M 0% /dev/shm/dev/sda1 291M 34M 242M 13% /boot 一般只看第一行就行，其它涉及Linux文件系统方面的知识有兴趣可以自行谷歌百度，这里不作描述。Size是磁盘容量，Used是已用的空间，Avail是剩余可用的空间（重要），Use%是已用的空间的百分比。 示例：查看文件或目录占用的磁盘空间大小： 命令：du 释义：disk usage，磁盘使用 参数：-h, --human-readable 释义：易读格式, 指的是数值后面的单位，如：M、G 等 123$ du -h logs81M logs/app149M logs 可以看出，logs目录总共占149M的磁盘空间。其中，logs/app目录共占81M，剩余的68M被logs根目录下的文件占用。如果想要查看各个文件占用的磁盘空间，可以追加使用-a, --all参数： 12345678$ du -ha logs332K logs/demo1.log20K logs/demo2.log68M logs/demo3.log49M logs/app/app-demo2.log33M logs/app/app-demo1.log81M logs/app149M logs 示例：找出目录下最大的10个文件： 123456$ find . -type f -exec du -b &#123;&#125; \\; | sort -nrk 1 | head70938260 ./demo3.log50838254 ./app/app-demo2.log33759270 ./app/app-demo1.log336939 ./demo1.log17510 ./demo2.log 由于是要按数值大小排序，故这里不能使用-h参数，-b, --bytes是统计字节数，这样排序才准确。 查看目录的磁盘大小du -sh * 15. 网络链接还在为系统链接不了网络而烦恼？还在为系统自动获取IP每次客户端链接终端都要修改IP地址而烦恼？ 为你虚拟机的Linux操作系统设置静态IP！【工具：VMware；操作系统：CentOS6（CentOS7类似）】 在顶部菜单中选择编辑–&gt;虚拟网络编辑器 &nbsp; 在 NAT 设置中查看网关IP： &nbsp; 在 DHCP 设置中查看子网掩码、广播地址、子网IP段： 虚拟机Linux系统的网络适配器选择NAT模式。CentOS操作系统网卡的名称通常是以ifcfg-xxx的方式命名，你也可以使用ifconfig命令来查看系统的网卡名称。CentOS6的网卡名称通常是ifcfg-eth0。编辑网卡信息： 1# vi /etc/sysconfig/network-scripts/ifcfg-eth0 CentOS6 配置：123456789DEVICE=\"eth0\"BOOTPROTO=\"static\"HWADDR=\"00:0C:29:66:3F:AB\"ONBOOT=\"yes\"UUID=\"96bcd1e9-5921-4cf9-bc0e-7c4b9d80e215\"IPADDR=192.168.139.129NETMASK=255.255.255.0GATEWAY=192.168.139.2DNS1=192.168.139.2 CentOS7 配置： 1234567... ...BOOTPROTO=\"static\"IPADDR0=192.168.139.129PREFIX0=24GATEWAY0=192.168.139.2DNS1=192.168.139.2DNS2=8.8.8.8 网卡配置信息主要修改BOOTPROTO为static，以及添加后面几行的配置，DNS的值保持和网关一致。 重启网络服务： 1# service network restart 验证网络是否可用（如果能ping通，说明网络可用）： 1$ ping baidu.com 16. 网络状态如果想查看系统的网络状态信息，可以使用netstat命令。 参数：–numeric , -n 释义：使用数字类型的IP地址显示 参数：-a, –all 释义：显示所有经过TCP建立链接的Socket 参数：-t, –tcp 释义：只显示TCP传输协议的连线 1234567$ netstat -antProto Recv-Q Send-Q Local Address Foreign Address Statetcp6 0 0 :::20818 :::* LISTENtcp6 0 0 :::20809 :::* LISTENtcp6 0 0 10.10.10.171:20818 10.10.10.170:55648 ESTABLISHEDtcp6 0 0 10.10.10.171:20818 10.10.10.170:34580 ESTABLISHEDtcp6 0 0 10.10.10.171:20809 10.10.10.176:26379 ESTABLISHED 这里主要来介绍后面的三列信息内容： 字段 描述 Local Address 本地地址和端口信息 Foreign Address 远程地址和端口信息 State 状态信息。常见的状态有：LISTEN：本地监听的端口；ESTABLISHED：远程访问本机服务的地址和端口信息；TIME-WAIT：链接已挂断，socket在网络上等待结束； 示例：统计某个端口的服务当前的链接数量： 12$ $ netstat -ant | grep \":20818\" | wc -l21 5. 数值运算高高兴兴的写脚本： 12345#!/bin/bashn1=1n2=2result=n1+n2echo \"n1 + n2 = $result\" 执行结果：n1 + n2 = n1+n2（一脸懵逼有没有o(╯□╰)o） 在shell中，给变量赋予数字类型的值最终也是以字符串的方式存储的，如果想要让它们变得像数字一样能够进行数值运算，可以采用以下的方法。 5.1 let使用let作数值运算时，变量名前不需要加$符号，适用于整数运算： 12345let result=n1+n2let result++let result--let result+=1let result-=1 5.2 $[ ]使用$[ ]作数值运算时，变量名前不需要加$符号，[]里面可以有空格，适用于整数运算： 1result=$[ n1 + n2 ] 5.3 $(( ))使用$(( ))作数值运算时，变量名前不需要加$符号，(())里面可以有空格，适用于整数运算： 1result=$(( n1 + n2 )) 5.4 expr使用expr作数值运算时，变量名前需要加$符号，适用于整数运算： 1result=`expr $n1 + $n2` 5.5 bc以上列举的方法都只适用于整数。如果要对小数进行运算，可以使用bc（数值运算的高级工具）： 12345#!/bin/bashn1=1.234n2=2result=`echo \"$n1 * $n2\" | bc`echo \"n1 * n2 = $result\" 除此之外，你还可以使用scale来指定需要保留的小数位数，中间用定界符分号来隔开： 1result=`echo \"scale=2; $n1 * $n2 / 1\" | bc` 注：scale只对除法、取余、乘幂有效，对乘法无效，所以上例除以了一个1来达到效果。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"FastDFS 客户端工具类","date":"2017-09-24T04:33:54.000Z","path":"post/fastdfs-client.html","text":"依赖配置： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.bestwu&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; FastDFS 配置： # fastdfs-client.properties12fastdfs.http_tracker_http_port=8080fastdfs.tracker_servers=10.10.10.121:22122,10.10.10.122:22122,10.10.10.123:22122 FastDFS 客户端工具类： # FastDFSClient123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.StorageClient1;import org.csource.fastdfs.StorageServer;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;import javax.servlet.http.HttpServletResponse;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream; /** * FastDFS 客户端工具 * Created by fanlychie on 2017/9/22. */public final class FastDFSClient &#123; private static StorageClient1 storageClient; /** * 上传文件 * * @param file 文件对象 * @return 上传如果成功, 则返回表示该文件的文件ID字符串; 否则抛出异常 */ public static String uploadFile(File file) &#123; String name = file.getName(); int index = name.lastIndexOf(\".\"); String extension = index == -1 ? null : name.substring(index + 1); byte[] sources; InputStream inputStream = null; try &#123; inputStream = new FileInputStream(file); sources = new byte[inputStream.available()]; inputStream.read(sources); &#125; catch (Exception e) &#123; throw new ExceptionWrapper(e); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123;&#125; &#125; &#125; return storage(sources, extension); &#125; /** * 存储任意源到文件 * * @param sources 源 * @return 存储如果成功, 则返回表示该文件的文件ID字符串; 否则抛出异常 */ public static String storage(byte[] sources) &#123; return storage(sources, null); &#125; /** * 存储任意源到文件 * * @param sources 源 * @param extension 存储的文件扩展名 * @return 存储如果成功, 则返回表示该文件的文件ID字符串; 否则抛出异常 */ public static String storage(byte[] sources, String extension) &#123; try &#123; return storageClient.upload_file1(sources, extension, null); &#125; catch (Exception e) &#123; throw new ExceptionWrapper(e); &#125; &#125; /** * 更新文件, 更新时, 先上传新的文件, 若上传成功, 则删除原文件; 若新文件上传失败, 则原文件不会被删除, 并抛出异常 * * @param fileId 原文件ID * @param newFile 新的文件对象 * @return 先上传新的文件, 若上传成功, 则删除原文件, 并返回新的文件ID; 若新文件上传失败, 则原文件不会被删除, 并抛出异常 */ public static String updateFile(String fileId, File newFile) &#123; String newFileId = uploadFile(newFile); delete(fileId); return newFileId; &#125; /** * 更新源, 更新时, 先存储新的源内容, 若存储成功, 则删除原文件; 若存储失败, 则原文件不会被删除, 并抛出异常 * * @param fileId 原文件ID * @param newSources 新的源内容 * @return 先存储新的源内容, 若存储成功, 则删除原文件, 并返回新的文件ID; 若存储失败, 则原文件不会被删除, 并抛出异常 */ public static String modify(String fileId, byte[] newSources) &#123; return modify(fileId, newSources, null); &#125; /** * 更新源, 更新时, 先存储新的源内容, 若存储成功, 则删除原文件; 若存储失败, 则原文件不会被删除, 并抛出异常 * * @param fileId 原文件ID * @param newSources 新的源内容 * @param extension 存储的文件扩展名 * @return 先存储新的源内容, 若存储成功, 则删除原文件, 并返回新的文件ID; 若存储失败, 则原文件不会被删除, 并抛出异常 */ public static String modify(String fileId, byte[] newSources, String extension) &#123; String newFileId = storage(newSources, extension); delete(fileId); return newFileId; &#125; /** * 删除文件 * * @param fileId 文件ID */ public static void delete(String fileId) &#123; try &#123; storageClient.delete_file1(fileId); &#125; catch (Exception e) &#123; throw new ExceptionWrapper(e); &#125; &#125; /** * 下载文件 * * @param fileId 文件ID * @param outputStream 输出流对象 */ public static void downloadFile(String fileId, OutputStream outputStream) &#123; byte[] bytes; try &#123; bytes = storageClient.download_file1(fileId); &#125; catch (Exception e) &#123; throw new ExceptionWrapper(e); &#125; InputStream inputStream = new ByteArrayInputStream(bytes); try (BufferedInputStream bis = new BufferedInputStream(inputStream); BufferedOutputStream bos = new BufferedOutputStream(outputStream)) &#123; int read; byte[] buffer = new byte[512 * 1024]; while ((read = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, read); &#125; &#125; catch (IOException e) &#123; if (!e.getClass().getSimpleName().equals(\"ClientAbortException\")) &#123; throw new ExceptionWrapper(e); &#125; &#125; &#125; /** * 下载文件 * * @param response 客户端响应对象 * @param fileId 文件ID * @param fileName 客户端下载框中显示的文件名称, 如果有扩展名, 该名称应含文件的扩展名 */ public static void downloadFile(HttpServletResponse response, String fileId, String fileName) &#123; try &#123; fileName = new String(fileName.getBytes(\"UTF-8\"), \"ISO-8859-1\"); response.setContentType(\"application/octet-stream; charset=iso-8859-1\"); response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName); downloadFile(fileId, response.getOutputStream()); &#125; catch (IOException e) &#123; throw new ExceptionWrapper(e); &#125; &#125; /** * 初始化 FastDFS */ private static void init() &#123; try &#123; ClientGlobal.initByProperties(\"fastdfs-client.properties\"); TrackerClient trackerClient = new TrackerClient(ClientGlobal.getG_tracker_group()); TrackerServer trackerServer = trackerClient.getConnection(); if (trackerServer == null) &#123; throw new FastDFSClientException(\"连接 FastDFS 服务失败\"); &#125; StorageServer storageServer = trackerClient.getStoreStorage(trackerServer); if (storageServer == null) &#123; throw new FastDFSClientException(\"获取 FastDFS 存储对象失败\"); &#125; storageClient = new StorageClient1(trackerServer, storageServer); &#125; catch (Exception e) &#123; throw new ExceptionWrapper(e); &#125; &#125; /** * 第一次加载时执行初始化工作 */ static &#123; init(); &#125; /** * 异常包装器, 将非运行时异常包装成运行时异常并在运行时抛出 */ static class ExceptionWrapper extends RuntimeException &#123; private Throwable cause; public ExceptionWrapper(Throwable throwable) &#123; this.cause = throwable; &#125; @Override public synchronized Throwable getCause() &#123; return cause; &#125; &#125; /** * FastDFS 客户端异常 */ public static class FastDFSClientException extends RuntimeException &#123; public FastDFSClientException(String message) &#123; super(message); &#125; &#125; &#125; 单元测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.junit.Test;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream; public class FastDFSClientTest &#123; /** * 测试文件上传 */ @Test public void testUploadFile() &#123; File file = new File(\"src/test/resources/demo.txt\"); String fileID = FastDFSClient.uploadFile(file); System.out.println(fileID); &#125; /** * 测试内容存储 */ @Test public void testStorage() &#123; String fileID = FastDFSClient.storage(\"Hello World!!!\".getBytes()); System.out.println(fileID); &#125; /** * 测试内容修改更新, 文件更新使用 updateFile */ @Test public void testModify() &#123; String fileID = FastDFSClient.modify(\"group1/M00/00/00/wKiLgVnHDwOAdxolAAAADtiRrk0132.txt\", \"Hello FastDFS!!!\".getBytes()); System.out.println(fileID); &#125; /** * 测试文件下载 */ @Test public void testDownloadFile() throws Exception &#123; OutputStream os = new FileOutputStream(\"src/test/resources/demo-download.txt\"); FastDFSClient.downloadFile(\"group1/M00/00/00/CgoKe1tYT4yAQqpZAAAAlLyiB3s056.txt\", os); &#125; &#125;","tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://yoursite.com/tags/FastDFS/"}]},{"title":"FastDFS集群搭建","date":"2017-09-23T04:33:54.000Z","path":"post/fastdfs-cluster-setup.html","text":"FastDFS有两个重要的角色：跟踪服务器（tracker）和存储服务器（storage）。 1. 存储服务器（storage server）FastDFS中的storage是采用分组（group）的方式来存储文件。 一个group中可以由一个或多个storage server组成，同一个group中的storage server是互备关系，即同一个group中的每个storage server相互进行文件同步（由专门的线程来完成），最终达到每个storage server中存储的文件是完全一致的。 一个storage集群是由一个或多个group组成。storage集群的存储总容量是集群中所有的group的存储总容量之和。由于同一个group中的storage server是互备关系，因此每个group的存储总容量是该group中存储容量最小的storage server的存储容量。因此，同一个group中的storage server的硬件配置应尽量保持一致，以免造成浪费。 storage server提供了文件上传、文件删除、文件访问（下载）等基础的功能。文件访问（下载）可以通过使用nginx扩展模块来完成（即每个storage server中都需要安装一个nginx应用）。 2. 跟踪服务器（tracker server）FastDFS中的tracker主要的作用是负载均衡和调度。tracker server可以有多个，tracker server之间是对等的关系，没有主从之分。当客户端连接tracker server时，如果tracker server有多个，客户端会任意选择其中的一个来连接。storage server会周期性定时的向集群中的所有tracker server报告其分组和状态等信息（storage server会通过启动一个单独的线程来完成）。 3. 客户端（client）以文件上传为例，client、tracker server、storage server的时序图如下（图片摘自网络）： 4. 部署概况 角色 IP 端口 tracker 10.10.10.121 22122 tracker 10.10.10.122 22122 tracker 10.10.10.123 22122 storage 10.10.10.121 22122 storage 10.10.10.122 22122 storage 10.10.10.123 22122 5. 安装清单 FastDFS fastdfs-5.10.tar.gz libfastcommon-1.0.36.tar.gz fastdfs-nginx-module_v1.16.tar.gz Nginx nginx-1.12.1.tar.gz openssl-1.0.2l.tar.gz pcre-8.36.tar.gz zlib-1.2.11.tar.gz 注：FastDFS的基础详细安装可参考「FastDFS分布式文件系统搭建」。 注：本文示例每台虚拟机都分别安装一个tracker和一个storage。10.10.10.12110.10.10.12210.10.10.123三台机器安装和配置均相同，按以下步骤进行。 5.1 libfastcommon 安装解压缩并进入解压缩后的文件夹的根目录：1# tar zxvf libfastcommon-1.0.36.tar.gz &amp;&amp; cd libfastcommon-1.0.36 执行编译安装：1# ./make.sh &amp;&amp; ./make.sh install 5.2 fastdfs 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf fastdfs-5.10.tar.gz &amp;&amp; cd fastdfs-5.10 执行编译安装： 1# ./make.sh &amp;&amp; ./make.sh install 安装完成之后，在系统的/etc路径下会自动生成一个/fdfs目录，该目录下是FastDFS相关的一些示例配置文件。 将当前路径下 conf 目录里面的 anti-steal.jpg，http.conf，mime.types 复制到 /etc/fdfs 目录中： 1# cp conf/anti-steal.jpg conf/http.conf conf/mime.types /etc/fdfs/ 5.2.1 tracker 配置将/etc/fdfs/tracker.conf.sample重命名为/etc/fdfs/tracker.conf： 1# mv /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf 编辑 tracker 配置文件： 1# vi /etc/fdfs/tracker.conf 主要配置及说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 端口port=22122## 连接超时时间，单位秒，默认是30connect_timeout=30## 网络超时时间，单位秒，默认是60network_timeout=60## 数据文件和日志文件存储的基路径base_path=/home/fanlychie/fastdfs## 最大并发连接数max_connections=256## 上传文件时，选group的策略# 0：轮询group# 1：使用特定的group# 2：选择可用空间最大的groupstore_lookup=2## 指定文件上传到哪个group。当store_lookup设置为1时，必须指定这个group的名称。当store_lookup是其它值时该属性可以不设值store_group=group1## 上传文件时，选storage server的策略# 0：轮询# 1：根据配置的IP的顺序# 2：根据配置的优先级store_server=0## 上传文件时，选存储介质（磁盘或挂载点）的策略# 0：轮询# 1：优先使用最大可用空间的路径store_path=0## 下载文件时，选storage server的策略# 0：轮询# 1：当前文件上传的源storage serverdownload_server=0## 系统保留的存储空间reserved_storage_space = 1%## HTTP端口http.server_port=8080 5.2.2 storage 配置将/etc/fdfs/storage.conf.sample重命名为/etc/fdfs/storage.conf： 1# mv /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf 编辑 storage 配置文件： 1# vi /etc/fdfs/storage.conf 主要配置及说明： 1234567891011121314151617181920212223242526# 所属group的名称group_name=group1## 端口port=23000## 连接超时时间，单位秒，默认是30connect_timeout=30## 网络超时时间，单位秒，默认是60network_timeout=60## 数据文件和日志文件存储的基路径base_path=/home/fanlychie/fastdfs/storage## 最大并发连接数max_connections=256## 文件存储的路径。可以配置多个store_path0=/home/fanlychie/fastdfs/storage#store_path1=/home/fanlychie/fastdfs/storage1## tracker server的IP和端口。如果有多个则配置多行tracker_server=10.10.10.121:22122tracker_server=10.10.10.122:22122tracker_server=10.10.10.123:22122 5.2.3 client 配置将/etc/fdfs/client.conf.sample重命名为/etc/fdfs/client.conf： 1# mv /etc/fdfs/client.conf.sample /etc/fdfs/client.conf 编辑 client 配置文件： 1# vi /etc/fdfs/client.conf 主要配置及说明： 1234567# 数据文件和日志文件存储的基路径base_path=/home/fanlychie/fastdfs## tracker server的IP和端口。如果有多个则配置多行tracker_server=10.10.10.121:22122tracker_server=10.10.10.122:22122tracker_server=10.10.10.123:22122 5.3 fastdfs-nginx-module 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf fastdfs-nginx-module_v1.16.tar.gz &amp;&amp; cd fastdfs-nginx-module 编辑src/mod_fastdfs.conf： 1# vi src/mod_fastdfs.conf 主要配置及说明： 12345678910111213# tracker server的IP和端口。如果有多个则配置多行tracker_server=10.10.10.121:22122tracker_server=10.10.10.122:22122tracker_server=10.10.10.123:22122## 如果请求的url地址中包含了group_name（如“group1/M00/00/00/xxx”）则应设为true。# 如果请求的url地址中不包含group_name（如“/M00/00/00/xxx”）则应设为false。url_have_group_name = true## 文件存储的路径。可以配置多个# 必须配置与本机storage.conf中配置的store_path0路径相同store_path0=/home/fanlychie/fastdfs/storage#store_path1=/home/fanlychie/fastdfs/storage1 复制文件src/mod_fastdfs.conf到/etc/fdfs/目录下： 1# cp src/mod_fastdfs.conf /etc/fdfs/ 编辑src/config： 1# vi src/config 找到CORE_INCS的配置行，去掉路径中的/local，改为如下并保存退出： 1CORE_INCS=\"$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/\" 5.4 nginx 安装由于FastDFS提供的HTTP服务较为简单，它无法提供负载均衡等高性能的服务。因此，FastDFS通常会结合Nginx来使用。安装Nginx所需的依赖有： nginx 的 gzip 模块（压缩）需要依赖 zlib 库 nginx 的 ssl 模块（支持 HTTPS）需要依赖 openssl 库 nginx 的 rewrite 模块（支持 URL 重写）需要依赖 pcre 库 5.4.1 pcre 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf pcre-8.36.tar.gz &amp;&amp; cd pcre-8.36 执行编译安装： 1# ./configure &amp;&amp; make &amp;&amp; make install 创建软连接（64位系统）： 1# ln -s /usr/local/lib/libpcre.so.1 /lib64 创建软连接（32位系统）： 1# ln -s /usr/local/lib/libpcre.so.1 /lib 5.4.2 zlib 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf zlib-1.2.11.tar.gz &amp;&amp; cd zlib-1.2.11 执行编译安装： 1# ./configure &amp;&amp; make &amp;&amp; make install 5.4.3 openssl 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf openssl-1.0.2l.tar.gz &amp;&amp; cd openssl-1.0.2l 执行编译安装： 1# ./config &amp;&amp; make &amp;&amp; make install 5.4.4 nginx 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf nginx-1.12.1.tar.gz &amp;&amp; cd nginx-1.12.1 编译安装（注意修改--add-module的路径）： 1# ./configure --prefix=/usr/local/nginx --add-module=/usr/local/src/fastdfs-nginx-module/src/ &amp;&amp; make &amp;&amp; make install –add-module的路径需要改成你服务上上面配置好的fastdfs-nginx-module对应的路径。 编辑 nginx 配置文件： 1# vi /usr/local/nginx/conf/nginx.conf 添加如下配置： 1234location /group1/M00 &#123; root /home/fanlychie/fastdfs/storage/data/; ngx_fastdfs_module;&#125; root指定到storage配置的${base_path}/data/目录下。 ngx_fastdfs_module是FastDFS模块名称，该名称固定不需要改变。 5.5 启动服务5.5.1 tracker启动命令： 1# fdfs_trackerd /etc/fdfs/tracker.conf start 停止命令： 1# fdfs_trackerd /etc/fdfs/tracker.conf stop 重启命令： 1# fdfs_trackerd /etc/fdfs/tracker.conf restart 5.5.2 storage启动命令： 1# fdfs_storaged /etc/fdfs/storage.conf start 停止命令： 1# fdfs_storaged /etc/fdfs/storage.conf stop 重启命令： 1# fdfs_storaged /etc/fdfs/storage.conf restart 5.5.3 nginx启动命令： 1# /usr/local/nginx/sbin/nginx 停止命令： 1# /usr/local/nginx/sbin/nginx -s stop 重新加载命令： 1# /usr/local/nginx/sbin/nginx -s reload 10.10.10.12110.10.10.12210.10.10.123三台机器的tracker配置相同。 6. storage 配置编辑tracker的配置文件：","tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://yoursite.com/tags/FastDFS/"}]},{"title":"FastDFS分布式文件系统搭建","date":"2017-09-22T14:39:04.000Z","path":"post/fastdfs-setup.html","text":"FastDFS 是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。适合以文件为载体的在线服务，如图片网站、视频网站等等。 1. 环境和软件安装包清单 Linux CentOS 7 FastDFS fastdfs-5.10.tar.gz libfastcommon-1.0.36.tar.gz fastdfs-nginx-module_v1.16.tar.gz Nginx nginx-1.12.1.tar.gz openssl-1.0.2l.tar.gz pcre-8.36.tar.gz zlib-1.2.11.tar.gz 2. FastDFS 安装FastDFS 服务端有两个重要的角色：跟踪器（tracker）和存储器（storage）。客户端通过 tracker 将文件存储在 storage 服务器。在访问量不大情况下，可将 tracker 和 storage 都部署在同一台服务器上，后期根据业务需要进行扩展。以下是安装所需的软件包： 123456789# lltotal 10552-rw-r--r-- 1 gw gw 17510 Sep 20 2017 fastdfs-nginx-module_v1.16.tar.gz-rw-r--r-- 1 gw gw 344620 Sep 22 2017 FastDFS_v5.08.tar.gz-rw-r--r-- 1 gw gw 434873 Sep 20 2017 libfastcommon-1.0.36.tar.gz-rw-r--r-- 1 gw gw 981093 Sep 20 2017 nginx-1.12.1.tar.gz-rw-r--r-- 1 gw gw 5365054 Sep 20 2017 openssl-1.0.2l.tar.gz-rw-r--r-- 1 gw gw 2009464 Sep 20 2017 pcre-8.36.tar.gz-rw-r--r-- 1 gw gw 607698 Sep 20 2017 zlib-1.2.11.tar.gz 2.1 libfastcommon 安装libfastcommon是从FastDFS和FastDHT中提取出来的公共C函数库，FastDFS依赖该模块，需要首先安装它。 解压缩并进入解压缩后的文件夹的根目录：1# tar zxvf libfastcommon-1.0.36.tar.gz &amp;&amp; cd libfastcommon-1.0.36 执行编译安装：1# ./make.sh &amp;&amp; ./make.sh install 如果报 gcc: command not found 错误，说明系统缺少gcc编译环境。先安装gcc环境： 1# yum install -y gcc gcc-c++重新编译安装： 1# ./make.sh clean &amp;&amp; ./make.sh &amp;&amp; ./make.sh install 安装完成后，返回到上一级目录（软件包所在的根目录）： 1# cd - 2.2 fastdfs 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf fastdfs-5.10.tar.gz &amp;&amp; cd fastdfs-5.10 执行编译安装： 1# ./make.sh &amp;&amp; ./make.sh install 如果报 perl: command not found 错误，说明系统缺少perl编译环境。先安装perl环境： 1# yum install perl重新编译安装： 1# ./make.sh clean &amp;&amp; ./make.sh &amp;&amp; ./make.sh install 安装成功后，在系统/etc路径下会生成一个/fdfs目录，该目录下是FastDFS相关的一些示例配置文件内容。 123456# ll /etc/fdfs/total 24-rw-r--r-- 1 root root 1461 Jun 5 16:46 client.conf.sample-rw-r--r-- 1 root root 7927 Jun 5 16:46 storage.conf.sample-rw-r--r-- 1 root root 105 Jun 5 16:46 storage_ids.conf.sample-rw-r--r-- 1 root root 7200 Jun 5 16:46 tracker.conf.sample 将当前路径下 conf 目录里面的 anti-steal.jpg，http.conf，mime.types 复制到 /etc/fdfs 目录中： 1# cp conf/anti-steal.jpg conf/http.conf conf/mime.types /etc/fdfs/ 安装完成后，返回到上一级目录（软件包所在的根目录）： 1# cd - 2.2.1 tracker 配置将/etc/fdfs/tracker.conf.sample重命名为/etc/fdfs/tracker.conf并编辑它： 1# mv /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf &amp;&amp; vi /etc/fdfs/tracker.conf 找到base_path的配置行，将其修改为： 1base_path=/home/fanlychie/fastdfs 这里的base_path是tracker用于存储数据文件（其路径为：base_path/data）以及日志文件（其路径为：base_path/logs）的基路径。如果配置的目录尚未存在，需要先创建该路径： 1# mkdir -p /home/fanlychie/fastdfs 启动命令： 1# fdfs_trackerd /etc/fdfs/tracker.conf start 停止命令： 1# fdfs_trackerd /etc/fdfs/tracker.conf stop 重启命令： 1# fdfs_trackerd /etc/fdfs/tracker.conf restart 2.2.2 storage 配置将/etc/fdfs/storage.conf.sample重命名为/etc/fdfs/storage.conf并编辑它： 1# mv /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf &amp;&amp; vi /etc/fdfs/storage.conf 找到base_path的配置行，将其修改为： 1base_path=/home/fanlychie/fastdfs/storage 这里的base_path是storage用于存储数据文件（其路径为：base_path/data）以及日志文件（其路径为：base_path/logs）的基路径。如果配置的目录尚未存在，需要先创建该路径： 1# mkdir -p /home/fanlychie/fastdfs/storage 找到store_path0的配置行，将其修改为： 1store_path0=/home/fanlychie/fastdfs/storage store_path0如果配置的路径不存在，则会使用base_path配置的路径。 找到tracker_server的配置行，将其修改为tracker服务器的地址： 1tracker_server=192.168.1.102:22122 启动命令： 1# fdfs_storaged /etc/fdfs/storage.conf start 停止命令： 1# fdfs_storaged /etc/fdfs/storage.conf stop 重启命令： 1# fdfs_storaged /etc/fdfs/storage.conf restart 2.2.3 client 配置将/etc/fdfs/client.conf.sample重命名为/etc/fdfs/client.conf并编辑它： 1# mv /etc/fdfs/client.conf.sample /etc/fdfs/client.conf &amp;&amp; vi /etc/fdfs/client.conf 找到base_path的配置行，将其修改为： 1base_path=/home/fanlychie/fastdfs 这里的base_path是storage用于存储数据文件（其路径为：base_path/data）以及日志文件（其路径为：base_path/logs）的基路径。如果配置的目录尚未存在，需要先创建该路径： 1# mkdir -p /home/fanlychie/fastdfs 找到tracker_server的配置行，将其修改为tracker服务器的地址： 1tracker_server=192.168.1.102:22122 2.3 fastdfs-nginx-module 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf fastdfs-nginx-module_v1.16.tar.gz &amp;&amp; cd fastdfs-nginx-module 编辑src/mod_fastdfs.conf： 1# vi src/mod_fastdfs.conf 找到tracker_server的配置行，将其修改为tracker服务器的地址： 1tracker_server=192.168.1.102:22122 找到url_have_group_name的配置行，将其改为： 1url_have_group_name = true 如果请求的url地址中包含了group_name（如“group1/M00/00/00/xxx”）则应设为true。如果请求的url地址中不包含group_name（如“/M00/00/00/xxx”）则应设为false。 找到store_path0的配置行，将其改为： 1store_path0=/home/fanlychie/fastdfs/storage 必须配置与本机storage.conf中配置的store_path0路径相同。 复制文件src/mod_fastdfs.conf到/etc/fdfs/目录下： 1# cp src/mod_fastdfs.conf /etc/fdfs/ 编辑src/config： 1# vi src/config 找到CORE_INCS的配置行： 1CORE_INCS=\"$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/\" 去掉路径中的/local，改为如下并保存退出： 1CORE_INCS=\"$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/\" 2.4 nginx 安装由于FastDFS提供的HTTP服务较为简单，它无法提供负载均衡等高性能的服务。因此，FastDFS通常会结合Nginx来使用。安装Nginx所需的依赖有： nginx 的 gzip 模块（压缩）需要依赖 zlib 库 nginx 的 ssl 模块（支持 HTTPS）需要依赖 openssl 库 nginx 的 rewrite 模块（支持 URL 重写）需要依赖 pcre 库 2.5.1 pcre 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf pcre-8.36.tar.gz &amp;&amp; cd pcre-8.36 执行编译安装： 1# ./configure &amp;&amp; make &amp;&amp; make install 创建软连接（64位系统）： 1# ln -s /usr/local/lib/libpcre.so.1 /lib64 创建软连接（32位系统）： 1# ln -s /usr/local/lib/libpcre.so.1 /lib 回到上一级目录（软件包所在的根目录）： 1# cd - 2.4.2 zlib 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf zlib-1.2.11.tar.gz &amp;&amp; cd zlib-1.2.11 执行编译安装： 1# ./configure &amp;&amp; make &amp;&amp; make install 回到上一级目录（软件包所在的根目录）： 1# cd - 2.5.3 openssl 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf openssl-1.0.2l.tar.gz &amp;&amp; cd openssl-1.0.2l 执行编译安装： 1# ./config &amp;&amp; make &amp;&amp; make install 回到上一级目录（软件包所在的根目录）： 1# cd - 2.5.4 nginx 安装解压缩并进入解压缩后的文件夹的根目录： 1# tar zxvf nginx-1.12.1.tar.gz &amp;&amp; cd nginx-1.12.1 编译安装（注意修改--add-module的路径）： 1# ./configure --prefix=/usr/local/nginx --add-module=/usr/local/src/fastdfs-nginx-module/src/ &amp;&amp; make &amp;&amp; make install –add-module的路径需要改成你服务上上面配置好的fastdfs-nginx-module对应的路径。 编辑 nginx 配置文件： 1# vi /usr/local/nginx/conf/nginx.conf 配置如下： 12345678user root; ... ... location /group1/M00 &#123; root /home/fanlychie/fastdfs/storage/data/; ngx_fastdfs_module;&#125; root指定到storage配置的${base_path}/data/目录下。 启动命令： 1# /usr/local/nginx/sbin/nginx 停止命令： 1# /usr/local/nginx/sbin/nginx -s stop 重新加载命令： 1# /usr/local/nginx/sbin/nginx -s reload 3. FastDFS 测试新建测试文件： 1$ echo 'Hello World!' &gt; hello.txt 测试上传： 1$ fdfs_test /etc/fdfs/client.conf upload hello.txt 上传成功之后返回类似信息： 1example file url: http://192.168.1.102/group1/M00/00/00/CgoKgFsXN6qAWGyzAAAADT9THu8575.txt 访问测试： 1$ curl http://192.168.1.102/group1/M00/00/00/CgoKgFsXN6qAWGyzAAAADT9THu8575.txt 4. 开启服务端口对外开启 80、8080、22122、23000 端口。 CentOS7 firewall 防火墙配置： 1234firewall-cmd --permanent --add-port=80/tcpfirewall-cmd --permanent --add-port=8080/tcpfirewall-cmd --permanent --add-port=22122/tcpfirewall-cmd --permanent --add-port=23000/tcp 重加载： 1# firewall-cmd --reload CentOS6 iptables 防火墙配置： 1# vi /etc/sysconfig/iptables 1234-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT 重加载： 1# service iptables restart","tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://yoursite.com/tags/FastDFS/"}]},{"title":"Jenkins 定时任务","date":"2017-08-20T10:24:11.000Z","path":"post/jenkins-schedule.html","text":"1. 创建自由风格的软件项目创建一个自由风格的软件项目，并找到构建触发器项，勾选Build periodically： 首次需要手工点一次任务构建，以后就会定时自动构建了。","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"}]},{"title":"Jenkins SSH 远程执行 Shell 脚本","date":"2017-08-20T07:44:41.000Z","path":"post/jenkins-remote-ssh.html","text":"1. 安装插件系统管理 -&gt; 管理插件 -&gt; 可用插件，搜索：SSH Plugin 2. 远程主机身份配置Credentials –&gt; global –&gt; Add Credentials 3. 远程主机SSH配置系统管理 –&gt; 系统设置，找到SSH remote hosts项，点击添加按钮： 4. 远程主机SSH免密登陆配置当前主机信息： IP：192.168.1.202 用户：root 目标主机信息： IP：192.168.1.201 用户：fanlychie 主机202以root用户身份免密SSH登陆到主机201的fanlychie用户的配置方式： ① 在主机202以root用户身份执行： 1# ssh-keygen -t rsa ② 一路回车，生成的密钥文件在当前用户的目录的.ssh目录中。 ③ 复制主机202用户目录下的id_rsa.pub文件到主机201的fanlychie用户目录下的.ssh目录中，并将文件重命名为authorized_keys： 1# cd ~/.ssh/ &amp;&amp; scp id_rsa.pub fanlychie@192.168.1.201:/home/fanlychie/.ssh/authorized_keys ④ 验证SSH免密登陆，在主机202以root用户身份执行： 1# ssh fanlychie@192.168.1.201 如果能顺利登陆主机201，说明配置成功。 ⑤ 退出SSH登陆： 1# exit 如果主机202需要远程登陆多台目标主机，如主机203，只需要从第3步开始配置即可。 5. 验证配置新建一个自由风格的软件项目，在构建项里面选择增加构建后操作步骤并选择Execute shell script on remote host using ssh： 在目标主机201中编写测试脚本： 1$ cd ~ &amp;&amp; mkdir scripts &amp;&amp; vi scripts/hello.sh 测试内容如下： 12345#!/bin/bash echo '========================================='echo 'Hello World!'echo '=========================================' 保存退出。并修改文件权限为可执行： 1$ chmod 764 scripts/hello.sh 构建任务： 6. 环境变量上面这种远程SSH到目标主机属于NoLogin方式，无法获取 PATH 等环境变量。 Jenkins构建好项目之后，如果应用服务器跟Jenkins服务器不是同一台主机，那Jenkins就需要通过SSH远程将应用的部署包发布到目标主机。执行发布的过程，通常需要目标主机环境变量的支持。例如： 123#!/bin/bash java -version 构建结果： 实际上，java 环境变量是已经在服务器中配置好了的。但由于是NoLogin的方式登陆，无法获取 PATH 等环境变量导致。目前我的解决方法是在脚本中重新定义一次。如： 12345678#!/bin/bash JAVA_HOME=/usr/local/jdk1.8.0_144CLASSPATH=.:$JAVA_HOME/libPATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH java -version 构建结果：","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"}]},{"title":"Jenkins 为视图添加控制台按钮","date":"2017-08-20T06:42:32.000Z","path":"post/jenkins-console-icon.html","text":"1. 安装插件系统管理 -&gt; 管理插件 -&gt; 可用插件，搜索：Console Column Plugin 2. 编辑视图 3. 添加列视图的列顺序可以自由拖放改变，按照你自己的习惯摆放即可。 4. 效果图","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"}]},{"title":"Jenkins 视图管理","date":"2017-08-20T04:12:22.000Z","path":"post/jenkins-view.html","text":"1. 添加视图 2. 填写信息 3. 配置信息 4. 效果图","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"}]},{"title":"使用 Jenkins 进行持续集成","date":"2017-08-19T14:52:52.000Z","path":"post/jenkins-guide.html","text":"Jenkins 的前身是 Hudson，它是基于 Java 开发的一种持续集成（Continuous Integration，简称 CI）开源工具。用于持续交付、自动构建、测试、发布和监控等，无需过多的人工干预，利于提高开发的效率。 1. 安装到 Jenkins 官网下载安装包 jenkins-2.60.3-1.1.noarch.rpm。Jenkins 2.54 或以上的版本需要 JDK 8 或以上的版本作为运行时环境。如果你系统环境的 JDK 版本低于 8，请选用低于 2.54 的 Jenkins 安装包。 1# rpm -ivh jenkins-2.60.3-1.1.noarch.rpm 目录 描述 /usr/lib/jenkins/ war 包目录 /var/lib/jenkins/ 默认的 JENKINS_HOME 目录 /var/log/jenkins/ 日志文件目录 /etc/sysconfig/jenkins 配置文件 1.1 JDK 配置1# vi /etc/init.d/jenkins 在 66 行附近找到 candidates 的配置： 12345678candidates=\"/etc/alternatives/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/bin/java\" 将你机器的 JDK 安装目录下的 /bin/java 文件的路径添加到第一行，其余行也可以删掉： 123candidates=\"/usr/local/jdk1.8.0_144/bin/java\" 1.2 端口配置（可选）：1# vi /etc/sysconfig/jenkins 在 56 行，默认端口是 8080，可自行修改： 1JENKINS_PORT=\"8888\" 1.3 用户配置Jenkins 安装时默认创建了一个名为 jenkins 的用户，为避免 Jenkins 运行时没有操作其他文件的权限，可修改为其他权限用户，比如 root： 1# vi /etc/sysconfig/jenkins 在 29 行： 123456789## Type: string## Default: \"jenkins\"## ServiceRestart: jenkins## Unix user account that runs the Jenkins daemon# Be careful when you change this, as you need to update# permissions of $JENKINS_HOME and /var/log/jenkins.#JENKINS_USER=\"root\" 1.4 命令行启动： 1service jenkins start 停止： 1service jenkins stop 重启： 1service jenkins restart 1.5 启动应用 第一次使用 Jenkins 时，它会自动生成一个随机的口令。你需要输入正确的口令才能进入系统。 1$ cat /var/lib/jenkins/secrets/initialAdminPassword 复制并粘贴口令进入到安装界面： 选择第一项Install suggested plugins，等待安装完成。待安装完成之后，创建管理员账户： 至此，安装完成。 2. 应用配置2.1 JDK 配置系统管理 -&gt; Global Tool Configuration 2.2 Maven 配置系统管理 -&gt; Global Tool Configuration 2.3 SVN 账户配置Credentials -&gt; global -&gt; Add Credentials 2.4 GIT 账户配置Credentials -&gt; global -&gt; Add Credentials 2.5 Maven 集成插件系统管理 -&gt; 管理插件 -&gt; Maven Integration plugin 2.6 发布插件系统管理 -&gt; 管理插件 -&gt; Deploy to container Plugin 3. 创建任务 4. 任务配置 附 Shell 脚本源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/bash # 必须, 否则Tomcat无法启动export BUILD_ID=anything # 应用部署到的Tomcat的路径, 不同项目只需改变此参数即可app_tomcat_path=/home/fanlychie/application/helloworld-demo-tomcat # 工作区间workspace=$WORKSPACE # 应用的名称app_final_name=$&#123;workspace##*/&#125; # 应用Tomcat的名称, 用于查杀进程app_tomcat_name=$&#123;app_tomcat_path##*/&#125; # 应用包备份的目录app_backup_path=$app_tomcat_path/backup # 应用包备份的路径app_backup_pathname=$app_backup_path/`echo | awk '&#123;print strftime(\"%Y-%m-%d-%H-%M-%S\")&#125;'` # 应用Tomcat的进程IDapp_tomcat_process_id=`ps -ef | grep $app_tomcat_name | grep -v grep | awk '&#123;print $2&#125;'` # 杀掉进程if [ $app_tomcat_process_id != \"\" ]; then kill -9 $app_tomcat_process_idfi # 创建备份目录if [ ! -d $app_backup_path ]; then mkdir $app_backup_pathfi # 创建备份路径mkdir $app_backup_pathname # 备份应用cp -r $app_tomcat_path/webapps/ROOT $app_backup_pathname # 清空目录rm -rf $app_tomcat_path/webapps/ROOT/* # 拷贝应用包cp -f $&#123;workspace&#125;/target/*.war $&#123;app_tomcat_path&#125;/webapps/ROOT # 进入ROOT目录cd $&#123;app_tomcat_path&#125;/webapps/ROOT # 解压缩应用包jar xvf *.war # 删除应用包rm -f *.war # 启动应用Tomcat服务$&#123;app_tomcat_path&#125;/bin/startup.sh 5. 用户管理系统管理 -&gt; Configure Global Security 系统管理 -&gt; 管理用户 -&gt; 新建用户 用户新建完成后再到系统管理 -&gt; Configure Global Security添加用户并配置权限。 环境：Java-8、Maven-3、Tomcat-8、Jenkins-2.60.3、Centos-6","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"}]},{"title":"dubbo 集群容错","date":"2017-07-29T10:18:21.000Z","path":"post/dubbo-cluster-fault-tolerance.html","text":"在集群调用失败时，dubbo 提供了多种可选的容错方案： failover、failfast、failsafe、failback、forking、broadcast 1. failover失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。 在缺省配置的情况下，dubbo 采用此方案作为默认的集群容错模式（可以通过cluster参数设置），并默认失败重试2次（不含第一次）调用其他的服务器（可以通过retries参数设置）。直至重试次数用完或调用成功为止。失败一次消费者调用方就会抛一个异常，但只要有一次调用是成功的，结果就是成功的。除非全部调用都失败了，结果才是失败的。 12345678910&lt;!-- 服务提供者方的配置 --&gt;&lt;dubbo:service retries=\"2\" /&gt; &lt;!-- 服务消费者方的配置 --&gt;&lt;dubbo:reference retries=\"2\" /&gt; &lt;!-- 服务消费者方的配置 --&gt;&lt;dubbo:reference&gt; &lt;dubbo:method name=\"findFoo\" retries=\"2\" /&gt;&lt;/dubbo:reference&gt; 注解配置示例： 12345// 服务提供者方的配置@com.alibaba.dubbo.config.annotation.Service(retries = 2) // 服务消费者方的配置@com.alibaba.dubbo.config.annotation.Reference(retries = 2) 2. failfast快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 12345&lt;!-- 服务提供者方的配置 --&gt;&lt;dubbo:service cluster=\"failfast\" /&gt; &lt;!-- 服务消费者方的配置 --&gt;&lt;dubbo:reference cluster=\"failfast\" /&gt; 注解配置示例： 12345// 服务提供者方的配置（亲测不起作用）@com.alibaba.dubbo.config.annotation.Service(cluster = \"failfast\") // 服务消费者方的配置@com.alibaba.dubbo.config.annotation.Reference(cluster = \"failfast\") 3. failsafe失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 12345&lt;!-- 服务提供者方的配置 --&gt;&lt;dubbo:service cluster=\"failsafe\" /&gt; &lt;!-- 服务消费者方的配置 --&gt;&lt;dubbo:reference cluster=\"failsafe\" /&gt; 注解配置示例： 12345// 服务提供者方的配置（亲测不起作用）@com.alibaba.dubbo.config.annotation.Service(cluster = \"failsafe\") // 服务消费者方的配置@com.alibaba.dubbo.config.annotation.Reference(cluster = \"failsafe\") 4. failback失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 12345&lt;!-- 服务提供者方的配置 --&gt;&lt;dubbo:service cluster=\"failback\" /&gt; &lt;!-- 服务消费者方的配置 --&gt;&lt;dubbo:reference cluster=\"failback\" /&gt; 注解配置示例： 12345// 服务提供者方的配置（亲测不起作用）@com.alibaba.dubbo.config.annotation.Service(cluster = \"failback\") // 服务消费者方的配置@com.alibaba.dubbo.config.annotation.Reference(cluster = \"failback\") 5. forking并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks=&quot;2&quot;来设置最大并行数。 12345&lt;!-- 服务提供者方的配置 --&gt;&lt;dubbo:service cluster=\"forking\" /&gt; &lt;!-- 服务消费者方的配置 --&gt;&lt;dubbo:reference cluster=\"forking\" /&gt; 注解配置示例： 12345// 服务提供者方的配置（亲测不起作用）@com.alibaba.dubbo.config.annotation.Service(cluster = \"forking\") // 服务消费者方的配置@com.alibaba.dubbo.config.annotation.Reference(cluster = \"forking\") 6. broadcast广播调用所有提供者，逐个调用，任意一台报错则报错。（2.1.0开始支持）通常用于通知所有提供者更新缓存或日志等本地资源信息。 12345&lt;!-- 服务提供者方的配置 --&gt;&lt;dubbo:service cluster=\"broadcast\" /&gt; &lt;!-- 服务消费者方的配置 --&gt;&lt;dubbo:reference cluster=\"broadcast\" /&gt; 注解配置示例： 12345// 服务提供者方的配置（亲测不起作用）@com.alibaba.dubbo.config.annotation.Service(cluster = \"broadcast\") // 服务消费者方的配置@com.alibaba.dubbo.config.annotation.Reference(cluster = \"broadcast\") 参考文档文献链接：dubbo集群容错","tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"}]},{"title":"dubbo 关闭启动时检查解决服务之间调用的问题","date":"2017-07-28T07:26:57.000Z","path":"post/resolve-dubbo-services-call-situation.html","text":"dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线前，能及早发现问题，默认check=&quot;true&quot;。 如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭检查，否则服务临时不可用时会抛出异常，拿到 null 引用，如果check=&quot;false&quot;，总是会返回引用，当服务恢复时，能自动连上。 比如对一些不关心的服务，或者服务之间出现了相互依赖必须有一方先启动时，你可以关闭检查避免异常。 1. 场景描述假设现有两个已知的服务：用户中心服务、订单中心服务。它们作为服务提供者分别向 dubbo 注册了自己。用户中心服务中的UserServiceImpl调用了订单中心服务的OrderServiceImpl，如下： 12345678public class OrderServiceImpl implements OrderService &#123; @Override public void findByUserIdAndOrderStatus(Integer userId, String orderStatus) &#123; // do something &#125; &#125; 1234567891011public class UserServiceImpl implements UserService &#123; private OrderService orderService; @Override public void findPaidOrdersById(Integer id) &#123; // do something orderService.findByUserIdAndOrderStatus(id, \"PAID\"); &#125; &#125; 2. XML 配置方式订单中心服务配置信息的代码片段： 12345&lt;!-- 声明 Bean --&gt;&lt;bean id=\"orderService\" class=\"org.fanlychie.service.OrderServiceImpl\" /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt;&lt;dubbo:service interface=\"org.fanlychie.service.OrderService\" ref=\"orderService\" /&gt; 用户中心服务配置信息的代码片段： 1234567891011&lt;!-- 声明引用的服务, check 设为 false 以关闭服务的启动时检查, 避免服务启动顺序引发的异常 --&gt;&lt;dubbo:reference id=\"orderService\" interface=\"org.fanlychie.service.OrderService\" check=\"false\" /&gt; &lt;!-- 声明 Bean --&gt;&lt;bean id=\"userService\" class=\"org.fanlychie.service.UserServiceImpl\"&gt; &lt;!-- 声明依赖的服务 --&gt; &lt;property name=\"orderService\" ref=\"orderService\" /&gt;&lt;/bean&gt; &lt;!-- 声明需要暴露的服务接口 --&gt;&lt;dubbo:service interface=\"org.fanlychie.service.UserService\" ref=\"userService\" /&gt; &lt;dubbo:reference&gt;的 check 属性设为 false 以关闭服务的启动时检查，否则服务的启动顺序不当会直接导致服务启动不了。如check=true（默认）若先启动用户中心服务会报以下异常导致服务启动失败： 1java.lang.IllegalStateException: Failed to check the status of the service ... 在用户心中调用订单中心的服务示例代码片段，相关的依赖需要通过 setter 方法注入： 123456789101112131415public class UserServiceImpl implements UserService &#123; private OrderService orderService; @Override public void findPaidOrdersById(Integer id) &#123; // do something orderService.findByUserIdAndOrderStatus(id, \"PAID\"); &#125; public void setOrderService(OrderService orderService) &#123; this.orderService = orderService; &#125; &#125; 3. 注解的方式订单中心的服务接口使用com.alibaba.dubbo.config.annotation.@Service注解直接暴露服务： 12345678910111213package org.fanlychie.service; import com.alibaba.dubbo.config.annotation.Service; @Servicepublic class OrderServiceImpl implements OrderService &#123; @Override public void findByUserIdAndOrderStatus(Integer userId, String orderStatus) &#123; // do something &#125; &#125; 用户中心的服务接口使用com.alibaba.dubbo.config.annotation.@Service注解暴露服务，并使用使用com.alibaba.dubbo.config.annotation.@Reference注解引用订单中心的接口服务： 123456789101112131415161718package org.fanlychie.service; import com.alibaba.dubbo.config.annotation.Reference;import com.alibaba.dubbo.config.annotation.Service; @Servicepublic class UserServiceImpl implements UserService &#123; @Reference private OrderService orderService; @Override public void findPaidOrdersById(Integer id) &#123; // do something orderService.findByUserIdAndOrderStatus(id, \"PAID\"); &#125; &#125; 引用的服务的属性check应设为 false 以关闭服务的启动时检查，避免服务启动顺序引发的异常。使用注解@Reference(check = false)的方式是无效的，需要在调用方(本文为用户中心)的配置文件中添加： 12&lt;!-- 关闭引用服务的启动时检查 --&gt;&lt;dubbo:consumer check=\"false\" /&gt; 参考文档文献链接：启动时检查","tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"}]},{"title":"dubbo 注解方式整合 springmvc","date":"2017-07-27T17:54:38.000Z","path":"post/dubbo-annotation-with-springmvc.html","text":"1. 项目结构创建一个 maven 多模块项目，结构如下： 1234567dubbo-annotation-with-springmvc-sample（父模块）||__ user-module-api（服务接口模块）||__ user-module-provider（服务提供者）||__ user-module-consumer（服务消费者） 1.1 父模块项目dubbo-annotation-with-springmvc-sample/pom.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;dubbo-annotation-with-springmvc-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;dubbo-annotation-with-springmvc-sample&lt;/name&gt; &lt;description&gt;Sample project for Dubbo&lt;/description&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;modules&gt; &lt;module&gt;user-module-api&lt;/module&gt; &lt;module&gt;user-module-provider&lt;/module&gt; &lt;module&gt;user-module-consumer&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt; &lt;spring.version&gt;4.3.7.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;user-module-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;!-- dubbo依赖的spring版本（2.5）较低, 排除此依赖, 使用自己的spring版本 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 1.2 服务接口模块user-module-api/pom.xml 配置如下： 12345678910111213&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;dubbo-annotation-with-springmvc-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-module-api&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-module-api&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt;&lt;/project&gt; 编写注册用户的示例服务接口： 1234567package org.fanlychie.service; public interface UserService &#123; void register(String username, String password); &#125; 1.3 服务提供者user-module-provider/pom.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;dubbo-annotation-with-springmvc-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-module-provider&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-module-provider&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;user-module-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 打包配置, 输出可执行的 jar 包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.alibaba.dubbo.container.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 实现服务接口，使用com.alibaba.dubbo.config.annotation.@Service注解暴露服务： 12345678910111213141516package org.fanlychie.service; import com.alibaba.dubbo.config.annotation.Service; @Servicepublic class UserServiceImpl implements UserService &#123; @Override public void register(String username, String password) &#123; System.out.println(\"---------------------------------------------------------\"); System.out.println(String.format(\"接收到注册用户请求 - &#123;username:%s, password:%s&#125;\", username, password)); System.out.println(\"---------------------------------------------------------\"); &#125; &#125; user-module-provider/src/main/resources/dubbo.properties 配置如下： 1dubbo.spring.config=classpath:spring-dubbo-provider.xml user-module-provider/src/main/resources/spring-dubbo-provider.xml 配置如下： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"user-module-provider\"/&gt; &lt;!-- 使用ZK注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 用Dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- 扫描注解包路径，多个包用逗号分隔 --&gt; &lt;dubbo:annotation package=\"org.fanlychie.service\"/&gt; &lt;/beans&gt; user-module-provider/src/main/resources/log4j.properties 配置如下： 12345log4j.rootCategory = INFO, consolelog4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.target = System.outlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.conversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125; [%t] %-5p [%c&#123;1&#125;:%L] - %m%n 1.4 服务消费者user-module-consumer/pom.xml 配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;dubbo-annotation-with-springmvc-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-module-consumer&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;user-module-consumer&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;user-module-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;autosellrobot-wechat&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;url&gt;http://localhost:8080/manager/html&lt;/url&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 服务消费者使用com.alibaba.dubbo.config.annotation.@Reference注解引用接口服务： 12345678910111213141516171819202122import com.alibaba.dubbo.config.annotation.Reference;import org.fanlychie.service.UserService;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController; @RestControllerpublic class UserController &#123; @Reference private UserService userService; @GetMapping(\"/user/register\") public String register(String username, String password) &#123; if (!StringUtils.hasText(username) || !StringUtils.hasText(password)) &#123; return \"用户名或密码不能为空\"; &#125; userService.register(username, password); return \"注册完成\"; &#125; &#125; user-module-consumer/src/main/webapp/WEB-INF/web.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; user-module-consumer/src/main/resources/log4j.properties 配置如下： 12345log4j.rootCategory = INFO, consolelog4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.target = System.outlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.conversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125; [%t] %-5p [%c&#123;1&#125;:%L] - %m%n user-module-consumer/src/main/resources/spring-context.xml 配置如下： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"org.fanlychie\"/&gt; &lt;/beans&gt; user-module-consumer/src/main/resources/spring-mvc.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"user-module-consumer\"/&gt; &lt;!-- 使用ZK注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 扫描注解包路径，多个包用逗号分隔 --&gt; &lt;dubbo:annotation package=\"org.fanlychie.controller\"/&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"&gt; &lt;property name=\"useSuffixPatternMatch\" value=\"true\"/&gt; &lt;property name=\"useTrailingSlashMatch\" value=\"true\"/&gt; &lt;/bean&gt; &lt;bean id=\"stringHttpMessageConverter\" class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;value&gt;application/xml;charset=utf-8&lt;/value&gt; &lt;value&gt;application/json;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"mappingJackson2HttpMessageConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"prefixJson\" value=\"false\"/&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;value&gt;application/xml;charset=utf-8&lt;/value&gt; &lt;value&gt;application/json;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;ref bean=\"stringHttpMessageConverter\"/&gt; &lt;ref bean=\"mappingJackson2HttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:component-scan base-package=\"org.fanlychie.**.controller\"/&gt; &lt;/beans&gt; 服务消费者方 dubbo 注解扫描配置的信息不能独立出 springmvc 配置文件，否则@Reference注解引用的接口实例会出现 Null 的状况。 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring-4.7、Dubbo-2.5.3完整示例项目链接：dubbo-annotation-with-springmvc-sample参考文档文献链接：dubbo用户指南","tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"}]},{"title":"dubbo 配置方式","date":"2017-07-27T08:12:08.000Z","path":"post/dubbo-configurations.html","text":"dubbo 提供了4种服务配置的方式，它们分别是：XML 配置、属性配置、注解配置、API 配置（官方不推荐 API 配置的方式）。本文只介绍前三种，API 配置方式可点此前往官方文档查看API配置。 1. XML 配置配置参考手册： 标签 描述 &lt;dubbo:service&gt; 服务提供者暴露服务配置，用于定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心。 &lt;dubbo:protocol&gt; 服务提供者协议配置，用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受。 &lt;dubbo:reference&gt; 服务消费者引用服务配置，用于创建一个远程服务代理，一个引用可以指向多个注册中心。 &lt;dubbo:registry&gt; 注册中心配置，用于配置连接注册中心相关信息。 &lt;dubbo:application&gt; 应用配置，用于配置当前应用信息，不管该应用是提供者还是消费者。 &lt;dubbo:module&gt; 模块配置，用于配置当前模块信息，可选。 &lt;dubbo:monitor&gt; 监控中心配置，用于配置连接监控中心相关信息，可选。 &lt;dubbo:provider&gt; 服务提供者缺省值配置，当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选。 &lt;dubbo:consumer&gt; 服务消费者缺省值配置，当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选。 &lt;dubbo:method&gt; 方法配置，用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息。 &lt;dubbo:argument&gt; 方法参数配置。 注：标签属性只有group,interface,version是服务的匹配条件，三者用于共同决定是否是同一个服务，其它属性配置项均为调优和治理参数。 1.1 dubbo:service必填属性参考列表（更多可选参数可点此前往官方文档查看）： 属性名称 类型 描述 interface class 服务接口名 ref object 服务对象实现引用 123&lt;dubbo:service interface=\"org.fanlychie.service.UserService\" ref=\"userService\"/&gt; &lt;bean id=\"userService\" class=\"org.fanlychie.service.UserServiceImpl\"/&gt; 1.2 dubbo:protocol必填属性参考列表（更多可选参数可点此前往官方文档查看）： 属性名称 类型 描述 name string 协议名称 1&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; dubbo 支持的协议有：dubbo、rmi、hessian、http、webservice、thrift、redis、memcached。各个协议的介绍和使用场景可点此前往官方文档查看协议参考手册。 1.3 dubbo:reference必填属性参考列表（更多可选参数可点此前往官方文档查看）： 属性名称 类型 描述 id string 服务引用的 Bean ID interface class 服务接口名 1&lt;dubbo:reference id=\"userService\" interface=\"org.fanlychie.service.UserService\" /&gt; 1.4 dubbo:registry必填属性参考列表（更多可选参数可点此前往官方文档查看）： 属性名称 类型 描述 address string 注册中心服务器地址，如果地址没有端口缺省为 9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port，不同集群的注册中心，请配置多个&lt;dubbo:registry&gt; 标签 1&lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; dubbo 提供支持的服务注册中心有：multicast、zookeeper、redis、simple。官方推荐你使用zookeeper注册中心，详细信息可点此前往官方文档查看注册中心参考手册。 1.5 dubbo:application必填属性参考列表（更多可选参数可点此前往官方文档查看）： 属性名称 类型 描述 name string 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样，此参数不是匹配条件，你当前项目叫什么名字就填什么，和提供者消费者角色无关 1&lt;dubbo:application name=\"user-module-provider\"/&gt; 2. 属性配置如果公共配置很简单，没有多注册中心，多协议等情况，或者想多个 Spring 容器想共享配置，可以使用 dubbo.properties 作为缺省配置。dubbo 将自动加载类路径下的 dubbo.properties，可以通过 JVM 启动参数：-Ddubbo.properties.file=xxx.properties改变缺省配置位置。如果类路径下存在多个 dubbo.properties，比如多个 jar 包中有 dubbo.properties，dubbo 会任意加载，并打印 Error 日志，后续可能改为抛异常。 2.1 映射规则 将 XML 配置的标签名，加属性名，用点分隔，多个属性拆成多行： 比如 dubbo.application.name=foo 等价于：&lt;dubbo:application name=&quot;foo&quot;/&gt; 如果 XML 有多行同名标签配置，可用 id 号区分，如果没有 id 号将对所有同名标签生效： 比如 dubbo.protocol.rmi.port=1234 等价于：&lt;dubbo:protocol id=&quot;rmi&quot; name=&quot;rmi&quot; port=&quot;1099&quot;/&gt; 比如 dubbo.registry.china.address=10.20.153.10:9090 等价于：&lt;dubbo:registry id=&quot;china&quot; address=&quot;10.20.153.10:9090&quot;/&gt; 123dubbo.application.name=foodubbo.application.owner=bardubbo.registry.address=10.20.153.10:9090 2.2 覆盖策略JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。 3. 注解配置dubbo 2.2.1 以上的版本支持注解配置。 3.1 服务提供者服务提供者使用com.alibaba.dubbo.config.annotation.@Service注解暴露服务： 12345678910111213141516package org.fanlychie.service; import com.alibaba.dubbo.config.annotation.Service; @Servicepublic class UserServiceImpl implements UserService &#123; @Override public void register(String username, String password) &#123; System.out.println(\"---------------------------------------------------------\"); System.out.println(String.format(\"接收到注册用户请求 - &#123;username:%s, password:%s&#125;\", username, password)); System.out.println(\"---------------------------------------------------------\"); &#125; &#125; 服务提供者使用&lt;dubbo:annotation&gt;配置扫描的包路径，多个包用逗号分隔： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;dubbo:application name=\"user-module-provider\"/&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;dubbo:annotation package=\"org.fanlychie.service\"/&gt; &lt;/beans&gt; 3.2 服务消费者服务消费者使用com.alibaba.dubbo.config.annotation.@Reference注解引用接口服务： 12345678910111213141516171819202122import com.alibaba.dubbo.config.annotation.Reference;import org.fanlychie.service.UserService;import org.springframework.util.StringUtils;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController; @RestControllerpublic class UserController &#123; @Reference private UserService userService; @GetMapping(\"/user/register\") public String register(String username, String password) &#123; if (!StringUtils.hasText(username) || !StringUtils.hasText(password)) &#123; return \"用户名或密码不能为空\"; &#125; userService.register(username, password); return \"注册完成\"; &#125; &#125; 服务消费者&lt;dubbo:annotation&gt;配置扫描的包路径，多个包用逗号分隔： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;dubbo:application name=\"user-module-consumer\"/&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;dubbo:annotation package=\"org.fanlychie.controller\"/&gt; &lt;/beans&gt; 参考文档文献链接：dubbo用户指南","tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"}]},{"title":"dubbo 快速入门","date":"2017-07-26T10:30:38.000Z","path":"post/dubbo-quickstart.html","text":"dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。它采用全 Spring 配置方式，透明化接入应用，对应用没有任何API侵入，只需用 Spring 加载 dubbo 的配置即可。如需了解更多相关信息可前往官方文档用户指南部分的介绍。 1. 创建项目创建一个 maven 多模块项目，结构如下： 1234567dubbo-quickstart-sample（父模块）||__ user-module-api（服务接口模块）||__ user-module-provider（服务提供者）||__ user-module-consumer（服务消费者） 1.1 父模块项目dubbo-quickstart-sample/pom.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;dubbo-quickstart-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;dubbo-quickstart-sample&lt;/name&gt; &lt;description&gt;Sample project for Dubbo&lt;/description&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;modules&gt; &lt;module&gt;user-module-api&lt;/module&gt; &lt;module&gt;user-module-provider&lt;/module&gt; &lt;module&gt;user-module-consumer&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt; &lt;spring.version&gt;4.3.7.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;user-module-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;!-- dubbo依赖的spring版本（2.5）较低, 排除此依赖, 使用自己的spring版本 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 1.2 服务接口模块user-module-api/pom.xml 配置如下： 12345678910111213&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;dubbo-quickstart-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-module-api&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-module-api&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt;&lt;/project&gt; 编写注册用户的示例服务接口： 1234567package org.fanlychie.service; public interface UserService &#123; void register(String username, String password); &#125; 1.3 服务提供者user-module-provider/pom.xml 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;dubbo-quickstart-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-module-provider&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-module-provider&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;user-module-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 打包配置, 输出可执行的 jar 包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.alibaba.dubbo.container.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 实现服务接口： 12345678910111213package org.fanlychie.service; public class UserServiceImpl implements UserService &#123; @Override public void register(String username, String password) &#123; System.out.println(\"---------------------------------------------------------\"); System.out.println(String.format(\"接收到注册用户请求 - &#123;username:%s, password:%s&#125;\", username, password)); System.out.println(\"---------------------------------------------------------\"); &#125; &#125; user-module-provider/src/main/resources/dubbo.properties 配置如下： 1234# 服务容器dubbo.container=spring# 容器加载的 spring 配置文件dubbo.spring.config=classpath:spring-dubbo-provider.xml user-module-provider/src/main/resources/spring-dubbo-provider.xml 配置如下： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"user-module-provider\"/&gt; &lt;!-- 使用ZK注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 用Dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- 和本地Bean一样实现服务 --&gt; &lt;bean id=\"userService\" class=\"org.fanlychie.service.UserServiceImpl\"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=\"org.fanlychie.service.UserService\" ref=\"userService\"/&gt; &lt;/beans&gt; user-module-provider/src/main/resources/log4j.properties 配置如下： 12345log4j.rootCategory = INFO, consolelog4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.target = System.outlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.conversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125; [%t] %-5p [%c&#123;1&#125;:%L] - %m%n 1.4 服务消费者user-module-consumer/pom.xml 配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;dubbo-quickstart-sample&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-module-consumer&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;user-module-consumer&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;user-module-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;autosellrobot-wechat&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;url&gt;http://localhost:8080/manager/html&lt;/url&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写用户注册的服务方法： 12345678910111213141516@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(\"/user/register\") public String register(String username, String password) &#123; if (!StringUtils.hasText(username) || !StringUtils.hasText(password)) &#123; return \"用户名或密码不能为空\"; &#125; userService.register(username, password); return \"注册完成\"; &#125; &#125; user-module-consumer/src/main/webapp/WEB-INF/web.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; user-module-consumer/src/main/resources/spring-context.xml 配置如下： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"org.fanlychie\"/&gt; &lt;import resource=\"spring-dubbo-consumer.xml\"/&gt; &lt;/beans&gt; user-module-consumer/src/main/resources/spring-dubbo-consumer.xml 配置如下： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"user-module-consumer\"/&gt; &lt;!-- 使用ZK注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 生成远程服务代理，可以和本地Bean一样使用 --&gt; &lt;dubbo:reference id=\"userService\" interface=\"org.fanlychie.service.UserService\" /&gt; &lt;/beans&gt; user-module-consumer/src/main/resources/spring-mvc.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"&gt; &lt;property name=\"useSuffixPatternMatch\" value=\"true\"/&gt; &lt;property name=\"useTrailingSlashMatch\" value=\"true\"/&gt; &lt;/bean&gt; &lt;bean id=\"stringHttpMessageConverter\" class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;value&gt;application/xml;charset=utf-8&lt;/value&gt; &lt;value&gt;application/json;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"mappingJackson2HttpMessageConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"prefixJson\" value=\"false\"/&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;value&gt;application/xml;charset=utf-8&lt;/value&gt; &lt;value&gt;application/json;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;ref bean=\"stringHttpMessageConverter\"/&gt; &lt;ref bean=\"mappingJackson2HttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:component-scan base-package=\"org.fanlychie.**.controller\"/&gt; &lt;/beans&gt; user-module-consumer/src/main/resources/log4j.properties 配置如下： 12345log4j.rootCategory = INFO, consolelog4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.target = System.outlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.conversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125; [%t] %-5p [%c&#123;1&#125;:%L] - %m%n 2. 启动服务首先需要先启动 zookeeper 服务（可参考Zookeeper安装和配置），再启动 dubbo-admin 应用（可选，可参考dubbo-admin管理控制台应用安装）。 2.1 启动服务提供者本示例将启用2个服务提供者的实例，并使用 dubbo 提供的com.alibaba.dubbo.container.Main启动类来启动服务提供者的实例。下面介绍3种较为常用的启动命令。 2.1.1 maven 命令启动1234# 启动第一个实例, 端口 20881&gt; mvn exec:java -Ddubbo.protocol.port=20881 -Dexec.mainClass=com.alibaba.dubbo.container.Main# 启动第二个实例, 端口 20882&gt; mvn exec:java -Ddubbo.protocol.port=20882 -Dexec.mainClass=com.alibaba.dubbo.container.Main 2.1.2 application 启动以开发工具 IntelliJ IDEA 为例，Run -&gt; Edit Configurations添加一个 Application，配置如下： 2.1.3 jar 包启动在父模块项目 dubbo-quickstart-sample 根目录下执行打包命令： 1&gt; mvn package 执行完成之后，在 dubbo-quickstart-sample/user-module-provider/target 目录下将得到一个可执行的 jar 包：user-module-provider-0.0.1-SNAPSHOT.jar。 1234# 启动第一个实例, 端口 20881&gt; java -jar -Ddubbo.protocol.port=20881 user-module-provider-0.0.1-SNAPSHOT.jar# 启动第二个实例, 端口 20882&gt; java -jar -Ddubbo.protocol.port=20882 user-module-provider-0.0.1-SNAPSHOT.jar 2.2 启动服务消费者服务消费者 user-module-consumer 是一个 web 项目，使用内置 tomcat 容器或部署到外部的 tomcat 运行即可。 如使用内置 tomcat 插件启动的 maven 命令： 3. 访问服务访问地址：http://localhost:8080/user/register?username=fanlychie&amp;password=123456可在服务提供者的控制台查看相关的输出信息。你也可以在 dubbo-admin 应用查看和管理相关的服务： 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring-4.7、Dubbo-2.5.3完整示例项目链接：dubbo-quickstart-sample参考文档文献链接：dubbo用户指南","tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"}]},{"title":"dubbo-admin 管理控制台应用安装","date":"2017-07-25T14:20:38.000Z","path":"post/dubbo-admin-setup.html","text":"dubbo 管理控制台是其内部裁剪版本，开源部分主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。 1. 安装应用目前最新的发布版本为 2.5.3，但由于仓库问题下载不了依赖包，亲测主分支代码可以编译通过。首先下载最新的源代码： 1git clone https://github.com/alibaba/dubbo.git 最新源代码拉下来之后，在 dubbo 文件夹的根目录下，执行编译安装命令： 1mvn install -Dmaven.test.skip=true 执行完成之后，在 dubbo/dubbo-admin/target 目录下得到 dubbo-admin-2.5.4-SNAPSHOT.war。 在 tomcat 的 webapps 目录下创建 dubbo-admin 文件夹，即：tomcat/webapps/dubbo-admin，并将安装包拷贝到该目录下，并对安装包进行解压缩（解压缩完成之后，删除安装包即可）： 1jar xvf dubbo-admin-2.5.4-SNAPSHOT.war 接着我们可以验证安装是否成功。首先需要先启动 zookeeper（可参考Zookeeper安装和配置），再启动 dubbo-admin 的 tomcat。访问http://localhost:8080/dubbo-admin。账户密码可在 dubbo-admin/WEB-INF/dubbo.properties 中查看和配置（默认为：root/root、guest/guest）。 参考文档文献链接：dubbo管理员指南","tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"}]},{"title":"Zookeeper 介绍和安装","date":"2017-07-25T12:56:35.000Z","path":"post/zookeeper-setup.html","text":"1. 简介ZooKeeper 是一个开放源码的分布式应用程序协调服务。所谓分布式协调服务，就是能够在集群的节点中进行可靠的消息传递，以此来协调集群的工作。它能够为分布式应用提供的基础服务有：命名服务、配置维护、组服务、分布式消息队列、分布式通知/协调、分布式锁等。 2. CAP 理论 理论 描述 C（Consistency） 一致性。当执行一个更新操作成功后，分布式系统中的所有节点在同一时刻的数据完全一致（这就要求分布式系统的运行就像在单机上运行一样）。 A（Availability） 可用性。当集群中的一个节点失效时，新的节点顶替故障的节点，整个集群对外仍然是可用的。 P（Partition tolerance） 分区容忍性。支持动态（不停机）横向扩展，当系统性能遇到瓶颈时，可通过动态增加服务器数量来提升系统的整体性能。 一个分布式系统如果丧失了分区容忍性，就意味着放弃了系统的扩展性。分布式系统本质上是不可靠的，由于网络故障无法完全避免，一旦出现就会导致整个系统的不可用，这是绝对不能容忍的。这也是大部分分布式系统都会在保证分区容忍性的前提下在一致性和可用性之间做权衡的原因。Zookeeper 是一个CP的。 3. 安装到 Zookeeper官网 下载安装包，本文使用 zookeeper-3.4.10.tar.gz 安装包。 解压缩： 1$ tar zxvf zookeeper-3.4.10.tar.gz 删除安装包： 1$ rm -f zookeeper-3.4.10.tar.gz 4. 单机模式配置拷贝一份 zookeeper-3.4.10/conf/zoo_sample.cfg 配置文件并重命名为 zoo.cfg： 12$ cd zookeeper-3.4.10/conf/$ cp zoo_sample.cfg zoo.cfg 编辑 zoo.cfg 配置文件： 1$ vi zoo.cfg 内容如下： 1234tickTime=2000dataDir=/usr/local/applications/zookeeper/datadataLogDir=/usr/local/applications/zookeeper/logsclientPort=2181 参数说明： 参数 描述 tickTime 基本时间单位（毫秒） dataDir 数据目录的路径 dataLogDir 日志目录的路径 clientPort 端口号 启动服务命令（在 bin 目录下执行）： 1$ ./zkServer.sh start 重启服务命令（在 bin 目录下执行）： 1$ ./zkServer.sh restart 查看服务状态（在 bin 目录下执行）： 1$ ./zkServer.sh status 停止服务命令（在 bin 目录下执行）： 1$ ./zkServer.sh stop 5. 伪集群模式配置伪集群是指在单台机器中启动多个 Zookeeper 服务并组成一个集群。Zookeeper 集群中只要有过半的节点是正常的，那么整个集群对外就是可用的。基于这种特性，Zookeeper 集群的节点数量通常为奇数个。 拷贝三份 Zookeeper： 123$ cp -r zookeeper-3.4.10/ zookeeper-1$ cp -r zookeeper-3.4.10/ zookeeper-2$ cp -r zookeeper-3.4.10/ zookeeper-3 配置 zookeeper-1/conf/zoo.cfg： 123456789tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/applications/zookeeper/cluster/node1/datadataLogDir=/usr/local/applications/zookeeper/cluster/node1/logsclientPort=2181server.1=127.0.0.1:8881:9991server.2=127.0.0.1:8882:9992server.3=127.0.0.1:8883:9993 参数说明： 参数 描述 initLimit 初始化连接时, follower 和 leader 之间的最长心跳时间。若设置为 10，表示 10 倍的 tickTime 时间 syncLimit leader 和 follower 之间发送消息，请求和应答的最大时间。若设置为 5，表示 5 倍的 tickTime 时间 server.X=A:B:C X 是一个数字，表示这是第几个服务。A 是服务器的IP地址。B 是服务器和 leader 交换消息所使用的端口。C 是选举 leader 时所使用的端口 zookeeper-2 和 zookeeper-3 的配置与 zookeeper-1 基本相同，只需改变 dataDir、dataLogDir、clientPort 参数的值。配置 zookeeper-2/conf/zoo.cfg： 123456789tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/applications/zookeeper/cluster/node2/datadataLogDir=/usr/local/applications/zookeeper/cluster/node2/logsclientPort=2182server.1=127.0.0.1:8881:9991server.2=127.0.0.1:8882:9992server.3=127.0.0.1:8883:9993 配置 zookeeper-3/conf/zoo.cfg： 123456789tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/applications/zookeeper/cluster/node3/datadataLogDir=/usr/local/applications/zookeeper/cluster/node3/logsclientPort=2183server.1=127.0.0.1:8881:9991server.2=127.0.0.1:8882:9992server.3=127.0.0.1:8883:9993 在相应的数据目录下创建 myid 文件，并输入相对应的数字编号的值作为内容： 12345678$ mkdir -p /usr/local/applications/zookeeper/cluster/node1/data$ vi /usr/local/applications/zookeeper/cluster/node1/data/myid # 输入内容：1 $ mkdir -p /usr/local/applications/zookeeper/cluster/node2/data$ vi /usr/local/applications/zookeeper/cluster/node2/data/myid # 输入内容：2 $ mkdir -p /usr/local/applications/zookeeper/cluster/node3/data$ vi /usr/local/applications/zookeeper/cluster/node3/data/myid # 输入内容：3 启动服务命令： 123$ zookeeper-1/bin/zkServer.sh start$ zookeeper-2/bin/zkServer.sh start$ zookeeper-3/bin/zkServer.sh start 查看服务状态： 123$ zookeeper-1/bin/zkServer.sh status$ zookeeper-2/bin/zkServer.sh status$ zookeeper-3/bin/zkServer.sh status 6. 集群模式配置集群模式的配置和伪集群的配置基本相同。在集群模式下，由于各个服务部署在不同的主机上，因此，zoo.cfg 配置文件的配置内容可以是完全一样的。 123456789tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/applications/zookeeper/datadataLogDir=/usr/local/applications/zookeeper/logsclientPort=2181server.1=192.168.1.101:2555:3555server.2=192.168.1.102:2555:3555server.3=192.168.1.103:2555:3555 在各主机相应的数据目录下创建 myid 文件，并输入相对应的数字编号的值作为内容： 12345678$ mkdir -p /usr/local/applications/zookeeper/data$ vi /usr/local/applications/zookeeper/data/myid # 192.168.1.101 输入内容：1 $ mkdir -p /usr/local/applications/zookeeper/data$ vi /usr/local/applications/zookeeper/data/myid # 192.168.1.102 输入内容：2 $ mkdir -p /usr/local/applications/zookeeper/data$ vi /usr/local/applications/zookeeper/data/myid # 192.168.1.103 输入内容：3 各主机防火墙分别开放相对应的端口： 123-A INPUT -m state --state NEW -m tcp -p tcp --dport 2181 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 2555 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3555 -j ACCEPT 各主机启动服务命令： 1$ zookeeper-3.4.10/bin/zkServer.sh start 查看服务状态： 1$ zookeeper-3.4.10/bin/zkServer.sh status","tags":[{"name":"Zookeeper","slug":"Zookeeper","permalink":"http://yoursite.com/tags/Zookeeper/"}]},{"title":"Spring Cloud Ribbon — 客户端负载均衡器","date":"2017-07-20T05:57:18.000Z","path":"post/spring-cloud-netflix-ribbon.html","text":"Ribbon 是 Netflix 开源的项目，主要用于为提供客户端软件提供负载均衡算法。Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的一个基于 HTTP 和 TCP 的客户端负载均衡器。 1. Ribbon 单独使用创建两个项目：order-service（订单服务，作为服务提供者）、user-center（用户中心，作为服务消费者）。并在 user-center（服务消费者）端使用 Spring Cloud Ribbon 做客户端负载均衡。 1.1 服务提供者在 order-service/pom.xml 中声明依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 在 order-service/src/main/resources/application.yml 配置两个端口以便启动两个不同实例用于测试： 123456789101112131415spring: application: name: order-service profiles: active: service1---spring: profiles: service1server: port: 8881---spring: profiles: service2server: port: 8882 编写查询用户订单的服务方法： 12345678910111213141516@RestController@RequestMapping(\"/order\")public class OrderController &#123; @Autowired private OrderRepository orderRepository; @GetMapping(\"/find/&#123;uid:[1-9]\\\\d+&#125;\") public List&lt;Order&gt; findByUid(@PathVariable Integer uid) &#123; System.out.println(\"------------------------------------------------\"); System.out.println(\"------------------ 方法被调用 ------------------\"); System.out.println(\"------------------------------------------------\"); return orderRepository.findByUid(uid); &#125; &#125; 配置根路径的访问许可，以便客户端负载均衡器能够 PING 通本服务： 123456789@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addStatusController(\"/\", HttpStatus.OK); &#125; &#125; 编写 Spring Boot 应用启动类： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 1.2 服务消费者在 user-center/pom.xml 中声明依赖： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 在 user-center/src/main/resources/application.yml 配置客户端负载均衡： 12345678910111213server: port: 8888spring: application: name: user-centerorder-service: ribbon: eureka: enabled: false # 微服务的服务器列表 listOfServers: localhost:8881,localhost:8882 # 刷新微服务的服务器列表信息间隔的毫秒数 ServerListRefreshInterval: 3000 默认情况下，Spring Cloud Ribbon 使用 NoOpPing 作为 IPing 的实现，NoOpPing 实际上并没有 PING 服务器而是一直返回 true。而 PingUrl 则会通过 PING 服务器根路径地址来检查每一台服务器的状态以确认服务是否还在线。默认情况下，Spring Cloud Ribbon 使用 ZoneAvoidanceRule 作为 IRule 的实现，ZoneAvoidanceRule 基于 AZ（可用区）过滤服务器最大程度避免区域服务器故障。由于本地环境测试，这里采用 AvailabilityFilteringRule，它使用 Ribbon 内置的断路器功能来过滤掉处于开路状态（无法 PING 通）的服务器。 12345678910111213141516public class RibbonConfiguration &#123; @Autowired private IClientConfig ribbonClientConfig; @Bean public IPing ribbonPing(IClientConfig config) &#123; return new PingUrl(); &#125; @Bean public IRule ribbonRule(IClientConfig config) &#123; return new AvailabilityFilteringRule(); &#125; &#125; 编写用户订单查询服务： 12345678910111213@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(\"/orders/&#123;uid:[1-9]\\\\d+&#125;\") public List&lt;Order&gt; orders(@PathVariable Integer uid) &#123; return restTemplate.getForObject(String.format(\"http://order-service/order/find/%d\", uid), List.class); &#125; &#125; 编写 Spring Boot 应用启动类，使用@LoadBalanced注解，为 RestTemplate 开启负载均衡的能力： 123456789101112131415@SpringBootApplication@RibbonClient(name = \"order-service\", configuration = RibbonConfiguration.class)public class Application &#123; @Bean @LoadBalanced public RestTemplate proviceRestTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 1.3 启动服务启动两个服务提供者服务： 12$ java -jar order-service-0.0.1-SNAPSHOT.jar$ java -Dspring.profiles.active=service2 -jar order-service-0.0.1-SNAPSHOT.jar 启动一个服务消费者服务： 1$ java -jar user-center-0.0.1-SNAPSHOT.jar 你可以尝试多次访问用户订单服务，或尝试途中关闭其中一个服务提供者服务再访问用户订单服务，以便查看其效果。 1$ curl -i -X GET http://localhost:8888/user/orders/1001 2. 整合 Eureka创建三个项目：eureka-server（服务注册中心）、order-service（订单服务，作为服务提供者）、user-center（用户中心，作为服务消费者）。并在 user-center（服务消费者）端使用 Spring Cloud Ribbon 做客户端负载均衡。 2.1 服务注册中心在 eureka-server/pom.xml 中声明依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; eureka-server/src/main/resources/application.yml 配置示例： 12345678910111213141516171819server: port: 8761spring: application: name: eureka-servereureka: instance: hostname: localhost server: renewal-percent-threshold: 0.49 client: register-with-eureka: false fetch-registry: false service-url: default-zone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/logging: level: com.netflix.eureka: 'off' com.netflix.discovery: 'off' Spring Boot 应用启动类： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 2.2 服务提供者在 order-service/pom.xml 中声明依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 在 order-service/src/main/resources/application.yml 配置两个端口以便启动两个不同实例用于测试： 12345678910111213141516171819spring: application: name: order-service profiles: active: service1eureka: client: service-url: defaultZone: http://localhost:8761/eureka/---spring: profiles: service1server: port: 8881---spring: profiles: service2server: port: 8882 编写查询用户订单的服务方法： 12345678910111213141516@RestController@RequestMapping(\"/order\")public class OrderController &#123; @Autowired private OrderRepository orderRepository; @GetMapping(\"/find/&#123;uid:[1-9]\\\\d+&#125;\") public List&lt;Order&gt; findByUid(@PathVariable Integer uid) &#123; System.out.println(\"------------------------------------------------\"); System.out.println(\"------------------ 方法被调用 ------------------\"); System.out.println(\"------------------------------------------------\"); return orderRepository.findByUid(uid); &#125; &#125; 编写 Spring Boot 应用启动类： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 2.3 服务消费者在 user-center/pom.xml 中声明依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; user-center/src/main/resources/application.yml 配置示例： 12345678910server: port: 8888spring: application: name: user-centereureka: client: register-with-eureka: false serviceUrl: defaultZone: http://localhost:8761/eureka/ 编写用户订单查询服务： 12345678910111213@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(\"/orders/&#123;uid:[1-9]\\\\d+&#125;\") public List&lt;Order&gt; orders(@PathVariable Integer uid) &#123; return restTemplate.getForObject(String.format(\"http://order-service/order/find/%d\", uid), List.class); &#125; &#125; 编写 Spring Boot 应用启动类，使用@LoadBalanced注解，为 RestTemplate 开启负载均衡的能力： 123456789101112131415@SpringBootApplication@RibbonClient(name = \"order-service\", configuration = RibbonConfiguration.class)public class Application &#123; @Bean @LoadBalanced public RestTemplate proviceRestTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 2.4 启动服务启动服务注册中心： 1$ java -jar eureka-server-0.0.1-SNAPSHOT.jar 启动两个服务提供者服务： 12$ java -jar order-service-0.0.1-SNAPSHOT.jar$ java -Dspring.profiles.active=service2 -jar order-service-0.0.1-SNAPSHOT.jar 启动一个服务消费者服务： 1$ java -jar user-center-0.0.1-SNAPSHOT.jar 你可以尝试多次访问用户订单服务，或尝试途中关闭其中一个服务提供者服务再访问用户订单服务，以便查看其效果。 1$ curl -i -X GET http://localhost:8888/user/orders/1001 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Cloud-Dalston.SR1完整示例项目链接：spring-cloud-netflix-ribbon-sample、spring-cloud-netflix-ribbon-with-eureka-sample参考文档文献链接：client-side-load-balancing、spring-cloud-ribbon","tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://yoursite.com/tags/Spring-Cloud/"}]},{"title":"Spring Boot @Scheduled 定时任务","date":"2017-06-24T13:04:47.000Z","path":"post/spring-boot-scheduled.html","text":"Spring Boot 2.0 开始对 Quartz 提供了支持，可以通过@Scheduled注解来创建定时任务。 依赖声明： 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-boot-starter-quartz：Quartz Scheduler 启动器。 启动类： 123456789@SpringBootApplication@EnableSchedulingpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; @EnableScheduling：用于启动定时任务。 @Scheduled(fixedDelay)：1234567891011121314151617package org.fanlychie.core; import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.concurrent.TimeUnit; @Componentpublic class ScheduledTask &#123; @Scheduled(fixedDelay = 5000) public void fixedDelayTask() throws InterruptedException &#123; System.out.println(\"[fixedDelay] \" + LocalDateTime.now()); TimeUnit.MILLISECONDS.sleep(2000); &#125; &#125; fixedDelay：从上一次任务执行完成之后开始计算，间隔多长时间再执行。 运行结果输出： 123[fixedDelay] 2018-07-14T14:07:12.877[fixedDelay] 2018-07-14T14:07:19.878[fixedDelay] 2018-07-14T14:07:26.879 @Scheduled(fixedRate)：12345@Scheduled(fixedRate = 5000)public void fixedRateTask() throws InterruptedException &#123; System.out.println(\"[fixedRate] \" + LocalDateTime.now()); TimeUnit.MILLISECONDS.sleep(2000);&#125; fixedRate：从上一次任务执行时开始计算，间隔多长时间再执行。 运行结果输出： 123[fixedRate] 2018-07-14T14:09:23.248[fixedRate] 2018-07-14T14:09:28.230[fixedRate] 2018-07-14T14:09:33.229 @Scheduled(initialDelay)：12345@Scheduled(initialDelay = 2000, fixedRate = 5000)public void initialDelayTask() throws InterruptedException &#123; System.out.println(\"[initialDelay] \" + LocalDateTime.now()); TimeUnit.MILLISECONDS.sleep(2000);&#125; initialDelay：计划任务第一次启动时延迟多长时间执行。它通常搭配fixedDelay或fixedRate来使用。 运行结果输出： 123[initialDelay] 2018-07-14T14:13:31.410[initialDelay] 2018-07-14T14:13:36.399[initialDelay] 2018-07-14T14:13:41.312 @Scheduled(cron)：12345@Scheduled(cron = \"*/5 * * * * ?\")public void cronTask() throws InterruptedException &#123; System.out.println(\"[cron] \" + LocalDateTime.now()); TimeUnit.MILLISECONDS.sleep(2000);&#125; cron：使用「cron表达式」定义计划任务的执行规则。 运行结果输出： 123[cron] 2018-07-14T22:07:10.004[cron] 2018-07-14T22:07:15.001[cron] 2018-07-14T22:07:20.001 并行执行计划任务通过@Scheduled配置的计划任务是串行执行的，多个任务之间会相互影响（当一个任务未执行完，另一个任务需要等待）。如果想要避免这个问题，可以采用并行的方式执行任务。 123456789@Configurationpublic class ApplicationConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.setScheduler(Executors.newScheduledThreadPool(4)); &#125; &#125; newScheduledThreadPool：用于创建一个固定大小的线程池，并且它支持定时或周期性的执行任务。 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2018、Spring Boot-1.5.14.RELEASE完整示例项目链接：spring-boot-scheduled-sample","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot ActiveMQ","date":"2017-06-23T13:04:47.000Z","path":"post/spring-boot-activemq.html","text":"依赖声明： 1234567891011121314151617181920&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.14.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-boot-starter-activemq：ActiveMQ 启动器。 activemq-pool：连接池的依赖包。 Spring Boot 配置文件： # src/main/resources/application.yml12345678910111213141516171819202122232425262728spring: activemq: # 链接地址, 采用故障转移策略 broker-url: failover:(tcp://10.10.10.127:61616,tcp://10.10.10.128:61616)?randomize=false&amp;timeout=3000 # 连接池配置 pool: # 开启连接池 enabled: true # 最大的连接数, 默认值是1, 可以适当调大一些 max-connections: 8 # 连接的空闲时间, 超时则回收, 默认是30秒, 可以适当调大一些, 提高连接的重用时间 idle-timeout: 180000 # 每个连接最大的会话数, 默认是500, 可以适当调小一些 maximum-active-session-per-connection: 300 # 自定义属性activemq: # 队列名称 queue-name: # 测试队列1 test1: QUEUE_TEST1 # 测试队列2 test2: QUEUE_TEST2 # 日志配置logging: level: root: warn 应用配置： 12345678910111213141516171819202122232425262728293031323334package org.fanlychie.config; import org.apache.activemq.command.ActiveMQQueue;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.jms.Queue; @Configurationpublic class ApplicationConfig &#123; /** * 测试队列1 * * @param queueNameTest1 通过配置文件将自定义的值注入进来 * @return */ @Bean public Queue queueTest1(@Value(\"$&#123;activemq.queue-name.test1&#125;\") String queueNameTest1) &#123; return new ActiveMQQueue(queueNameTest1); &#125; /** * 测试队列2 * * @param queueNameTest2 通过配置文件将自定义的值注入进来 * @return */ @Bean public Queue queueTest2(@Value(\"$&#123;activemq.queue-name.test2&#125;\") String queueNameTest2) &#123; return new ActiveMQQueue(queueNameTest2); &#125; &#125; @Configuration：效果等同于 Spring XML 配置方式。该注解用于 Java 编码形式配置。 消息生产者： 1234567891011121314151617181920212223242526272829303132333435363738package org.fanlychie.core; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;import javax.jms.Queue; @Componentpublic class MessageProducer &#123; @Autowired private Queue queueTest1; @Autowired private Queue queueTest2; @Autowired private JmsTemplate jmsTemplate; /** * 发送消息到测试队列1 * * @param message 消息内容 */ public void sendToQueueTest1(String message) &#123; jmsTemplate.convertAndSend(queueTest1, message); &#125; /** * 发送消息到测试队列2 * * @param message 消息内容 */ public void sendToQueueTest2(String message) &#123; jmsTemplate.convertAndSend(queueTest2, message); &#125; &#125; 消息消费者： 1234567891011121314151617181920212223242526272829package org.fanlychie.core; import org.springframework.jms.annotation.JmsListener;import org.springframework.stereotype.Component; @Componentpublic class MessageConsumer &#123; /** * 接收处理测试队列1的消息 * * @param message 消息内容 */ @JmsListener(destination = \"QUEUE_TEST1\") public void receiveQueueTest1Message(String message) &#123; System.out.println(\"====&gt;&gt; [QUEUE_TEST1] 收到消息：\" + message); &#125; /** * 接收处理测试队列2的消息 * * @param message 消息内容 */ @JmsListener(destination = \"QUEUE_TEST2\") public void receiveQueueTest2Message(String message) &#123; System.out.println(\"====&gt;&gt; [QUEUE_TEST2] 收到消息：\" + message); &#125; &#125; 启动类： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; 单元测试： 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTest &#123; @Autowired private MessageProducer messageProducer; @Test public void doTest() &#123; messageProducer.sendToQueueTest1(\"Hello\"); messageProducer.sendToQueueTest2(\"World\"); &#125; &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2018、Spring Boot-1.5.14.RELEASE完整示例项目链接：spring-boot-redis-sample、spring-boot-redis-sentinel-sample","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Redis","date":"2017-06-22T13:04:47.000Z","path":"post/spring-boot-redis.html","text":"依赖声明： 123456789101112131415161718192021&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.14.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.11.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-boot-starter-data-redis：Redis 启动器。 jackson-databind：用于以 JSON 的形式序列化存储到 Redis 上的值。 Spring Boot 配置文件： # src/main/resources/application.yml（单点模式）123456789101112131415spring: redis: host: 10.10.10.127 port: 6379 database: 0 timeout: 5000 pool: max-active: 8 max-idle: 8 min-idle: 4 max-wait: 30000 logging: level: root: warn redis 配置项说明可参考：Redis参数配置 # src/main/resources/application.yml（哨兵模式）123456789101112131415161718spring: redis: host: 10.10.10.127 port: 6379 database: 0 timeout: 5000 pool: max-active: 8 max-idle: 8 min-idle: 4 max-wait: 30000 sentinel: master: mymaster nodes: 10.10.10.127:26379,10.10.10.128:26379,10.10.10.129:26379 logging: level: root: warn 哨兵模式比单点模式仅是多了sentinel部分的配置。 RedisTemplate 配置： 123456789101112131415161718192021222324252627282930package org.fanlychie.config; import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer; @Configurationpublic class ApplicationConfig &#123; @Bean public RedisTemplate&lt;?, ?&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;?, ?&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); // 字符串序列化 RedisSerializer stringRedisSerializer = new StringRedisSerializer(); // 对象转为JSON串序列化 RedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(new ObjectMapper()); template.setKeySerializer(stringRedisSerializer); template.setValueSerializer(jsonRedisSerializer); template.setHashKeySerializer(stringRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); return template; &#125; &#125; @Configuration：效果等同于 Spring XML 配置方式。该注解用于 Java 编码形式配置。 启动类： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; 单元测试： 1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTest &#123; @Autowired private RedisTemplate redisTemplate; @Test public void doTest() &#123; if (redisTemplate.hasKey(\"infomsg\")) &#123; System.out.println(\"=====&gt; \" + redisTemplate.opsForValue().get(\"infomsg\")); &#125; else &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"fanlychie\"); map.put(\"mail\", \"fanlychie@yeah.net\"); redisTemplate.opsForValue().set(\"infomsg\", map); &#125; &#125; &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2018、Spring Boot-1.5.14.RELEASE完整示例项目链接：spring-boot-redis-sample、spring-boot-redis-sentinel-sample","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Cloud Eureka — 服务发现","date":"2017-06-21T13:57:47.000Z","path":"post/spring-cloud-netflix-eureka.html","text":"Spring Cloud 是一套基于 Spring Boot 实现的微服务开发工具。微服务（也称微服务架构），简单的说，就是将一个系统按照一定的规则有效的拆分成多个不同的服务，每个服务都能够独立的进行开发、部署、扩展和维护。服务与服务之间可以通过 RESTful API 等方式进行相互调用。 Spring Cloud 没有重复制造轮子，它只是将业界内多个开源的微服务框架集成起来，再通过 Spring Boot 进行包装屏蔽掉了复杂的配置和实现原理，目的是给开发者予一套简单易懂、易部署和易维护的分布式系统开发工具包。它提供了微服务开发所需的配置管理、服务发现、断路器、智能路由、微代理、控制总线等组件。 1. EurekaEureka 是一种基于 REST 的服务，主要用于定位服务，以实现中间层服务器的负载均衡和故障转移。它是由 Spring Cloud Netflix（Spring Cloud 的子项目） 项目提供的。 1.1 Spring Cloud Netflix它主要是对 Netflix 开源的一系列产品进行包装，为 Spring Boot 应用程序提供自动配置的 Netflix OSS 集成。通过一些简单的注解，就能快速启用并构建大型的分布式系统。它提供的模块有：服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）、客户端负载均衡（Ribbon）。 1.2 样例项目结构 1.3 服务注册中心在 pom.xml 中声明使用spring-cloud-starter-eureka-server启动器（本示例对应的项目是eureka-server）： pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 使用@EnableEurekaServer注解将应用声明为 Eureka 服务器端（Eureka Server），从而启动 Eureka 服务注册中心的组件，对外提供服务注册和发现的功能。 123456789@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 在默认的模式中，Eureka 服务器端也充当客户端并向给定的 serviceUrl 注册自己。在生产环境中，我们通常会有多台服务器端应用，但是为了简单起见，本示例使用单台服务器，因此需要禁掉 Eureka 服务器端应用的客户端行为： src/main/resources/application.yml12345678910server: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 配置项 默认值 简述 eureka.instance.hostname - 实例的主机名。 eureka.client.register-with-eureka true 该实例是否向 Eureka 服务器注册自己，以供外部应用发现自己。在某些情况下，你可能不希望当前的应用被外部的其他应用发现，而只是想从服务器发现其他服务的实例，此时你可以将此值设为 false。 eureka.client.fetch-registry true 该实例是否向 Eureka 服务器获取所有的注册信息表。 eureka.client.service-url.defaultZone - 该实例与 Eureka 服务器通讯的 URL 地址列表。如果 Eureka 服务器地址不止一个，则使用英文的逗号分隔。 Eureka 服务器默认监听 8761 端口来接收服务注册，除此之外它还提供一个可视化的直观页面，可以方便的查看注册的服务。启动EurekaServerApplication，访问：http://localhost:8761/ 从上图可以看到，此时还没有任何服务注册到 Eureka 服务器。 1.4 客户端（服务提供者）在 pom.xml 中声明使用spring-cloud-starter-eureka启动器（本示例对应的项目是order-service）： pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 使用@EnableEurekaClient或@EnableDiscoveryClient注解可以将应用声明为 Eureka 客户端（Eureka Client）。当客户端向 Eureka 服务器注册时，它会提供关于自身的一些元数据，例如主机和端口，健康指示符 URL，主页等信息。 123456789@SpringBootApplication@EnableEurekaClientpublic class OrderServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 除此之外，还需要配置才能找到 Eureka 服务器： src/main/resources/application.yml123456789server: port: 8881spring: application: name: order-serviceeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ spring.application.name是 Eureka 客户端向服务器注册的服务ID和虚拟主机的名称。在 Eureka 服务器中，服务ID相同的实例将集群在一起。启动OrderServiceApplication，再次访问：http://localhost:8761/ 从上图可以看到，客户端应用程序已经成功被注册了。 1.5 高可用以上示例都是单点运行的，不适合于生产环境。Eureka 官方给出的应用部署架构图是这样的： 下面对这个架构图来作一些解读，希望能帮助你更好的理解。 1．Region 和 Zone在 Eureka 中有 Region（区域）和 Zone（Availability Zone，可用区）的区分。这是由于 Netflix 开源的 Eureka 旨在 AWS（Amazon Web Services，现在通常称为云计算）中运行，因此使用了一些 AWS 特有的概念术语。在非 AWS 的环境下，我们可以简单的将 Region 理解成大区或地域（如阿里云服务器的华南、华北地区），Zone 可以简单的理解成机房。如需了解更多相关信息，可参考：AWS的区域和可用区概念解释。上图是一个 Eureka 集群的部署架构图，它面有 3 个 Zone（us-east-1c、us-east-1d、us-east-1e），它们都属于 us-east-1 这个 Region。 2．Eureka Server 每个 Zone 至少有一个 Eureka Server，能够对外提供服务发现和处理区域故障。在 Eureka Server 集群中（eureka.client.register-with-eureka不能设置为 false），没有 Master/Slave 的区分，每个 Eureka Server 都是对等（Peer）的。它们除了可以作为服务注册中心外还可以充当客户端向其他 Eureka Server 注册自己，并且会从它的对等的节点（由eureka.client.service-url.defaultZone配置指定）中 Replicate（复制）所有的服务注册表信息以达到同步的目的，如果因为某种原因导致同步失败，默认等待 5 分钟（可以通过eureka.server.wait-time-in-ms-when-sync-empt配置），在这期间，它不向客户端提供服务注册信息。并且默认失败重试 5 次（可以通过eureka.server.number-of-replication-retries配置）。 3．Eureka Client Eureka 客户端应用分两种，Applicaton Service（服务提供者）和 Application Client（服务消费者）。Applicaton Service（服务提供者）通常需要向给定的 serviceUrl 对应的 Eureka Server 来 Register（注册）自己，以供外部应用可以发现自己。其注册信息包含主机名和端口信息等元数据。然后默认以每隔 30 秒的频率向注册的 Eureka Server 发送一次心跳（可以通过eureka.instance.lease-renewal-interval-in-seconds配置）来 Renew（续约）服务。Eureka Server 默认为 90 秒内如果没有收到客户端的心跳，则它会将该客户端实例从它的注册表中剔除，以禁止该实例的流量（可以通过eureka.instance.lease-expiration-duration-in-seconds配置。注意，如果该值设置的太大，即使实例已经不存在了，流量也可以路由到该实例；如果设置的太小，很可能因为网络问题导致实例被服务器剔除；该值至少应该比发送心跳频率的间隔值要大）。Eureka 客户端默认会从注册的 Eureka Server 中获取所有的服务注册表信息（可以通过eureka.client.fetch-registry配置），默认是以每隔 30 秒的频率去 Get Registry（获取注册表） 一次（可以通过eureka.client.registry-fetch-interval-seconds配置）。Application Client（服务消费者）可以不向任何 Eureka Server 注册自己，它可以只从 Eureka Server 获取注册过的服务列表，通过 RESTful API 的方式远程调用 Applicaton Service（服务提供者）。 1.5.1 Eureka Server 高可用样例本示例是在同一主机运行多个 Eureka Server 实例，由于 Eureka 会过滤同一主机的相同主机名（详见com.netflix.eureka.cluster.PeerEurekaNodes#isThisMyUrl），但是它不检查端口，因此需要先行定义至少两个不同的主机名，并使它们映射到127.0.0.1。这里采用修改 hosts 文件的方式。Windows 操作系统的 hosts 文件路径是C:\\Windows\\System32\\drivers\\etc\\hosts。找到并打开系统的 hosts 文件，在最后添加如下行： hosts1127.0.0.1 peer1 peer2 peer3 修改eureka-server项目的配置文件： src/main/resources/application.yml123456789101112131415161718192021222324252627282930313233343536373839404142spring: application: name: eureka-server profiles: active: peer1logging: level: com.netflix.eureka: 'off' com.netflix.discovery: 'off'---spring: profiles: peer1server: port: 8761eureka: instance: hostname: peer1 client: service-url: defaultZone: http://peer2:8762/eureka/,http://peer3:8763/eureka/---spring: profiles: peer2server: port: 8762eureka: instance: hostname: peer2 client: service-url: defaultZone: http://peer1:8761/eureka/,http://peer3:8763/eureka/---spring: profiles: peer3server: port: 8763eureka: instance: hostname: peer3 client: service-url: defaultZone: http://peer1:8761/eureka/,http://peer2:8762/eureka/ 这里配置了 3 个 Eureka Server 实例，每个实例与其他两个实例分别进行两两的相互注册，关系如图示： 需要注意的是，Eureka Server 的服务注册信息不能进行二次传播。如下图的实例关系配置是不可取的： 此图的每个 Eureka Server 实例是单向的向另外一个实例注册，假如现有一个新的客户端实例 C 向 1 注册，那么，1 和 2 中都会有 C 的注册信息，但是 3 中是没有 C 的注册信息的（详见com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#replicateToPeers）。 启动 3 个 Eureka Server 实例： cmd123456# 启动 peer1 实例&gt; java -jar eureka-server-0.0.1-SNAPSHOT.jar# 启动 peer2 实例&gt; java -jar -Dspring.profiles.active=peer2 eureka-server-0.0.1-SNAPSHOT.jar# 启动 peer3 实例&gt; java -jar -Dspring.profiles.active=peer3 eureka-server-0.0.1-SNAPSHOT.jar 1.5.2 Eureka Client 高可用样例修改order-service项目的配置文件： src/main/resources/application.yml12345678910111213141516171819spring: application: name: order-service profiles: active: client1eureka: client: service-url: defaultZone: http://peer1:8761/eureka/---spring: profiles: client1server: port: 8881---spring: profiles: client2server: port: 8882 客户端的eureka.client.service-url.defaultZone指定为当前 Zone 中任意一台服务注册中心的地址就可以，因为上例中配置的每台服务注册中心的服务注册表是两两相互进行复制的。 启动 2 个 Eureka Client 实例： cmd1234# 启动 client1 实例&gt; java -jar order-service-0.0.1-SNAPSHOT.jar# 启动 client2 实例&gt; java -jar -Dspring.profiles.active=client2 order-service-0.0.1-SNAPSHOT.jar 重新刷新http://localhost:8761/： 1.6 自我保护模式Eureka 默认开启了自我保护模式（可以通过eureka.server.enable-self-preservation配置）。该模式被激活的条件是：在 1 分钟后，Renews (last min)&lt;Renews threshold。你可以在 Eureka Server 首页的右上侧可以看到： 参数 简述 Renews threshold Eureka Server 期望每分钟收到客户端实例续约的总数 Renews (last min) Eureka Server 最后 1 分钟收到客户端实例续约的总数 1．服务器端续约阀值的计算源码（Renews threshold） com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#openForTraffic12this.expectedNumberOfRenewsPerMin = count * 2;this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold()); 其中，count 为 服务器的数量。数值 2 表示每 30 秒 1 个心跳，每分钟 2 个心跳的固定频率因子。 归纳公式：2M * renewalPercentThreshold。其中，M 为服务器的个数，计算结果只保留整数位。 renewalPercentThreshold 默认是 0.85（可以通过eureka.server.renewal-percent-threshold配置）。 其实这就是个固定值，因为对于每个 Eureka Server 来说，M 只能取 1。这段代码达到的效果是： 1．expectedNumberOfRenewsPerMin 重置为固定值 2；2．numberOfRenewsPerMinThreshold 的值被设置为 1； 2．客户端续约阀值的计算源码（Renews threshold） com.netflix.eureka.registry.AbstractInstanceRegistry#register1234if (this.expectedNumberOfRenewsPerMin &gt; 0) &#123; this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2; this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());&#125; 注：上面贴出的 PeerAwareInstanceRegistryImpl 继承自 AbstractInstanceRegistry。它们共享 expectedNumberOfRenewsPerMin 和 numberOfRenewsPerMinThreshold 属性，具体可自行翻阅源码。 设有 N 个客户端，服务器端先启动，expectedNumberOfRenewsPerMin 被重置为固定值 2。接着客户端依次启动： N = 1–&gt;(2 + 2) * renewalPercentThresholdN = 2–&gt;(2 + 2 + 2) * renewalPercentThresholdN = 3–&gt;(2 + 2 + 2 + 2) * renewalPercentThreshold 归纳公式：2(N + 1) * renewalPercentThreshold，计算结果只保留整数位。 即，如果只有 1 个 Eureka Server 或者有多个 Eureka Server 但它们之间没有相互注册： 当 N = 0 时，只计算服务器端。Renews threshold= 1。由于没有客户端向服务器发送心跳，Renews (last min)&lt;Renews threshold，Eureka 自我保护模式被激活； 当 N ≠ 0 时，服务器端的计算结果被客户端覆盖，即只计算客户端； 当 N = 2 时，Renews threshold= 2(N + 1) * renewalPercentThreshold = 2 * 3 * 0.85 = 5。2 个客户端以每 30 秒发送 1 个心跳，1 分钟后总共向服务器发送 4 个心跳，Renews (last min)&lt;Renews threshold，Eureka 自我保护模式被激活； 所以如果 N &lt; 3，在 1 分钟后，服务器端收到的客户端实例续约的总数总是小于期望的阀值，因此 Eureka 的自我保护模式自动被激活。首页会出现警告信息： EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 这种情况下，由于 Eureka Server 没有对等的节点，同步不到服务注册信息，默认需等待 5 分钟（可以通过eureka.server.wait-time-in-ms-when-sync-empty配置）。即 5 分钟后你应该看到此信息。 为避免这种情况发生，你可以： 关闭自我保护模式（eureka.server.enable-self-preservation设为 false） 降低 renewalPercentThreshold 的比例（eureka.server.renewal-percent-threshold设置为 0.5 以下，比如 0.49） 部署多个 Eureka Server 并开启其客户端行为（eureka.client.register-with-eureka不要设为 false，默认为 true） 如果是采取部署多个 Eureka Server 并开启其客户端行为使其相互注册。假设有 M 个 Eureka Server，那么，每个 Eureka Server 每分钟可以额外收到 2 * (M - 1) 个心跳。例如： 当 M = 1，N = 2 时，Renews threshold= 2(N + 1) * renewalPercentThreshold = 2 * 3 * 0.85 = 5，2 个客户端以每 30 秒发送 1 个心跳，1 分钟后总共向服务器发送 4 个心跳，Renews (last min)&lt;Renews threshold； 当 M = 2，N = 2 时，Renews threshold= 2(N + 1) * renewalPercentThreshold = 2 * 3 * 0.85 = 5，2 个客户端以每 30 秒发送 1 个心跳，1 分钟后总共向服务器发送 4 个心跳，另外还有 1 个 M 发来的 2 个心跳，总共是 6 个心跳，Renews (last min)&gt;Renews threshold； Eureka 的自我保护模式是有意义的，该模式被激活后，它不会从注册列表中剔除因长时间没收到心跳导致租期过期的服务，而是等待修复，直到心跳恢复正常之后，它自动退出自我保护模式。这种模式旨在避免因网络分区故障导致服务不可用的问题。例如，两个客户端实例 C1 和 C2 的连通性是良好的，但是由于网络故障，C2 未能及时向 Eureka 发送心跳续约，这时候 Eureka 不能简单的将 C2 从注册表中剔除。因为如果剔除了，C1 就无法从 Eureka 服务器中获取 C2 注册的服务，但是这时候 C2 服务是可用的。所以，Eureka 的自我保护模式最好还是开启它。 1.7 Eureka 与 Zookeeper 的区别Eureka 最大程度上保证 AP（Availability，可用性；Partition-tolerance，分区容错性），而 Zookeeper 保证的是 CP（Consistency，一致性；Partition-tolerance，分区容错性）。如果因为网络分区故障导致服务器（master 节点）无法与其它节点联系，对于 Zookeeper 来说，这是不能容忍的。它会对剩下的节点重新进行 leader 选举，在这期间，整个 Zookeeper 集群是不可用的，这就直接导致了所有注册服务瘫痪的现象。而对于 Eureka 来说，每个节点都是对等的，失去了一个节点，就自动切换到其它节点，只要还有一个 Eureka 节点存在，就能正常对外提供注册服务。Eureka 可以很好的应对因网络分区故障而导致的部分节点失去联系的状况。 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Cloud-Dalston.SR1完整示例项目链接：spring-cloud-netflix-eureka-sample参考文档文献链接：http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_spring_cloud_netflix","tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://yoursite.com/tags/Spring-Cloud/"}]},{"title":"Spring Boot MyBatis","date":"2017-06-21T13:04:47.000Z","path":"post/spring-boot-mybatis.html","text":"依赖声明： # pom.xml12345678910111213141516171819202122&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.14.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; mybatis-spring-boot-starter：MyBatis 启动器。 数据库表： 123456CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID', `name` varchar(16) NOT NULL COMMENT '姓名', `age` int(11) NOT NULL COMMENT '性别', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; MySQL 数据库脚本 实体类： 12345678910111213141516171819202122package org.fanlychie.entity; public class Employee &#123; private Long id; private String name; private Integer age; // ignore getters and setters ... @Override public String toString() &#123; return \"Employee&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; &#125; Mapper 配置文件： # src/main/resources/mapper/EmployeeMapper.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"org.fanlychie.mapper.EmployeeMapper\"&gt; &lt;insert id=\"save\" useGeneratedKeys=\"true\" keyProperty=\"id\" parameterType=\"Employee\"&gt; INSERT INTO EMPLOYEE ( ID, NAME, AGE ) VALUES ( #&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125; ) &lt;/insert&gt; &lt;select id=\"selectAll\" resultMap=\"EmployeeResultMap\"&gt; SELECT * FROM EMPLOYEE &lt;/select&gt; &lt;resultMap id=\"EmployeeResultMap\" type=\"Employee\"&gt; &lt;id property=\"id\" column=\"ID\" /&gt; &lt;result property=\"name\" column=\"NAME\" /&gt; &lt;result property=\"age\" column=\"AGE\" /&gt; &lt;/resultMap&gt; &lt;/mapper&gt; Mapper 接口： 123456789package org.fanlychie.mapper; public interface EmployeeMapper &#123; Long save(Employee employee); List&lt;Employee&gt; selectAll(); &#125; 只需声明接口，不需要编写额外的实现类。 Spring Boot 配置文件： # src/main/resources/application.yml1234567891011121314151617spring: datasource: url: jdbc:mysql://127.0.0.1/test username: root password: root driver-class-name: com.mysql.jdbc.Driver tomcat: default-auto-commit: true mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: org.fanlychie.entity logging: level: root: WARN org.fanlychie.mapper: DEBUG mapper-locations：用来指定 MyBatis 的 Mapper 配置文件的位置。 type-aliases-package：指定类型别名的包。多个用逗号（,）或分号（;）分隔。指定的包下所有的类型在 Mapper 配置文件中可以使用类的简单类名（如：org.fanlychie.entity.Employee 可以简写为 Employee）。 启动类： 123456789@SpringBootApplication@MapperScan(\"org.fanlychie.mapper\")public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; MyBatis 启动器默认会搜索所有 @Mapper 的注解。这意味着你所有的 Mapper 接口都需要标注 @Mapper 注解。显然这样不够方便。@MapperScan 注解可以用来指定要扫描的 Mapper 接口的包路径。 单元测试： 12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTest &#123; @Autowired private EmployeeMapper employeeMapper; @Test public void testSave() &#123; Employee employee = new Employee(); employee.setName(\"fanlychie\"); employee.setAge(23); employeeMapper.save(employee); &#125; @Test public void testSelectAll() &#123; List&lt;Employee&gt; employees = employeeMapper.selectAll(); employees.forEach(System.out::println); &#125; &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2018、Spring Boot-1.5.14.RELEASE完整示例项目链接：spring-boot-mybatis-sample参考文档文献链接：mybatis-spring-boot-autoconfigure","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Test","date":"2017-06-20T06:51:38.000Z","path":"post/spring-boot-testing.html","text":"Spring 框架提供了一个专门的测试模块（spring-test），用于应用程序的集成测试。 在 Spring Boot 中，你可以通过spring-boot-starter-test启动器快速开启和使用它。 # pom.xml12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 1. Junit 测试当你的单元测试代码不需要用到 Spring Boot 功能，而只是一个简单的测试时，你可以直接编写你的 Junit 测试代码： 12345678public class SimpleJunitTest &#123; @Test public void testSayHi() &#123; System.out.println(\"Hi Junit.\"); &#125; &#125; 2. Spring Boot 测试当你的集成测试代码需要用到 Spring Boot 功能时，你可以使用@SpringBootTest注解。该注解是普通的 Spring 项目（非 Spring Boot 项目）中编写集成测试代码所使用的@ContextConfiguration注解的替代品。其作用是用于确定如何装载 Spring 应用程序的上下文资源。 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class BeanInjectTest &#123; @Autowired private HelloService helloService; @Test public void testSayHi() &#123; System.out.println(helloService.sayHi()); &#125; &#125; 123456789101112@Servicepublic class HelloService &#123; public String sayHi() &#123; return \"--- Hi ---\"; &#125; public String sayHello() &#123; return \"--- Hello ---\"; &#125; &#125; 当运行 Spring Boot 应用程序测试时，它会自动的从当前测试类所在的包起一层一层向上搜索，直到找到一个@SpringBootApplication或@SpringBootConfiguration注释类为止。以此来确定如何装载 Spring 应用程序的上下文资源。只要你以合理的方式组织你的代码，你项目的主配置通常是可以被发现的。本示例项目的部分文件结构图为： 123456789101112131415spring-boot-testing-sample\\__ src \\__ main : \\__ java : \\__ org : \\__ fanlychie : |__ Application.java : \\__ service : |__ HelloService.java \\__ test \\__ java \\__ org \\__ fanlychie \\__ test |__ BeanInjectTest.java 其中，主配置启动类的代码为： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 如果搜索算法搜索不到你项目的主配置文件，将报出异常： java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=…) with your test 解决办法是，按 Spring Boot 的约定重新组织你的代码结构，或者手工指定你要装载的主配置文件： 1234567@RunWith(SpringRunner.class)@SpringBootTest(classes = &#123;YourApplication.class&#125;)public class BeanInjectTest &#123; // ... &#125; 基于 Spring 环境的 Junit 集成测试还需要使用@RunWith(SpringJUnit4ClassRunner.class)注解，该注解能够改变 Junit 并让其运行在 Spring 的测试环境，以得到 Spring 测试环境的上下文支持。否则，在 Junit 测试中，Bean 的自动装配等注解将不起作用。但由于 SpringJUnit4ClassRunner 不方便记忆，Spring 4.3 起提供了一个等同于 SpringJUnit4ClassRunner 的类 SpringRunner，因此可以简写成：@RunWith(SpringRunner.class)。 3. Spring MVC 测试当你想对 Spring MVC 控制器编写单元测试代码时，可以使用@WebMvcTest注解。它提供了自配置的 MockMvc，可以不需要完整启动 HTTP 服务器就可以快速测试 MVC 控制器。 12345678910111213141516171819import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @RunWith(SpringRunner.class)@WebMvcTest(HelloController.class)public class HelloControllerTest &#123; @Autowired private MockMvc mvc; @Test public void testHello() throws Exception &#123; mvc.perform(get(\"/hello\")) .andExpect(status().isOk()) .andDo(print()); &#125; &#125; 12345678910@Controllerpublic class HelloController &#123; @GetMapping(\"/hello\") public String hello(ModelMap model) &#123; model.put(\"message\", \"Hello Page\"); return \"hello\"; &#125; &#125; 使用@WebMvcTest注解时，只有一部分的 Bean 能够被扫描得到，它们分别是： @Controller @ControllerAdvice @JsonComponent Filter WebMvcConfigurer HandlerMethodArgumentResolver 其他常规的@Component（包括@Service、@Repository等）Bean 则不会被加载到 Spring 测试环境上下文中。 如果测试的 MVC 控制器中需要@ComponentBean 的参与，你可以使用@MockBean注解来协助完成： 12345678910111213141516171819202122232425import static org.mockito.BDDMockito.*;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @RunWith(SpringRunner.class)@WebMvcTest(HelloController.class)public class HelloControllerTest &#123; @Autowired private MockMvc mvc; @MockBean private HelloService helloService; @Test public void testSayHi() throws Exception &#123; // 模拟 HelloService.sayHi() 调用, 返回 \"=== Hi ===\" when(helloService.sayHi()).thenReturn(\"=== Hi ===\"); mvc.perform(get(\"/hello/sayHi\")) .andExpect(status().isOk()) .andDo(print()); &#125; &#125; 12345678910111213@Controllerpublic class HelloController &#123; @Autowired private HelloService helloService; @GetMapping(\"/hello/sayHi\") public String sayHi(ModelMap model) &#123; model.put(\"message\", helloService.sayHi()); return \"hello\"; &#125; &#125; 4. Spring Boot Web 测试当你想启动一个完整的 HTTP 服务器对 Spring Boot 的 Web 应用编写测试代码时，可以使用@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)注解开启一个随机的可用端口。Spring Boot 针对 REST 调用的测试提供了一个 TestRestTemplate 模板，它可以解析链接服务器的相对地址。 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class ApplicationTest &#123; @Autowired private TestRestTemplate restTemplate; @Test public void testSayHello() &#123; Map&lt;String, Object&gt; result = restTemplate.getForObject(\"/hello/sayHello\", Map.class); System.out.println(result.get(\"message\")); &#125; &#125; 1234567891011121314@Controllerpublic class HelloController &#123; @Autowired private HelloService helloService; @GetMapping(\"/hello/sayHello\") public @ResponseBody Object helloInfo() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"message\", helloService.sayHello()); return map; &#125; &#125; 5. Spring Data JPA 测试当你想对 Spring Data JPA 应用进行单元测试时，你可以使用@DataJpaTest注解。并且在进行 JPA 测试时，你可以选择使用内存数据库还是真实的数据库测试。 5.1 内存数据库测试默认情况下，@DataJpaTest使用的是内存数据库进行测试，你无需配置和启用真实的数据库。只需要在 pom.xml 配置文件中声明如下依赖即可： # pom.xml1234&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;/dependency&gt; @DataJpaTest注解它只扫描@EntityBean 和装配 Spring Data JPA 存储库，其他常规的@Component（包括@Service、@Repository等）Bean 则不会被加载到 Spring 测试环境上下文。 123456789101112131415161718@RunWith(SpringRunner.class)@DataJpaTestpublic class UserRepositoryInMemoryTest &#123; @Autowired private UserRepository userRepository; @Test public void testSave() &#123; User user = new User(); user.setName(\"fanlychie\"); userRepository.save(user); System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; 12345678910111213@Entity(name = \"User\")public class User &#123; @Id @GeneratedValue(generator = \"uuidGenerator\") @GenericGenerator(name = \"uuidGenerator\", strategy = \"uuid\") private String id; private String name; // getters and setters &#125; 123public interface UserRepository extends JpaRepository&lt;User, String&gt; &#123; &#125; 5.2 真实数据库测试如果你希望使用真实的数据库做测试，你可以使用@AutoConfigureTestDatabase(replace = Replace.NONE)注解： 12345678910111213141516171819@RunWith(SpringRunner.class)@DataJpaTest@AutoConfigureTestDatabase(replace = Replace.NONE)public class UserRepositoryMySQLTest &#123; @Autowired private UserRepository userRepository; @Test public void testSave() &#123; User user = new User(); user.setName(\"fanlychie\"); userRepository.save(user); System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; replace = Replace.NONE的作用是告知 Spring Boot 不要替换应用程序默认的数据源。 # src/main.resources/application.yml1234567891011spring: datasource: url: jdbc:mysql://127.0.0.1/test username: root password: root driver-class-name: com.mysql.jdbc.Driver tomcat: default-auto-commit: true jpa: hibernate: ddl-auto: update 5.3 事务控制默认情况下，在每个 JPA 测试结束时，事务会发生回滚。这在一定程度上可以防止测试数据污染数据库。如果你不希望事务发生回滚，你可以使用@Rollback(false)注解，该注解可以标注在类级别做全局的控制，也可以标注在某个特定不需要执行事务回滚的方法级别上。 1234567891011121314151617181920@RunWith(SpringRunner.class)@DataJpaTest@AutoConfigureTestDatabase(replace = Replace.NONE)public class UserRepositoryMySQLTest &#123; @Autowired private UserRepository userRepository; @Test @Rollback(false) public void testSave() &#123; User user = new User(); user.setName(\"fanlychie\"); userRepository.save(user); System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; 另外，你也可以使用@Transactional注解对事务进行控制。该注解可以标注在类级别做全局的控制，也可以标注在某个特定的方法级别上。如： 1234567891011121314151617@RunWith(SpringRunner.class)@DataJpaTest@AutoConfigureTestDatabase(replace = Replace.NONE)public class UserRepositoryMySQLTest &#123; @Autowired private UserRepository userRepository; @Test @Transactional(readOnly = true) public void testSelect() &#123; System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; 6. 关闭 DEBUG 日志和输出 SQL 信息在 Spring Boot 环境中执行 Junit 单元测试的时候，会有很多DEBUG和INFO级别的日志信息输出。我们对这些信息其实并不是很感兴趣，而是更关心自己编写的测试代码部分输出的信息以及 SQL 语句信息。正确关闭这些日志信息的姿势是，在测试目录的资源文件夹中创建一个logback-test.xml文件： # src/test/resources/logback-test.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\" /&gt; &lt;!-- 日志级别设置为 ERROR --&gt; &lt;root level=\"ERROR\" /&gt; &lt;!-- 输出 SQL 语句信息 --&gt; &lt;logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/&gt; &lt;!-- 输出 SQL 语句参数信息 --&gt; &lt;logger name=\"org.hibernate.type.descriptor.sql.BasicBinder\" level=\"TRACE\"/&gt;&lt;/configuration&gt; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-testing-sample参考文档文献链接：http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-features-testing","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 使用 Servlet、Filter、Listener","date":"2017-06-19T14:30:08.000Z","path":"post/spring-boot-servlet-filter-listener-usage.html","text":"在普通的 WEB 应用中，Servlet、Filter、Listener 都是在 web.xml 配置文件中配置的。而在 Spring Boot 中，由于它省去 web.xml 配置文件，Servlet、Filter、Listener 的配置需要通过 Java 代码的方式来进行配置。 1. 通过 Bean 的方式配置Spring Boot 提供了 ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean 三种类型来分别配置应用的 Servlet、Filter、Listener。 # 在 Spring Boot 应用中配置使用 Servlet、Filter、Listener123456789101112131415161718192021222324@Configurationpublic class ApplicationConfigurer &#123; @Bean public FilterRegistrationBean registerCustomFilter() &#123; FilterRegistrationBean filterRegBean = new FilterRegistrationBean(new CustomFilter()); filterRegBean.setUrlPatterns(Arrays.asList(\"/*\")); return filterRegBean; &#125; @Bean public ServletRegistrationBean registerCustomServlet() &#123; ServletRegistrationBean servletRegBean = new ServletRegistrationBean(new CustomServlet()); servletRegBean.setUrlMappings(Arrays.asList(\"/customServlet\")); servletRegBean.setLoadOnStartup(1); return servletRegBean; &#125; @Bean public ServletListenerRegistrationBean&lt;?&gt; registerCustomListener() &#123; return new ServletListenerRegistrationBean&lt;&gt;(new CustomListener()); &#125; &#125; # 自定义的 Filter12345678910111213141516171819public class CustomFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"------ CustomFilter ------\"); chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125; &#125; # 自定义的 Listener12345678910111213public class CustomListener implements ServletRequestListener &#123; @Override public void requestInitialized(ServletRequestEvent event) &#123; System.out.println(\"------ CustomListener ------\"); &#125; @Override public void requestDestroyed(ServletRequestEvent event) &#123; &#125; &#125; # 自定义的 Servlet12345678public class CustomServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"------ CustomServlet ------\"); &#125; &#125; 2. 通过注解的方式配置Spring Boot 提供了 @WebServlet、@WebFilter、@WebListener 三种类型的注解来分别配置应用的 Servlet、Filter、Listener。 # Filter 注解1234567891011121314151617181920@WebFilter(urlPatterns = \"/*\")public class CustomFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"------ CustomFilter Annotation ------\"); chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125; &#125; # Listener 注解1234567891011121314@WebListenerpublic class CustomListener implements ServletRequestListener &#123; @Override public void requestInitialized(ServletRequestEvent event) &#123; System.out.println(\"------ CustomListener Annotation ------\"); &#125; @Override public void requestDestroyed(ServletRequestEvent event) &#123; &#125; &#125; # Servlet 注解123456789@WebServlet(urlPatterns = \"/customServlet\", loadOnStartup = 1)public class CustomServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"------ CustomServlet Annotation ------\"); &#125; &#125; 最后，需要在应用中使用@ServletComponentScan注解配置才有效。 123456789@SpringBootApplication@ServletComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：conf-sample scan-sample参考文档文献链接：http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-features-embedded-container","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 异常处理","date":"2017-06-18T08:18:54.000Z","path":"post/spring-boot-exception-handler.html","text":"Spring Boot 默认提供了程序出错的结果映射路径/error（见：Spring Boot 错误页面）。其内部是通过判断请求头中的Accept的内容是否为text/html来区分请求是来自客户端浏览器（浏览器通常默认自动发送请求头内容Accept:text/html）还是客户端接口的调用，以此来决定返回页面视图还是 JSON 消息内容。 1. 自定义异常处理使用@ControllerAdvice注解可以对已知的Controller中抛出的异常进行捕获并处理。 12345678910111213141516171819202122232425@ControllerAdvicepublic class GlobalExceptionHandler &#123; private Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(BusinessHtmlException.class) public ModelAndView handleHtmlException(Exception e) &#123; logger.error(\"「捕捉到异常」：\", e); ModelAndView modelAndView = new ModelAndView(\"error/general\"); modelAndView.addObject(\"message\", e.getMessage()); return modelAndView; &#125; @ExceptionHandler(&#123; BusinessJsonException.class, IllegalArgumentJsonException.class &#125;) public ResponseEntity&lt;?&gt; handleJsonException(Exception e) &#123; logger.error(\"「捕捉到异常」：\", e); HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR; return new ResponseEntity&lt;&gt;(new HttpResponseBody(status.value(), e.getMessage(), null), status); &#125; &#125; 1.1 @ExceptionHandler该注解用于标注处理方法处理哪些特定的异常。被该注解标注的方法可以有以下任意顺序的参数类型： Throwable、Exception 等异常对象； ServletRequest、HttpServletRequest、ServletResponse、HttpServletResponse； HttpSession 等会话对象； org.springframework.web.context.request.WebRequest； java.util.Locale； java.io.InputStream、java.io.Reader； java.io.OutputStream、java.io.Writer； org.springframework.ui.Model； 并且被该注解标注的方法可以有以下的返回值类型可选： ModelAndView； org.springframework.ui.Model； java.util.Map； org.springframework.web.servlet.View； @ResponseBody 注解标注的任意对象； HttpEntity&lt;?&gt; or ResponseEntity&lt;?&gt;； void； 以上罗列的不完全，更加详细的信息可参考：Spring ExceptionHandler。 1.2 @ResponseStatus@ExceptionHandler 注释可以与 @ResponseStatus 结合起来，以定义 HTTP 响应的状态码值。 以下为涉及本示例的其余代码： 1234567891011121314151617public class HttpResponseBody &#123; private int code; private String errmsg; private Object data; public HttpResponseBody(int code, String errmsg, Object data) &#123; this.code = code; this.data = data; this.errmsg = errmsg; &#125; // getters and setters &#125; 1234567public class BusinessHtmlException extends RuntimeException &#123; public BusinessHtmlException(String message) &#123; super(message); &#125; &#125; 1234567public class BusinessJsonException extends RuntimeException &#123; public BusinessJsonException(String message) &#123; super(message); &#125; &#125; 1234567public class IllegalArgumentJsonException extends RuntimeException &#123; public IllegalArgumentJsonException(String message) &#123; super(message); &#125; &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-exception-handler-sample参考文档文献链接：http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-features-error-handling","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 错误页面","date":"2017-06-17T03:26:48.000Z","path":"post/spring-boot-error-page.html","text":"1. 默认的错误页面Spring Boot 默认提供了程序出错的结果映射路径/error：spring-boot-autoconfigure.jar/org.springframework.boot.autoconfigure.web.BasicErrorController.java 其中，errorHtml方法是用于处理浏览器端的请求，它返回一个简单的错误页面。而error方法是用于处理客户端的调用，它返回一个简单的 JSON 字串信息。 当请求发生错误，它会响应浏览器一个简单的页面来描述这些错误信息，如 404 错误页面： 2. 自定义错误页面Spring Boot 默认是到模板文件所在目录的error文件夹中查找错误码对应的视图模板文件：spring-boot-autoconfigure-1.5.2.RELEASE.jar/org.springframework.boot.autoconfigure.web.DefaultErrorViewResolver.java 因此，自定义的错误模板文件放在 error 目录下即可。如： # src/main/resources/templates/error/404.html（Thymeleaf）123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;404错误页面&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;p th:text=\"|timestamp：$&#123;#dates.format(timestamp, 'yyyy-MM-dd HH:mm:ss:SSS')&#125;|\"&gt;&lt;/p&gt;&lt;p th:text=\"|status：$&#123;status&#125;|\"&gt;&lt;/p&gt;&lt;p th:text=\"|error：$&#123;error&#125;|\"&gt;&lt;/p&gt;&lt;p th:text=\"|message：$&#123;message&#125;|\"&gt;&lt;/p&gt;&lt;p th:text=\"|path：$&#123;path&#125;|\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 最终的效果： 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-error-page-sample参考文档文献链接：http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-features-error-handling-custom-error-pages","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Cron 表达式","date":"2017-06-13T13:04:47.000Z","path":"post/cron-expression.html","text":"语法：秒 分 时 日 月 周 [年] 年是非必填字段，可留空。 字段允许的值范围允许的通配符秒0-59,-*/分0-59,-*/时0-23,-*/日1-31,-*/?LCW月1-12,-*/周1-7（1为周日，7为周六，2为周一）,-*/?LC#年1970-2099,-*/ *：表示任意时刻的值。可用于表示每秒、每分、每时、每日、每月、每周、每年。 -：表示一个范围的值。例如在秒字段中使用5-10，则表示从每分钟的第5秒开始至10秒结束，期间每秒触发一次。 ,：表示列举出来的值。例如在秒字段中使用5,10，则表示在每分钟的第5秒和第10秒分别触发一次。 /：表示起始时间触发一次，然后每隔固定时间触发一次。例如在秒字段中使用5/10，则表示从每分钟的第5秒触发一次，然后第15、25、35、45、55秒分别触发一次。 ?：表示不关心，不管是什么。只能用在“日”和“周”字段中。例如在每月的第一天凌晨两点触发（0 0 2 1 * ?）。“?”表示不管这天是周几。 L：表示最后的。只能用在“日”和“周”字段中。例如在周字段中使用6L，则表示在每个月的最后一个周五触发。","tags":[{"name":"表达式","slug":"表达式","permalink":"http://yoursite.com/tags/表达式/"}]},{"title":"Spring Boot Tomcat 上下文路径","date":"2017-05-12T16:17:40.000Z","path":"post/spring-boot-tomcat-context-path.html","text":"Spring Boot 内置 Tomcat 上下文路径默认是/。修改上下文路径的方式有： 1. application.ymlsrc/main/resources/application.yml12server: contextPath: /my-app 2. application.propertiessrc/main/resources/application.properties1server.contextPath=/my-app 3. 命令行terminal1$ java -Dserver.contextPath=/my-app -jar xxxx.jar","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Tomcat 端口","date":"2017-05-12T16:16:30.000Z","path":"post/spring-boot-tomcat-port.html","text":"Spring Boot 内置 Tomcat 端口默认是8080。修改端口的方式有： 1．application.ymlsrc/main/resources/application.yml12server: port: 8888 2．application.propertiessrc/main/resources/application.properties1server.port=8888 3．命令行terminal1$ java -Dserver.port=8888 -jar xxxx.jar","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Banner","date":"2017-05-12T16:16:13.000Z","path":"post/spring-boot-logo-banner.html","text":"Spring Boot 启动时的 Logo Banner： 1234567 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _`| \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE) 1. 更换 Banner在src/main/resources目录下创建banner.txt文件： src/main/resources/banner.txt123456789101112131415161718192021 _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ . ' \\\\| |//`. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__`-`___/-. / ___`. .' /--.--\\`. . __ .\"\" '&lt;`.___\\_&lt;|&gt;_/___.' &gt;'\"\". | | :`- \\`.;`\\ _ /`;.`/ -`: | | \\ \\`-. \\_ __\\ /__ _/ .-`/ /======`-.____`-.___\\_____/___.-`____.-'====== `=---='............................................. 佛祖镇楼 BUG辟易 2. 禁用 Bannersrc/main/resources/application.yml123spring: main: banner-mode: 'off' 或 src/main/resources/application.properties1spring.main.banner-mode='off' 或 terminal1$ java -Dspring.main.banner-mode=off -jar xxxx.jar","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"JPQL 语言语法","date":"2017-05-06T06:42:27.000Z","path":"post/jpql-usage.html","text":"JPQL（Java Persistence Query Language，Java 持久化查询语言）和 SQL 之间有很多相似之处，它们之间主要的区别在于前者处理 JPA 实体类，而后者则直接涉及关系数据。在 JPQL 中，可以使用SELECT、UPDATE和DELETE语法来定义查询。 1. 查询语法：SELECT ... FROM ... [WHERE ...] [GROUP BY ... [HAVING ...]] [ORDER BY ...] FROM 子句 通过声明一个或多个标识符变量来定义查询的范围。在SELECT和WHERE子句中可以引用这些变量。 WHERE 子句 用于限制查询到的对象或值的条件表达式。 GROUP BY 子句 根据一组属性对查询结果进行分组。 HAVING 子句 配合GROUP BY子句使用，以根据条件表达式进一步限制查询结果。 ORDER BY 子句 对查询结果进行排序。 # 部门实体12345678910111213141516@Entity(name = \"Department\")public class Department &#123; @Id @GeneratedValue private Long id; private String name; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = \"department_id\") private Set&lt;Employee&gt; employees; // getters and setters &#125; # 雇员实体1234567891011121314151617181920212223242526@Entity(name = \"Employee\")public class Employee &#123; @Id @GeneratedValue private Long id; private String name; @Enumerated(EnumType.STRING) private Sex sex; private Integer age; private Boolean married; private Double salary; private Date hireDate; @ManyToOne(fetch = FetchType.LAZY) private Department department; // getters and setters &#125; # 性别枚举12345678910111213141516171819202122package org.fanlychie.enums; public enum Sex &#123; MALE(\"男\"), FEMALE(\"女\"), ; private final String displayText; private Sex(String displayText) &#123; this.displayText = displayText; &#125; @Override public String toString() &#123; return displayText; &#125; &#125; 1.1 基础查询语法：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量 示例：查询所有的雇员信息 12@Query(\"SELECT E FROM Employee E\")List&lt;Employee&gt; selectAll(); 1.2 查询参数JPQL 支持两种查询参数，它们分别是命名参数和位置参数。 1.2.1 命名参数语法：:自定义的参数名称 示例：按性别和薪资范围查找雇员信息 12@Query(\"SELECT E FROM Employee E WHERE E.sex = :sex AND E.salary &gt; :salary\")List&lt;Employee&gt; selectByNamedParams(@Param(\"sex\") Sex sex, @Param(\"salary\") Double salary); 在方法的参数列表中，需要使用@Param注解标注每个参数的名称，使之与查询语句参数名称匹配。 1.2.2 位置参数语法：?位置编号的数值 示例：按姓名和性别查找雇员信息 12@Query(\"SELECT E FROM Employee E WHERE E.sex = ?1 AND E.salary &gt; ?2\")List&lt;Employee&gt; selectByPositionalParams(Sex sex, Double salary); 在方法的参数列表中，参数的顺序需要与查询语句中参数标注的编号依次对应起来。 1.3 关联查询通过使用关键字[LEFT|INNER] JOIN联接关系属性查询。 1.3.1 单值关联查询语法：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量 JOIN 实体名称.单值关联字段 [AS] 标识符变量2 ... 示例：按部门名称查找该部门所有的雇员信息 12@Query(\"SELECT E FROM Employee E JOIN E.department D WHERE D.name = ?1\")List&lt;Employee&gt; selectByDeptName(String deptName); 1.3.2 多值关联查询语法1：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量 JOIN 实体名称.多值关联字段 [AS] 标识符变量2 ... 示例：查询薪资大于10000的所有雇员所属的部门信息 12@Query(\"SELECT D FROM Department D JOIN D.employees E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedField(); 语法2：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量, IN(实体名称.多值关联字段) [AS] 标识符变量2 ... 12@Query(\"SELECT D FROM Department D, IN(D.employees) E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedCollection(); 1.4 去重查询语法：SELECT DISTINCT 标识符变量 FROM 实体名称 [AS] 标识符变量 ... 示例：查询薪资大于10000的所有雇员所属的部门信息，并消除查询结果中的重复的部门 12@Query(\"SELECT DISTINCT D FROM Department D JOIN D.employees E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedFieldDistinct(); 1.5 字面值JPQL 支持的字面值有以下的4种，它们分别是：字符串、数字、布尔、枚举。 1.5.1 字符串语法：&#39;字符串&#39; 示例：查询给定名字的雇员信息 12@Query(\"SELECT E FROM Employee E WHERE E.name = '张三'\")Employee selectByLiteralString(); 如果字符串中含有单引号，则用两个单引号来表示。如：Li&#39;Si -&gt; Li&#39;&#39;Si 12@Query(\"SELECT E FROM Employee E WHERE E.name = 'Li''Si'\")Employee selectByLiteralStringWithQuote(); 1.5.2 数字整数类型：如24、+24、-24、24L，支持 Java Long 范围的数值。 浮点类型：如24.、24.6、+24.6、-24.6、24.6F、24.6D，支持 Java Double 范围的数值。 示例：查询薪资大于10000的所有雇员 12@Query(\"SELECT E FROM Employee E WHERE E.salary &gt; 10000.0\")List&lt;Employee&gt; selectByLiteralNumber(); 1.5.3 布尔布尔类型的可选值为：TRUE或FALSE，它们不区分大小写。 示例：查找已婚的所有雇员 12@Query(\"SELECT E FROM Employee E WHERE E.married = TRUE\")List&lt;Employee&gt; selectByLiteralBool(); 1.5.4 枚举枚举类名必须指定为完全限定类名。 示例：查询所有女性的雇员 12@Query(\"SELECT E FROM Employee E WHERE E.sex = org.fanlychie.enums.Sex.FEMALE\")List&lt;Employee&gt; selectByLiteralEnum(); 1.6 模糊查询 表达式 匹配 不匹配 E.name LIKE ‘张%’ 张三 小张伟 E.name LIKE ‘张_’ 张三 张三丰 E.name LIKE ‘张\\_%’ 张_三 张三 示例：查询张性的所有雇员 12@Query(\"SELECT E FROM Employee E WHERE E.name LIKE '张%'\")List&lt;Employee&gt; selectByLikeLiteralString(); 1.7 空集合查询通过使用关键字IS [NOT] EMPTY来查找关联的属性集合的值为空的记录。 示例：查找尚无雇员的所有部门 12@Query(\"SELECT D FROM Department D WHERE D.employees IS EMPTY\")List&lt;Department&gt; selectByEmpty(); 1.8 构造器查询结果的类型如果不是持久化的实体类，必须使用该类的完全限定名。 语法：SELECT NEW 类的完全限定名(参数1, 参数2, ...) ... 示例：查询所有的雇员信息 12@Query(\"SELECT NEW org.fanlychie.model.SimpleEmployee(E.name, E.sex) FROM Employee E\")List&lt;SimpleEmployee&gt; selectSimpleEmployees(); 12345678910111213141516package org.fanlychie.model; public class SimpleEmployee &#123; private String name; private Sex sex; public SimpleEmployee(String name, Sex sex) &#123; this.name = name; this.sex = sex; &#125; // getters and setters &#125; 2. 更新示例：更新某个雇员的婚姻状态和薪资信息 1234@Modifying@Transactional@Query(\"UPDATE Employee SET married = ?2, salary = ?3 WHERE id = ?1\")int update(Long id, Boolean married, Double salary); @Query无法进行 DML（Data Manipulation Language 数据操控语言，主要语句有 INSERT、DELETE、UPDATE）操作，如需更新数据库表的数据需要标注@Modifying注解，并且需要使用支持事务的@Transactional注解。 3. 删除示例：删除没有雇员的部门信息 1234@Modifying@Transactional@Query(\"DELETE FROM Department D WHERE D.employees IS EMPTY\")int delete(); 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-jpql-sample参考文档文献链接：http://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm、http://docs.oracle.com/html/E13946_04/ejb3_langref.html","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"Spring Boot JPA","date":"2017-04-30T13:04:47.000Z","path":"post/spring-boot-jpa.html","text":"JPA（Java Persistence API）是一套 Java 持久化规范，用于将应用程序中的对象映射到关系型数据库。应用程序的数据访问层通常为域对象提供创建、读取、更新和删除（CRUD）操作，Spring Data JPA 提供了这方面的通用接口以及持久化存储特定的实现，它选择目前最流行之一的 Hibernate 作为 JPA 实现的提供者，旨在简化数据访问层。作为应用程序的开发人员，你只需要编写数据库的存取接口，由 Spring 运行时自动生成这些接口的适当实现，开发人员不需要编写任何具体的实现代码。在 Spring Boot 中，通过使用spring-boot-starter-data-jpa启动器，就能快速开启和使用 Spring Data JPA。 # pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 1. 编程接口 1.1 Repository这是 Spring Data Jpa 抽象的中心接口，它是一个标记接口。扩展此接口需要传递实体类型和实体的ID字段类型参数，你必须在接口里面声明你自己需要的方法，这些方法由 Spring 在运行时提供具体的实现。 12345public interface EmployeeRepository extends Repository&lt;Employee, Long&gt; &#123; Employee findOne(Long id); &#125; 1.2 CrudRepository继承自 Repository 接口，它提供了一套 CRUD 操作的方法。扩展此接口需要传递实体类型和实体的ID字段类型参数，你可以不需要再定义基础的 CRUD 操作方法而直接可以使用它们。但在某些场景中你可能不希望接口对外暴露一套完整的增删查改的方法，比如你只希望提供查改的方法而不希望暴露增删的功能。基于这种情况，你可以使用 Repository 接口，并将需要的方法从 CrudRepository 拷贝到其中以选择性的公开 CRUD 方法。 123public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; &#125; 1.2.1 save当你需要修改数据库的数据时，你可以调用此方法。当此方法被调用时，它首先判断参数的实体对象是否是新的。如果是新的，则调用 persist 将对象数据 insert 到数据库。如果不是新的，则调用 merge 将对象数据 update/insert 到数据库。源码：spring-data-jpa.jar!\\org\\springframework\\data\\jpa\\repository\\support\\SimpleJpaRepository.java # SimpleJpaRepository 源码片段123456789@Transactionalpublic &lt;S extends T&gt; S save(S entity) &#123; if (entityInformation.isNew(entity)) &#123; em.persist(entity); return entity; &#125; else &#123; return em.merge(entity); &#125;&#125; 判断实体对象是否是新的，其依据是主键字段是否设置了有效的值。源码：spring-data-commons.jar!\\org\\springframework\\data\\repository\\core\\support\\AbstractEntityInformation.java # AbstractEntityInformation 源码片段1234567891011public boolean isNew(T entity) &#123; ID id = getId(entity); Class&lt;ID&gt; idType = getIdType(); if (!idType.isPrimitive()) &#123; return id == null; &#125; if (id instanceof Number) &#123; return ((Number) id).longValue() == 0L; &#125; throw new IllegalArgumentException(String.format(\"Unsupported primitive id type %s!\", idType));&#125; 因此，CrudRepository.save()既有保存又有更新数据的能力。保存一条数据： 1234567@Testpublic void testSave() &#123; Employee employee = new Employee(); employee.setName(\"张三丰\"); employee.setAge(24); employeeRepository.save(employee);&#125; 更新数据时，应该先从数据库将记录查询出来，对数据修改完成之后再调用save更新回数据库： 123456@Testpublic void testUpdate() &#123; Employee employee = employeeRepository.findByName(\"张三丰\"); employee.setAge(25); employeeRepository.save(employee);&#125; 切勿脑洞大开异想通过设置主键字段的值来直接更新数据库的记录，以下做法是不可取的： 1234567@Testpublic void testUpdateById() &#123; Employee employee = new Employee(); employee.setId(1L); // 已知ID=1的记录是存在的 employee.setAge(26); // 期望根据ID更新年龄的值 employeeRepository.save(employee);&#125; 方法执行完之后悲剧就发生了，除了主键和年龄之外，其余字段的值全部被清空了。观众朋友切勿模仿。 1.2.2 delete根据主键删除时，主键字段不能为空，并且在数据库中必须得有与主键对应的行记录（通过SELECT查询判断），然后将查询出的行记录删除。 1234@Testpublic void testDeleteById() &#123; employeeRepository.delete(1L); // 产生 SELECT 和 DELETE 语句&#125; 根据实体删除时，实体对象不能为空，依据实体的主键标识判断数据库中是否有与之对应的行记录，如果有，则将此行删除；如果没有，则调用merge产生 INSERT 语句，然后再删除。 12345678910111213@Testpublic void testDeleteByEntity() &#123; Employee employee = new Employee(); employee.setId(2L); // 此 ID 在数据库中存在 employeeRepository.delete(employee); // 产生 SELECT 和 DELETE&#125; @Testpublic void testDeleteByNonExistentEntity() &#123; Employee employee = new Employee(); employee.setId(20L); // 此 ID 在数据库中不存在 employeeRepository.delete(employee); // 产生 SELECT 和 INSERT 及 DELETE&#125; 1.3 PagingAndSortingRepository继承自 CrudRepository 接口，它提供了一个分页和排序的操作方法。扩展此接口需要传递实体类型和实体的ID字段类型参数，但是通常我们会比较少选择扩展该接口，而更多的是在接口里声明含有 Pageable 或 Sort 类型参数的方法来完成分页或排序的功能。 123public interface EmployeeRepository extends PagingAndSortingRepository&lt;Employee, Long&gt; &#123; &#125; 1.3.1 排序查询123456789@Testpublic void testSelectAndOrder() &#123; List&lt;Order&gt; orders = new ArrayList&lt;&gt;(); orders.add(new Order(Direction.DESC, \"salary\")); // 薪资降序 orders.add(new Order(\"age\")); // 薪资相同则按年龄升序 orders.add(new Order(\"hireDate\").with(Direction.ASC)); // 薪资和年龄都相同则按入职时间升序 employeeRepository.findAll(new Sort(orders)) .forEach(System.out::println);&#125; 或 12345678@Testpublic void testSelectAndSort() &#123; Sort sort = new Sort(Direction.DESC, \"salary\") // 薪资降序 .and(new Sort(\"age\")) // 薪资相同则按年龄升序 .and(new Sort(Direction.DESC, \"hireDate\")); // 薪资和年龄都相同则按入职时间升序 employeeRepository.findAll(sort) .forEach(System.out::println);&#125; 1.3.2 分页查询1234567891011121314151617181920@Testpublic void testSelectByPagination() &#123; // 分页索引从0开始, 表示第一页 Page&lt;Employee&gt; page = employeeRepository.findAll(new PageRequest(0, 2)); long totalElements = page.getTotalElements(); // 查询结果总的记录条数 int totalPages = page.getTotalPages(); // 分页的总页数 List&lt;Employee&gt; content = page.getContent(); // 当前页的数据内容 int number = page.getNumber(); // 当前页的页码, 从0开始, 表示第一页 int numberOfElements = page.getNumberOfElements(); // 每页的记录条数 int size = page.getSize(); // 每页的记录条数 Sort sort = page.getSort(); // 分页查询的排序对象 boolean isFirst = page.isFirst(); // 是否是第一页 boolean isLast = page.isLast(); // 是否是最后一页 boolean hasContent = page.hasContent(); // 当前页是否有数据 boolean hasNext = page.hasNext(); // 是否有下一页 boolean hasPrevious = page.hasPrevious(); // 是否有上一页 Pageable nextPageable = page.nextPageable(); // 下一页的分页对象 Pageable previousPageable = page.previousPageable(); // 上一页的分页对象 page.forEach(System.out::println);&#125; 1.3.3 分页并排序1234567@Testpublic void testSelectByPaginationAndSort() &#123; Sort sort = new Sort(Direction.DESC, \"salary\") // 薪资降序 .and(new Sort(\"age\")); // 薪资相同则按年龄升序 Page&lt;Employee&gt; page = employeeRepository.findAll(new PageRequest(0, 2, sort)); page.forEach(System.out::println);&#125; 1.4 JpaRepository继承自 PagingAndSortingRepository 接口，它提供了一组实用的操作方法，如批量操作等。扩展此接口需要传递实体类型和实体的ID字段类型参数，该接口的一部分方法返回 List 类型的实体，与之不同的是，CrudRepository 返回的是 Iterable 类型的实体。 123public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; &#123; &#125; 2. 定义查询方法Spring Data JPA 在运行时会为接口创建代理对象并为接口声明的方法提供具体的实现。代理提供了两种方式来从方法名中提取查询，一种是从方法名中直接提取查询，另外一种是从方法中提取手工定义的查询语句。代理如何创建查询是由具体的策略来决定的。 策略 简述 CREATE 根据方法名构造出一个特定的查询。具体的做法是从方法名中移除一组已知的前缀，然后解析剩余的部分。 USE_DECLARED_QUERY 使用查询注解定义的查询语句。如：@Query、@NamedQuery、@NamedNativeQuery CREATE_IF_NOT_FOUND 默认使用的策略。它组合了 CREATE 和 USE_DECLARED_QUERY 两个策略。它首先使用 USE_DECLARED_QUERY 策略查找，如果找不到再使用 CREATE 策略。 2.1 创建查询JPA 提供了一种可以根据方法名称直接构造出查询语句的方式，这种方式称为创建查询。在存储库接口中定义的方法，其名称只需按照约定命名，需满足以下的规则： 方法名必须以：findBy find...By readBy read...By queryBy query...BycountBy count...By getBy get...By前缀之一开始命名； 在第一个By之后可以添加查询方法的检索条件，可以使用实体的属性名和支持的关键字来组合； 在第一个By之前可以添加First或Top关键字，表示返回查询结果的第一条数据。除此之外，关键字First或Top的后面也可以携带数字表示返回前多少条的数据，如Top10； 在第一个By之前可以添加Distinct关键字，去掉查询结果中重复的数据； 查询方法如果设定了X个检索条件，那么，查询方法的参数个数也必须是X个，并且参数必须按与检索条件相同的顺序给出； 查询方法同时还可以使用特殊的Pageable或Sort参数，用于分页或排序，该参数不算在X之内； 2.1.1 查询方法支持的关键字表 关键字 示例 JPQL 片段 And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 IsEquals findByFirstnamefindByFirstnameIsfindByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNullNotNull findByAgeNotNullfindByAgeIsNotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection&lt;Age&gt; ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection&lt;Age&gt; age) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 2.1.2 查询方法支持的返回值表 类型 简述 void 不需要返回值 Primitives Java 基本数据类型 Wrapper Java 基本数据类型对应的包装类型 T 期望返回的实体类型，查询方法至多只能返回一条数据结果，多于一条数据的结果将抛出异常，没有查询到数据结果，则返回 null Iterator&lt;T&gt; 迭代器类型 Collection&lt;T&gt; 集合类型 List&lt;T&gt; List 集合类型 Optional&lt;T&gt; Java8 Optional 类型 Stream&lt;T&gt; Java8 Stream 类型 Future&lt;T&gt; Java8 Future 类型，使用@Async注解标注查询方法，并且需要启用 Spring 异步方法执行的功能 CompletableFuture&lt;T&gt; Java8 CompletableFuture 类型，使用@Async注解标注查询方法，并且需要启用 Spring 异步方法执行的功能 ListenableFuture Spring ListenableFuture 类型，使用@Async注解标注查询方法，并且需要启用 Spring 异步方法执行的功能 Slice 分页相关 Page&lt;T&gt; 分页相关 在存储库接口中定义的方法，只需要按照约定命名，就能快速实现查询的功能： 123456789101112131415161718192021public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; // 根据姓名查询 Employee findByName(String name); // 根据姓名查询, 返回第一条记录 Employee findFirstByName(String name); // 根据姓名和性别查询 Employee findByNameAndSex(String name, Sex sex); // 根据性别查询, 返回前3条记录 List&lt;Employee&gt; findTop3BySex(Sex sex); // 根据性别分页查询 Page&lt;Employee&gt; findBySex(Sex sex, Pageable pageable); // 根据给定的年龄查找小于且未婚的记录并按年龄升序排序 List&lt;Employee&gt; findByAgeLessThanAndMarriedIsFalseOrderByAge(int age); &#125; 创建查询的优点是，不用编写查询语句，处理检索条件简单的查询非常方便，而且方法的可读性很高。但是对于检索条件过多的查询方法，很容易导致方法名称过长，可读性降低。 2.2 命名查询JPA 提供了一种可以将查询语句从存储库接口中独立出来的方式，这种方式称为命名查询。它允许我们通过使用@NamedQuery或@NamedNativeQuery注解将预定义好的静态查询语句直接绑定到目标方法。命名查询的优点是，查询语句集中，便于维护，查询方法的名称不受约束，编写复杂的查询只要合理命名也不会导致产生过长的方法名称。但是由于命名查询的注解都是标注在实体类中，因此它不适合用于大量定义查询语句，这样会使得实体类变得过于臃肿。 2.2.1 @NamedQuery 参数 简述 name 用于定义查询的方法名称，该方法名称是全局范围的，为避免不同的实体定义了相同的方法名称而导致的查询冲突，JPA 明确规定自定义的方法名称的命名需要满足约定：实体类的简单类名 + “.” + 自定义的查询方法名称 query 用于定义 JPQL 查询语句（附：查询参数语法） 使用@NamedQuery注解需要在实体类中标注使用： 12345678910111213141516@Entity(name = \"Employee\")@NamedQueries(&#123; @NamedQuery( name = \"Employee.selectBySex\", query = \"SELECT E FROM Employee E WHERE E.sex = ?1\" ), @NamedQuery( name = \"Employee.selectByName\", query = \"SELECT E FROM Employee E WHERE E.name = ?1\" )&#125;)public class Employee &#123; ... &#125; 然后在存储库接口中声明与这些名称相同的方法即可： 1234567public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; Employee selectByName(String name); List&lt;Employee&gt; selectBySex(Sex sex); &#125; 2.2.2 @NamedNativeQuery注解@NamedNativeQuery与@NamedQuery的用法和作用相类似。不同的是，@NamedQuery使用的是 JPQL 查询语言，可以做到跨数据库平台。而@NamedNativeQuery使用的是 SQL 查询语言，与特定的数据库平台紧密相关。@NamedNativeQuery注解也是需要在实体类中标注使用： 123456789101112131415161718@Entity(name = \"Employee\")@NamedNativeQueries(&#123; @NamedNativeQuery( name = \"Employee.searchBySex\", query = \"SELECT * FROM EMPLOYEE WHERE SEX = ?1\", resultClass = Employee.class ), @NamedNativeQuery( name = \"Employee.searchByName\", query = \"SELECT * FROM EMPLOYEE WHERE NAME = ?1\", resultClass = Employee.class )&#125;)public class Employee &#123; ... &#125; 相比较@NamedQuery注解而言，多了一个resultClass参数，它用于定义查询结果的返回值类型。 1234567public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; Employee searchByName(String name); List&lt;Employee&gt; searchBySex(String sex); &#125; 2.3 @Query 查询使用@Query注解可以直接将查询语句绑定到存储库接口的方法上，它同时支持 JPQL 和 SQL 查询语言。另外，它对方法名称的命名没有约束，并且查询语句就编写在方法的上方，方便追踪查询方法的具体作用。 2.3.1 JPQL 查询注解@Query默认使用的就是 JPQL 查询语言： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM Employee E WHERE E.name = ?1\") Employee queryOneByName(String name); &#125; 2.3.2 SQL 查询在@Query注解中，如果要使用 SQL 查询语言，nativeQuery参数需要标记为 true： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(value = \"SELECT * FROM EMPLOYEE WHERE NAME = ?1\", nativeQuery = true) Employee queryOneByName(String name); &#125; 2.3.3 LIKE 查询在@Query注解中，可以使用高级的LIKE表达式查询（命名查询不支持）： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM Employee E WHERE E.name LIKE %?1\") List&lt;Employee&gt; queryNameLike(String suffixName); &#125; 2.3.4 分页查询如果你使用的是@Query的 JPQL 查询语言，只需在查询方法中添加Pageable参数就能实现分页查询： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM Employee E WHERE E.sex = ?1\") Page&lt;Employee&gt; queryBySexPagination(Sex sex, Pageable pageable); &#125; 如果你使用的不是 JPQL 而是 SQL 查询语言，则还需提供countQuery参数用于查询结果的总条数： 12345678public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(value = \"SELECT * FROM EMPLOYEE WHERE SEX = ?1\", countQuery = \"SELECT COUNT(*) FROM EMPLOYEE WHERE SEX = ?1 \", nativeQuery = true) Page&lt;Employee&gt; queryBySexPagination(String sex, Pageable pageable); &#125; Spring Data JPA 官方文档给出了@Query注解使用本地查询分页的基础示例（Example 51），但是按照该示例编写出的代码运行时报错。 2.3.5 排序查询如果你使用的是@Query的 JPQL 查询语言，只需在查询方法中添加Sort参数就能实现排序功能： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM Employee E WHERE E.sex = ?1\") List&lt;Employee&gt; queryBySexAndSort(Sex sex, Sort sort); &#125; 注：@Query的本地查询（SQL 查询）不支持这种动态排序的功能。 如果是分页查询需要排序支持，可以通过向PageRequest构造器传入Sort对象来完成： 123456@Testpublic void testQueryBySexPagination() &#123; Page&lt;Employee&gt; page = employeeRepository.queryBySexPagination(Sex.FEMALE, new PageRequest(0, 2, new Sort(\"age\"))); page.forEach(System.out::println);&#125; 2.3.6 SpEL 表达式Spring Data JPA 1.4 版本开始引入 SpEL 表达式，目前支持的 SpEL 表达式非常有限（目前仅有一个）： 变量 描述 entityName 存储库接口关联的实体类的实体名称。如果实体类@Entity注解设置了name属性，那么将使用它。否则将使用实体类的简单类名。 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM #&#123;#entityName&#125; E WHERE E.name = ?1\") Employee queryByNameSpEL(String name); &#125; 2.3.7 更新查询@Query注解除了可以用来定义查询语句还可以用来定义更新语句（UPDATE/DELETE），在@Query标注的方法上只需要使用@Modifying注解就能实现更新的行为： 1234567891011public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Modifying @Query(\"UPDATE Employee E SET E.salary = ?2 WHERE E.name = ?1\") int updateSalaryForName(String name, Double salary); @Modifying @Query(\"DELETE FROM Employee E WHERE E.name = ?1\") int deleteByName(String name); &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-jpa-sample参考文档文献链接：http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Tomcat & HikariCP & DBCP 连接池","date":"2017-04-29T15:12:15.000Z","path":"post/spring-boot-tomcat-pool-hikaricp-dbcp-dbcp2.html","text":"Tomcat JDBC 连接池Spring Boot 默认选择 Tomcat JDBC Pool 作为数据库连接池。Tomcat（8） 连接池常用的属性： 属性 描述 默认值 defaultAutoCommit 连接池中创建的连接默认是否自动提交事务 驱动的缺省值 defaultReadOnly 连接池中创建的连接默认是否为只读状态 - defaultCatalog 连接池中创建的连接默认的 catalog - driverClassName 驱动类的名称 - username 数据库账户 - password 数据库密码 - maxActive 连接池同一时间可分配的最大活跃连接数 100 maxIdle 始终保留在池中的最大连接数，如果启用，将定期检查限制连接，超出此属性设定的值且空闲时间超过minEvictableIdleTimeMillis的连接则释放 与maxActive设定的值相同 minIdle 始终保留在池中的最小连接数，池中的连接数量若低于此值则创建新的连接，如果连接验证失败将缩小至此值 与initialSize设定的值相同 initialSize 连接池启动时创建的初始连接数量 10 maxWait 最大等待时间（毫秒），如果在没有连接可用的情况下等待超过此时间，则抛出异常 30000（30秒） testOnBorrow 当从连接池中取出一个连接时是否进行验证，若验证失败则从池中删除该连接并尝试取出另一个连接 false testOnConnect 当一个连接首次被创建时是否进行验证，若验证失败则抛出 SQLException 异常 false testOnReturn 当一个连接使用完归还到连接池时是否进行验证 false testWhileIdle 对池中空闲的连接是否进行验证，验证失败则回收此连接 false validationQuery 在连接池返回连接给调用者前用来对连接进行验证的查询 SQL null validationQueryTimeout SQL 查询验证超时时间（秒），小于或等于 0 的数值表示禁用 -1 timeBetweenEvictionRunsMillis 在空闲连接回收器线程运行期间休眠时间（毫秒）， 该值不应该小于 1 秒，它决定线程多久验证空闲连接或丢弃连接的频率 5000（5秒） minEvictableIdleTimeMillis 连接在池中保持空闲而不被回收的最小时间（毫秒） 60000（60秒） removeAbandoned 标记是否删除泄露的连接，如果连接超出removeAbandonedTimeout的限制，且该属性设置为 true，则连接被认为是被泄露并且可以被删除 false removeAbandonedTimeout 泄露的连接可以被删除的超时时间（秒），该值应设置为应用程序查询可能执行的最长时间 60 # src/main/resources/application.properties12345678910111213141516spring.datasource.url=jdbc:mysql://127.0.0.1/spring_boot_testing_storagespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.tomcat.default-auto-commit=truespring.datasource.tomcat.initial-size=3spring.datasource.tomcat.max-active=120spring.datasource.tomcat.max-wait=10000spring.datasource.tomcat.test-on-borrow=truespring.datasource.tomcat.test-while-idle=truespring.datasource.tomcat.validation-query=SELECT 1spring.datasource.tomcat.validation-query-timeout=3spring.datasource.tomcat.time-between-eviction-runs-millis=10000spring.datasource.tomcat.min-evictable-idle-time-millis=120000spring.datasource.tomcat.remove-abandoned=truespring.datasource.tomcat.remove-abandoned-timeout=120 # src/main/resources/application.yml12345678910111213141516171819spring: datasource: url: jdbc:mysql://127.0.0.1/spring_boot_testing_storage username: root password: root driver-class-name: com.mysql.jdbc.Driver tomcat: default-auto-commit: true initial-size: 30 max-active: 120 max-wait: 10000 test-on-borrow: true test-while-idle: true validation-query: 'SELECT 1' validation-query-timeout: 3 time-between-eviction-runs-millis: 10000 min-evictable-idle-time-millis: 120000 remove-abandoned: true remove-abandoned-timeout: 120 Spring Boot Data Jpa 依赖声明： # pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; HikariCP 连接池Spring Boot 如果发现 Tomcat 连接池不可用，则尝试选择 HikariCP 作为默认连接池。HikariCP 连接池常用的属性： 属性 描述 默认值 dataSourceClassName JDBC 驱动程序提供的 DataSource 类的名称，如果使用了jdbcUrl则不需要此属性 - jdbcUrl 数据库连接地址 - username 数据库账户，如果使用了jdbcUrl则需要此属性 - password 数据库密码，如果使用了jdbcUrl则需要此属性 - autoCommit 是否自动提交事务 true connectionTimeout 连接超时时间（毫秒），如果在没有连接可用的情况下等待超过此时间，则抛出 SQLException 30000（30秒） idleTimeout 空闲超时时间（毫秒），只有在minimumIdle&lt;maximumPoolSize时生效，超时的连接可能被回收，数值 0 表示空闲连接永不从池中删除 600000（10分钟） maxLifetime 连接池中的连接的最长生命周期（毫秒）。数值 0 表示不限制 1800000（30分钟） connectionTestQuery 连接池每分配一条连接前执行的查询语句（如：SELECT 1），以验证该连接是否是有效的。如果你的驱动程序支持 JDBC4，HikariCP 强烈建议我们不要设置此属性 - minimumIdle 最小空闲连接数，HikariCP 建议我们不要设置此值，而是充当固定大小的连接池 与maximumPoolSize数值相同 maximumPoolSize 连接池中可同时连接的最大连接数，当池中没有空闲连接可用时，就会阻塞直到超出connectionTimeout设定的数值 10 poolName 连接池名称，主要用于显示在日志记录和 JMX 管理控制台中 auto-generated # src/main/resources/application.properties1234567spring.datasource.url=jdbc:mysql://127.0.0.1/spring_boot_testing_storagespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.hikari.auto-commit=truespring.datasource.hikari.connection-test-query=SELECT 1spring.datasource.hikari.maximum-pool-size=150 # src/main/resources/application.yml12345678910spring: datasource: url: jdbc:mysql://127.0.0.1/spring_boot_testing_storage username: root password: root driver-class-name: com.mysql.jdbc.Driver hikari: auto-commit: true connection-test-query: 'SELECT 1' maximum-pool-size: 150 Spring Boot Data Jpa 依赖声明： # pom.xml123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; DBCP 连接池Spring Boot 如果发现 HikariCP 连接池不可用，则尝试选择 DBCP 作为默认连接池。DBCP（2） 连接池常用的属性： 属性 描述 默认值 url 数据库连接地址 - username 数据库账户 - password 数据库密码 - driverClassName 驱动类的名称 - defaultAutoCommit 连接池中创建的连接默认是否自动提交事务 驱动的缺省值 defaultReadOnly 连接池中创建的连接默认是否为只读状态 驱动的缺省值 defaultCatalog 连接池中创建的连接默认的 catalog - initialSize 连接池启动时创建的初始连接数量 0 maxTotal 连接池同一时间可分配的最大活跃连接数；负数表示不限制 8 maxIdle 可以在池中保持空闲的最大连接数，超出此值的空闲连接被释放，负数表示不限制 8 minIdle 可以在池中保持空闲的最小连接数，低于此值将创建空闲连接，若设置为 0，则不创建 0 maxWaitMillis 最大等待时间（毫秒），如果在没有连接可用的情况下等待超过此时间，则抛出异常；-1 表示无限期等待，直到获取到连接为止 - validationQuery 在连接池返回连接给调用者前用来对连接进行验证的查询 SQL - validationQueryTimeout SQL 查询验证超时时间（秒） - testOnCreate 连接在创建之后是否进行验证 false testOnBorrow 当从连接池中取出一个连接时是否进行验证，若验证失败则从池中删除该连接并尝试取出另一个连接 true testOnReturn 当一个连接使用完归还到连接池时是否进行验证 false testWhileIdle 对池中空闲的连接是否进行验证，验证失败则释放此连接 false timeBetweenEvictionRunsMillis 在空闲连接回收器线程运行期间休眠时间（毫秒），如果设置为非正数，则不运行此线程 -1 numTestsPerEvictionRun 空闲连接回收器线程运行期间检查连接的个数 3 minEvictableIdleTimeMillis 连接在池中保持空闲而不被回收的最小时间（毫秒） 1800000（30分钟） removeAbandonedOnBorrow 标记是否删除泄露的连接，如果连接超出removeAbandonedTimeout的限制，且该属性设置为 true，则连接被认为是被泄露并且可以被删除 false removeAbandonedTimeout 泄露的连接可以被删除的超时时间（秒），该值应设置为应用程序查询可能执行的最长时间 300（5分钟） poolPreparedStatements 设置该连接池的预处理语句池是否生效 false # src/main/resources/application.properties123456789101112131415161718192021spring.jmx.enabled=falsespring.datasource.url=jdbc:mysql://127.0.0.1/spring_boot_testing_storagespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.dbcp2.default-auto-commit=truespring.datasource.dbcp2.initial-size=30spring.datasource.dbcp2.max-total=120spring.datasource.dbcp2.max-idle=120spring.datasource.dbcp2.min-idle=30spring.datasource.dbcp2.max-wait-millis=10000spring.datasource.dbcp2.validation-query=SELECT 1spring.datasource.dbcp2.validation-query-timeout=3spring.datasource.dbcp2.test-on-borrow=truespring.datasource.dbcp2.test-while-idle=truespring.datasource.dbcp2.time-between-eviction-runs-millis=10000spring.datasource.dbcp2.num-tests-per-eviction-run=10spring.datasource.dbcp2.min-evictable-idle-time-millis=120000spring.datasource.dbcp2.remove-abandoned-on-borrow=truespring.datasource.dbcp2.remove-abandoned-timeout=120spring.datasource.dbcp2.pool-prepared-statements=true # src/main/resources/application.yml12345678910111213141516171819202122232425spring: jmx: enabled: false datasource: url: jdbc:mysql://127.0.0.1/spring_boot_testing_storage username: root password: root driver-class-name: com.mysql.jdbc.Driver dbcp2: default-auto-commit: true initial-size: 30 max-total: 120 max-idle: 120 min-idle: 30 max-wait-millis: 10000 validation-query: 'SELECT 1' validation-query-timeout: 3 test-on-borrow: true test-while-idle: true time-between-eviction-runs-millis: 10000 num-tests-per-eviction-run: 10 min-evictable-idle-time-millis: 120000 remove-abandoned-on-borrow: true remove-abandoned-timeout: 120 pool-prepared-statements: true Spring Boot Data Jpa 依赖声明： # pom.xml123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 参考文档文献链接：tomcat-8-jdbc-pool-doc、HikariCP-doc、commons-dbcp-doc","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot JDBC","date":"2017-04-28T12:18:25.000Z","path":"post/spring-boot-jdbc-example.html","text":"Spring 对 JDBC API 操作数据库进行了良好的封装，通过使用 JdbcTemplate，你不必关心数据库连接创建和打开、处理异常、连接关闭等问题。这些细节都由 JdbcTemplate 底层来完成，你只需要专注于业务 SQL 语句的编写以及执行结果的处理。在 Spring Boot 中，你可以通过spring-boot-starter-jdbc启动器快速开启和使用它。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 1. 环境配置在 MySQL 测试数据库创建表： 123456CREATE TABLE `employee` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `name` varchar(128) DEFAULT NULL COMMENT '姓名', `age` int(11) DEFAULT NULL COMMENT '年龄', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=gbk COMMENT='员工表'; 编写对应的实体类： 1234567891011public class Employee &#123; private Long id; private String name; private Integer age; // getters and setters &#125; 项目配置文件信息： # src/main/resources/application.yml1234567891011121314spring: main: banner-mode: 'off' datasource: url: jdbc:mysql://127.0.0.1/test username: root password: root driver-class-name: com.mysql.jdbc.Driver tomcat: default-auto-commit: truelogging: level: root: warn org.springframework.jdbc.core.JdbcTemplate: debug 2. 保存操作向数据库插入一条记录： 1234public int save(Employee employee) &#123; return jdbcTemplate.update(\"INSERT INTO EMPLOYEE(NAME, AGE) VALUE (?, ?)\", employee.getName(), employee.getAge());&#125; 如果表的主键字段是自动递增的，可以使用GeneratedKeyHolder来接收 SQL 执行完成之后插入数据库的记录的主键的值： 123456789101112public Employee save(Employee employee) &#123; KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(con -&gt; &#123; PreparedStatement ps = con.prepareStatement(\"INSERT INTO EMPLOYEE(NAME, AGE) VALUE (?, ?)\", Statement.RETURN_GENERATED_KEYS); ps.setString(1, employee.getName()); ps.setInt(2, employee.getAge()); return ps; &#125;, keyHolder); employee.setId(keyHolder.getKey().longValue()); return employee;&#125; 3. 查询操作查询某个字段信息： 1234public String findNameById(Long id) &#123; return jdbcTemplate.queryForObject(\"SELECT NAME FROM EMPLOYEE WHERE ID = ?\", new Object[]&#123;id&#125;, String.class);&#125; 查询一条完整的记录： 12345678910public Employee findById(Long id) &#123; return jdbcTemplate.queryForObject(\"SELECT * FROM EMPLOYEE WHERE ID = ?\", new Object[]&#123;id&#125;, (rs, rowNum) -&gt; &#123; Employee employee = new Employee(); employee.setId(rs.getLong(\"id\")); employee.setAge(rs.getInt(\"age\")); employee.setName(rs.getString(\"name\")); return employee; &#125;);&#125; 查询所有的记录： 12345678910public List&lt;Employee&gt; findAll() &#123; return jdbcTemplate.query(\"SELECT * FROM EMPLOYEE\", (rs, rowNum) -&gt; &#123; Employee employee = new Employee(); employee.setId(rs.getLong(\"id\")); employee.setAge(rs.getInt(\"age\")); employee.setName(rs.getString(\"name\")); return employee; &#125;);&#125; 4. 更新操作更新数据库中的一条记录： 1234public int update(Employee employee) &#123; return jdbcTemplate.update(\"UPDATE EMPLOYEE SET NAME = ?, AGE = ? WHERE ID = ?\", employee.getName(), employee.getAge(), employee.getId());&#125; 批量更新记录： 12345678910111213141516public int[] batchUpdate(List&lt;Employee&gt; employees) &#123; return jdbcTemplate.batchUpdate(\"UPDATE EMPLOYEE SET NAME = ?, AGE = ? WHERE ID = ?\", new BatchPreparedStatementSetter() &#123; @Override public void setValues(PreparedStatement ps, int i) throws SQLException &#123; Employee employee = employees.get(i); ps.setString(1, employee.getName()); ps.setInt(2, employee.getAge()); ps.setLong(3, employee.getId()); &#125; @Override public int getBatchSize() &#123; return employees.size(); &#125; &#125;);&#125; 5. 删除操作删除一条记录： 123public int delete(Long id) &#123; return jdbcTemplate.update(\"DELETE FROM EMPLOYEE WHERE ID = ?\", id);&#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-jdbc-sample参考文档文献链接：relational-data-access","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 启动器介绍","date":"2017-04-26T12:18:25.000Z","path":"post/spring-boot-starters-list.html","text":"Spring Boot 提供的启动器（Starters）是一组非常方便的依赖关系描述符，你可以通过启动器获得所有和 Spring 技术相关的一站式服务。所有官方的启动器都是以spring-boot-starter-*模式命名，其中*是表示某种特定类型的应用。这种命名结构能够帮助我们快速的找到所需的启动器。例如，如果想使用 Spring 和 JDBC 技术，你只需要在项目中使用spring-boot-starter-jdbc依赖即可。 名称 描述 pom spring-boot-starter-thymeleaf Thymeleaf 作为视图的 Spring MVC Web 应用 pom spring-boot-starter-data-couchbase Couchbase 数据库 pom spring-boot-starter-artemis Apache Artemis 提供的 JMS 消息服务 pom spring-boot-starter-web-services Spring Web Services pom spring-boot-starter-mail Java Mail 和 Spring 支持的电子邮件发送 pom spring-boot-starter-data-redis Jedis 作为客户端的 Redis 缓存 pom spring-boot-starter-web Spring MVC 的 RESTful 应用，Tomcat 作为内嵌容器 pom spring-boot-starter-data-gemfire GemFire 分布式数据存储 pom spring-boot-starter-activemq Apache ActiveMQ 提供的 JMS 消息服务 pom spring-boot-starter-data-elasticsearch Elasticsearch 搜索引擎 pom spring-boot-starter-test 单元测试 pom spring-boot-starter-jdbc 内置 Tomcat JDBC 连接池的 Spring JDBC 应用 pom spring-boot-starter-mobile Spring Mobile 构建的 Web 应用 pom spring-boot-starter-validation Hibernate Validator 验证器 pom spring-boot-starter-websocket Websocket 应用 pom spring-boot-starter-aop Spring AOP 和 AspectJ 面向方面的编程 pom spring-boot-starter-amqp Rabbit MQ 提供的 JMS 消息服务 pom spring-boot-starter-data-cassandra Cassandra 分布式数据库 pom spring-boot-starter-social-facebook Spring Social Facebook pom spring-boot-starter-jta-atomikos Atomikos JTA 事务 pom spring-boot-starter-security Spring Security 安全框架 pom spring-boot-starter-data-jpa Spring Data JPA pom spring-boot-starter 核心启动器，包括自动配置支持，日志记录和YAML pom spring-boot-starter-groovy-templates Groovy 作为视图的 Spring MVC Web 应用 pom spring-boot-starter-freemarker Freemarker 作为视图的 Spring MVC Web 应用 pom spring-boot-starter-batch Spring Batch pom spring-boot-starter-cache Spring 框架缓存 pom spring-boot-starter-data-solr Solr 搜索引擎 pom spring-boot-starter-data-mongodb Mongo 数据库 pom spring-boot-starter-jooq jOOQ 访问数据库 pom","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 日志","date":"2017-04-25T15:21:15.000Z","path":"post/spring-boot-logging.html","text":"Spring Boot 内部所有的日志记录都是通过使用 Commons Logging 实现，同时默认配置也提供了 Java Util Logging、Log4J、Log4J2、Logback 的支持。每种日志都预配置可以使用控制台输出和文件输出。Spring Boot 日志由启动器spring-boot-starter-logging来解决： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 你不必显式的声明此依赖。默认情况下，Spring Boot 使用 Logback 进行日志记录。 1. 日志级别在 Spring Boot 中，通过logging.level.*=TRACE/DEBUG/INFO/WARN/ERROR/FATAL/OFF来设置日志的级别。*可以是根级别（root）也可以是包级别。 application.properties 配置示例： 123logging.level.root = WARNlogging.level.org.springframework = INFOlogging.level.org.hibernate.SQL = DEBUG application.yml 配置示例： 12345logging: level: root: WARN org.springframework: INFO org.hibernate.SQL: DEBUG 2. 文件输出默认情况下，Spring Boot 只将日志信息显示到控制台。如果你想要将日志信息输出到外部文件，你可以使用logging.file或logging.path属性来配置。日志文件大小达到 10M 时，将产生一个新的文件。 使用logging.file可以设置日志输出的文件 文件相对路径（相对项目的根目录）：logfile.log或logs/logfile.log 文件绝对路径：/pathname/logfile.log application.properties 配置示例： 1logging.file = logs/logfile.log application.yml 配置示例： 12logging: file: logs/logfile.log 使用logging.path可以设置日志输出的目录，spring.log日志文件将输出到该目录 目录相对路径（相对项目的根目录）：logs或pathname/logs 目录绝对路径：/pathname/logs application.properties 配置示例： 1logging.path = logs application.yml 配置示例： 12logging: path: logs 3. 日志格式Spring Boot 默认输出的日志信息格式： 122017-07-09 11:47:06.599 INFO 10252 --- [main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-07-09 11:47:06.632 INFO 10252 --- [main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http) 它由以下几个部分组成： 精确到毫秒的日期和时间 日志级别（TRACE&lt;br&gt;DEBUG&lt;br&gt;INFO&lt;br&gt;WARN&lt;br&gt;ERROR） 进程 ID 分隔符--- 线程名称，包裹在[]中 日志名称，通常是类的完全限定路径的简写 分隔符: 日志消息 使用logging.pattern.console（只支持logback）可以自定义控制台日志输出格式。 application.properties 配置示例： 1logging.pattern.console=\"%date&#123;yyyy-MM-dd HH:mm:ss&#125; -%5level [%15.15thread] %-40.40logger&#123;39&#125; : %msg%n\" application.yml 配置示例： 123logging: pattern: console: \"%date&#123;yyyy-MM-dd HH:mm:ss&#125; -%5level [%15.15thread] %-40.40logger&#123;39&#125; : %msg%n\" 使用logging.pattern.file（只支持logback）可以自定义文件的日志输出格式。 application.properties 配置示例： 1logging.pattern.file=\"%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; -%5level [%15.15thread] %-40.40logger&#123;39&#125; : %msg%n\" application.yml 配置示例： 123logging: pattern: file: \"%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; -%5level [%15.15thread] %-40.40logger&#123;39&#125; : %msg%n\" 常用的日志信息格式化参数： 参数 描述 %c{length}%logger{length} 输出所属的类目，通常就是所在类的全名 %d{pattern}%date{pattern} 输出日志的日期或时间 %F%file 输出发出日志记录请求的Java源文件的文件名 %L%line 输出日志事件的发生行号信息 %m%msg%message 输出程序代码中指定的消息 %p%le%level 输出日志级别信息 %t%thread 输出产生该日志事件的线程名 %n 输出一个平台的回车换行符 其中 %logger{length}，如果信息长度大于给定的 length 的值，保留最右边的单词，左边的每个单词只保留第一个字符。 示例 信息 结果 %logger org.fanlychie.DemoService org.fanlychie.DemoService %logger{0} org.fanlychie.DemoService DemoService %logger{10} org.fanlychie.DemoService o.f.DemoService %logger{24} org.fanlychie.DemoService o.fanlychie.DemoService %logger{100} org.fanlychie.DemoService org.fanlychie.DemoService 日志信息宽度和对齐方式控制，以%logger为例： 示例 描述 %50logger 右对齐，最小的宽度是50，长度不足50则左补空格，长度超出50则原样输出 %-50logger ‘-‘表示向左对齐，最小的宽度是50，长度不足50则右补空格，长度超出50则原样输出 %.20logger 左对齐，最大的宽度是20，如果长度超出20，将左边多出的字符直接丢掉 %30.50logger 最小宽度是30，如果长度不足30则左补空格右对齐；如果长度超出30且不足50则左对齐；如果长度超出50则将左边多出的字符直接丢掉 4. 扩展 logbackSpring Boot 允许我们通过扩展 Logback 进行更高级的配置。在类路径下创建logback-sprng.xml： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 引用 Spring Boot 的 base.xml 的配置 --&gt; &lt;!-- spring-boot.jar!\\org\\springframework\\boot\\logging\\logback\\base.xml --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\"/&gt; &lt;!-- 自定义日志级别 --&gt; &lt;root level=\"ERROR\" /&gt; &lt;logger name=\"org.springframework.web\" level=\"INFO\"/&gt; &lt;logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/&gt;&lt;/configuration&gt; 4.1 配置文件的加载Spring Boot 默认从系统类路径加载的日志配置文件： logback-spring.xml logback-spring.groovy logback.xml logback.groovy 单元测试的 DEBUG 日志可以在src/test/resources/logback-test.xml中配置控制。 5. 多环境日志配置使用&lt;springProfile&gt;标签可以定义不同 profile 环境的配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 引用 Spring Boot 的 defaults.xml 的配置 --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/&gt; &lt;!-- 定义 LOG_FILE 变量 --&gt; &lt;!-- 日志文件优先使用 logging.file 的值，如果没有则使用 logging.path 的值，如果还没有则放入临时目录 --&gt; &lt;property name=\"LOG_FILE\" value=\"$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;/&#125;spring.log&#125;\"/&gt; &lt;!-- 自定义日志级别 --&gt; &lt;logger name=\"org.springframework.web\" level=\"INFO\"/&gt; &lt;logger name=\"org.fanlychie\" level=\"DEBUG\"/&gt; &lt;!-- 开发环境日志 --&gt; &lt;springProfile name=\"dev\"&gt; &lt;!-- 引用 Spring Boot 的 console-appender.xml 的配置 --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\"/&gt; &lt;!-- root 日志级别 --&gt; &lt;root level=\"WARN\"&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!-- 生产环境日志 --&gt; &lt;springProfile name=\"prod\"&gt; &lt;!-- 引用 Spring Boot 的 console-appender.xml 的配置 --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\"/&gt; &lt;!-- 自定义文件日志 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;encoder&gt; &lt;!-- 使用默认的日志格式 --&gt; &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 日志文件 --&gt; &lt;file&gt;$&#123;LOG_FILE&#125;&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;!-- 如果日志文件超出大小限制, 则以 $&#123;LOG_FILE&#125;.1, $&#123;LOG_FILE&#125;.2... 备份 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_FILE&#125;.%i&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;!-- 超出大小限制开启一个新的文件 --&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!-- root 日志级别 --&gt; &lt;root level=\"WARN\"&gt; &lt;appender-ref ref=\"FILE\"/&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; application.properties 配置示例： 12spring.profiles.active = devlogging.file = logs/logfile.log application.yml 配置示例： 12345spring: profiles: active: devlogging: file: logs/logfile.log 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-logging-sample参考文档文献链接：logback-doc、spring-boot-logging","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Profiles 配置","date":"2017-04-23T15:21:15.000Z","path":"post/spring-boot-profiles.html","text":"Spring Profiles 提供了一套隔离应用配置的方式，它允许我们通过定义不同的 profiles 来提供不同组合的配置。在不同的环境中，启动应用时可以通过选择激活某组特定的 profiles 来适应运行时环境，以达到在不同的环境可以使用相同的一套程序代码。 1. 使用 @Profiles 创建 profilesSpring 提供了@Profiles注解，用于创建 profiles 配置。你可以在@Component(@Service、@Repository) 或@Configuration注解标注的类中使用它。 12345public interface AuthorityService &#123; boolean hasRole(String role); &#125; 12345678910@Service@Profile(\"dev\")public class DevAuthorityServiceImpl implements AuthorityService &#123; @Override public boolean hasRole(String role) &#123; return true; &#125; &#125; 12345678910@Service@Profile(\"prod\")public class ProdAuthorityServiceImpl implements AuthorityService &#123; @Override public boolean hasRole(String role) &#123; return role == \"admin\"; &#125; &#125; 1.1 设置默认的 profiles在@Profile注解中，可以通过使用关键字default将当前的配置设置为默认的 profiles。Spring Boot 在启动时默认就会来加载此 profiles 配置。 12345678910@Service@Profile(&#123;\"dev\", \"default\"&#125;)public class DevAuthorityServiceImpl implements AuthorityService &#123; @Override public boolean hasRole(String role) &#123; return true; &#125; &#125; 2. 使用属性配置文件创建 profiles我们可以按照约定，将项目的配置文件以application-{profile}.{properties|yml}的方式命名来创建 profiles 配置。 application-test.properties 配置： 1custom.env = test-env application-prod.properties 配置： 1custom.env = prod-env 而在*.yml配置文件中，我们可以通过使用---分隔符在同一个文件创建多个 profile 配置： 123456789spring: profiles: testcustom: env: test-env---spring: profiles: prodcustom: env: prod-env 3. 激活 profiles当我们配置了多组不同的 profiles 后，我们可以非常灵活的有选择性的激活它们，而那些未被激活的 profiles 配置，则不会被加载。 3.1 通过配置文件激活application.properties 配置示例： 1spring.profiles.active = dev, test application.yml 配置示例： 12345spring: profiles: active: - dev - test 3.2 通过命令行激活终端在启动 Spring Boot 应用的时候可以使用-Dspring.profiles.active参数激活 profiles 配置。 1$ java -jar -Dspring.profiles.active=\"dev, test\" xxxx.jar 3.3 通过 @ActiveProfiles 注解激活这种方式仅适用于单元测试，@ActiveProfiles是由spring-test提供的。 1234567891011@RunWith(SpringRunner.class)@SpringBootTest@ActiveProfiles(&#123;\"dev\", \"test\"&#125;)public class ApplicationTest &#123; @Test public void testProfiles() &#123; &#125; &#125; 3.4 通过 setAdditionalProfiles 激活在 Spring Boot 启动类中，可以通过调用SpringApplication.setAdditionalProfiles(...)来激活一组 profiles 配置。 12345678910@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication application = new SpringApplication(Application.class); application.setAdditionalProfiles(\"dev\", \"test\"); application.run(args); &#125; &#125; 3.5 通过 setActiveProfiles 激活在 Spring Boot 启动类中，可以通过调用ConfigurableEnvironment.setActiveProfiles(...)来激活一组 profiles 配置。 123456789101112@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication application = new SpringApplication(Application.class); ConfigurableEnvironment environment = new StandardEnvironment(); environment.setActiveProfiles(\"dev\", \"test\"); application.setEnvironment(environment); application.run(args); &#125; &#125; 4. 组合 profiles 配置使用spring.profiles.include属性可以将多个不同的 profiles 有效的组合到一起： 1234567891011121314151617181920spring: profiles: active: dev-test---spring: profiles: testcustom: env: test-env---spring: profiles: prodcustom: env: prod-env---spring.profiles: dev-testspring: profiles: include: - dev - test 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-profiles-sample参考文档文献链接：spring-boot-features-profiles","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 属性文件配置","date":"2017-04-16T05:24:40.000Z","path":"post/spring-boot-properties.html","text":"Spring Boot 允许我们通过*.properties文件、*.yml文件、环境变量、命令行参数等来外部化应用程序的配置，以便我们在不同的环境可以使用同一套程序代码。 1. 配置加载优先级Spring Boot 加载配置文件的优先级从高到低的搜索顺序为： 注解@TestPropertySource设置的属性文件 注解@SpringBootTest#properties设置的属性文件 命令行参数 ServletConfig 初始化参数 ServletContext 初始化参数 来自java:comp/env的 JNDI 属性 Java 系统属性（通过System.getProperties()能获取到的） 操作系统环境变量 含有random.*值的属性 Jar 包外部的application-{profile}.{properties|yml} Jar 包内部的application-{profile}.{properties|yml} Jar 包外部的application.{properties|yml} Jar 包内部的application.{properties|yml} 注解@PropertySource设置的属性文件 启动类SpringApplication.setDefaultProperties设置的默认属性 Spring Boot 搜索 Jar 包外部的application.{properties|yml}文件时，它优先搜索类路径下的/config目录，如果没有，再到类路径的根目录下搜索。 你可以参考源码： spring-configuration-metadata.json#spring.config.location spring-configuration-metadata.json#spring.config.name org.springframework.boot.context.config.ConfigFileApplicationListener 2. 配置文件配置Spring Boot 允许我们通过*.properties文件、*.yml文件来外部化应用程序的配置，我们只需要在类路径下创建application.{properties|yml}文件。 2.1 properties 配置文件相信大家对*.properties文件都并不陌生，这里就不多说了，看下面的示例： 12email-name = fanlychieemail-from = fanlychie@yeah.net 2.2 yaml 配置文件YAML 是一种专门用来编写配置文件（*.yml）的语言，它的语法简洁，也方便人们阅读。在部分 IDE 开发工具（如 IntelliJ IDEA）中还有代码提示，让人爱不释手。 123456789101112131415# 自定义属性data-structure: # 简单键值对 key-value: YAML Sample # 数组 array: value1, value2, value3 # List 集合 list: - value1 - value2 - value3 # Map 散列表 map: name: fanlychie email: fanlychie@yeah.net 3. 属性占位符在配置文件中，我们可以使用${var}语法引用已经定义的属性的值。 application.properties 配置示例： 12app.name = Spring Boot Properties Sampleapp.description = $&#123;app.name&#125; For My Github's Blog application.yml 配置示例： 123app: name: Spring Boot Properties Sample description: $&#123;app.name&#125; For My Github's Blog 我们还可以使用${var :defalutValue}语法来设置默认的值，如果var不存在, 则使用默认的值。 12app.name = Spring Boot Properties Sampleapp.description = $&#123;app.name :YourName&#125; For My Github's Blog application.yml 配置示例： 123app: name: Spring Boot Properties Sample description: $&#123;app.name :YourName&#125; For My Github's Blog 4. 绑定属性Spring Boot 对*.properties和*.yml配置文件中配置的属性名称提供了松绑定，它不要求配置的属性名称完全与 Bean 中的属性名称一致。它支持以下几种规格的命名方式： 属性 描述 firstName 标准的驼峰式命名 first-name 单词之间通过‘-‘分隔，Spring Boot 推荐这种 first_name 单词之间通过‘_’分隔 FIRST_NAME 单词全部大写并通过‘_’分隔，在使用系统环境变量时，推荐这种 4.1 通过 @Value 注解绑定application.yml 配置示例： 12email-name: fanlychieemail-from: fanlychie@yeah.net 通过使用@Value(&quot;${属性名称}&quot;)注解可以将属性的值注入到 Bean 对象的属性中： 123456789101112@Componentpublic class EmailValueConfig &#123; @Value(\"$&#123;email-name&#125;\") private String emailName; @Value(\"$&#123;email-from&#125;\") private String emailFrom; // getters &#125; 4.2 通过 @ConfigurationProperties 注解绑定通过使用@ConfigurationProperties注解可以将属性值绑定到结构化的对象中： 1234567891011@Component@ConfigurationPropertiespublic class EmailConfig &#123; private String emailName; private String emailFrom; // getters and setters &#125; 使用@ConfigurationProperties(&quot;前缀限定名&quot;)可以将*.*的属性绑定到 Bean 中。 application.yml 配置示例： 123app: name: Spring Boot Properties Sample description: $&#123;app.name&#125; For My Github's Blog 通过@ConfigurationProperties(&quot;app&quot;)绑定app.*属性： 1234567891011@Component@ConfigurationProperties(\"app\")public class AppConfig &#123; private String name; private String description; // getters and setters &#125; 4.3 复杂的属性绑定application.properties 配置示例： 1234567891011121314151617181920layout.desc = 布局配置layout.moudles[0].desc = 顶部模块layout.moudles[0].width = 100%layout.moudles[0].height = 200pxlayout.moudles[1].desc = 主区域模块layout.moudles[1].width = 80%layout.moudles[1].height = autolayout.moudles[2].desc = 脚部模块layout.moudles[2].width = 100%layout.moudles[2].height = 300pxlayout.background-rgb = 97, 96, 96, 1layout.tag-cloud-random-colors[0] = redlayout.tag-cloud-random-colors[1] = bluelayout.tag-cloud-random-colors[2] = greenlayout.tag-cloud-random-colors[3] = yellowlayout.moudle-color-mapping.top = whitelayout.moudle-color-mapping.main = graylayout.moudle-color-mapping.bottom = pinklayout.author.name = fanlychielayout.author.mail = fanlychie@yeah.net application.yml 配置示例： 12345678910111213141516171819202122232425layout: desc: 布局配置 moudles: - desc: 顶部模块 width: 100% height: 200px - desc: 主区域模块 width: 80% height: auto - desc: 脚部模块 width: 100% height: 300px background-rgb: 97, 96, 96, 1 tag-cloud-random-colors: - red - blue - green - yellow moudle-color-mapping: top: white main: gray bottom: pink author: name: fanlychie mail: fanlychie@yeah.net 1234567891011121314151617181920212223242526272829303132333435363738394041@Component@ConfigurationProperties(\"layout\")public class LayoutConfig &#123; private String desc; private List&lt;Moudle&gt; moudles; private int[] backgroundRgb; private List&lt;String&gt; tagCloudRandomColors; private Map&lt;String, String&gt; moudleColorMapping; private Author author; public static class Moudle &#123; private String width; private String height; private String desc; // getters and setters &#125; public static class Author &#123; private String name; private String mail; // getters and setters &#125; // getters and setters &#125; 4.4 对绑定的属性进行验证在@ConfigurationProperties注解标注的类中，你可以直接使用JSR-303相关的约束注解对绑定的属性值进行验证： 1234567891011121314151617181920import org.hibernate.validator.constraints.Length;import org.hibernate.validator.constraints.NotBlank;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import javax.validation.constraints.NotNull; @Component@ConfigurationProperties(\"app\")public class AppWithJSR303Config &#123; @NotNull private String name; @NotBlank @Length(min = 1, max = 100) private String description; // getters and setters &#125; 5. 配置随机值Spring Boot 内部提供了一个random.*属性，专门用于生成随机种子。 属性 描述 random.int 随机产生正负的整数 random.int(max) 随机产生 [0, max) 区间的整数 random.int(min,max) 随机产生 [min, max) 区间的整数 random.long 随机产生正负的长整数 random.long(max) 随机产生 [0, max) 区间的长整数 random.long(min,max) 随机产生 [min, max) 区间的长整数 random.uuid 产生 UUID 字符串（含‘-‘字符） random.* ‘*’表示除上面列举之外的其他字符，用于随机产生 32 位字符串 你可以翻阅源代码：org.springframework.boot.context.config.RandomValuePropertySource application.properties 配置示例： 123456random-seed.random-int-value=$&#123;random.int&#125;random-seed.random-int-range-value=$&#123;random.int(2)&#125;random-seed.random-long-value=$&#123;random.long&#125;random-seed.random-long-range-value=$&#123;random.long(1,3)&#125;random-seed.random-uuid-value=$&#123;random.uuid&#125;random-seed.random-str-value=$&#123;random.whatever&#125; application.yml 配置示例： 1234567random-seed: random-int-value: $&#123;random.int&#125; random-int-range-value: $&#123;random.int(2)&#125; random-long-value: $&#123;random.long&#125; random-long-range-value: $&#123;random.long(1,3)&#125; random-uuid-value: $&#123;random.uuid&#125; random-str-value: $&#123;random.whatever&#125; 12345678910111213141516171819@Component@ConfigurationProperties(\"random-seed\")public class RandomSeedConfig &#123; private int randomIntValue; private int randomIntRangeValue; private long randomLongValue; private long randomLongRangeValue; private String randomUuidValue; private String randomStrValue; // getters and setters &#125; 6. @PropertySource使用@PropertySource注解可以声明当前所使用的具体属性文件： 123456789101112@Component@PropertySource(\"jdbc.properties\")@ConfigurationProperties(\"jdbc\")public class JdbcConfig &#123; private String username; private String password; // getters and setters &#125; src/main/resources/jdbc.properties配置示例： 12jdbc.username = rootjdbc.password = root@123321 7. 命令行参数123456789@Componentpublic class CommandLineConfig &#123; @Value(\"$&#123;command-line-arg&#125;\") private String commandLineArg; // getters and setters &#125; 在命令行中，通过-D参数名称=参数的值进行配置： 1$ java -jar -Dcommand-line-arg=\"今天天气不错\" spring-boot-properties-sample-0.0.1-SNAPSHOT.jar 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-properties-sample参考文档文献链接：spring-boot-features-profiles","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Thymeleaf 教程","date":"2017-04-03T18:32:29.000Z","path":"post/thymeleaf.html","text":"Thymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择。 1. 创建模板文件创建一个 HTML 模板文件： 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Index Page&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 通过&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;引入 Thymeleaf 命名空间。th:text用于处理p标签体的文本内容。该模板文件直接在任何浏览器中正确显示，浏览器会自动忽略它们不能理解的属性th:text。但这不是一个真正有效的 HTML5 文档，因为 HTML5 规范是不允许使用th:*这些非标准属性的。我们可以切换到 Thymeleaf 的data-th-*语法，以此来替换th:*语法： 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Index Page&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;p data-th-text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML5 规范是允许data-*这样自定义的属性的。th:*和data-th-*这两个符号是完全等效且可以互换的。但为了简单直观和代码的紧凑性，本文采用th:*的表示形式。 2. 标准表达式语法Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类： 简单表达式 字面值 文本操作 算术运算 布尔运算 比较和相等 条件运算 无操作符 2.1 简单表达式 语法 名称 描述 作用 ${…} Variable Expressions 变量表达式 取出上下文变量的值 *{…} Selection Variable Expressions 选择变量表达式 取出选择的对象的属性值 #{…} Message Expressions 消息表达式 使文字消息国际化，I18N @{…} Link URL Expressions 链接表达式 用于表示各种超链接地址 ~{…} Fragment Expressions 片段表达式 引用一段公共的代码片段 2.1.1 ${…}1234567@GetMapping(\"/standard-expression-syntax/variables\")public String variables(ModelMap model, HttpSession session) &#123; model.put(\"now\", new Date()); model.put(\"message\", \"Welcome to BeiJing!\"); session.setAttribute(\"user\", new User(\"fanlychie\", \"男\", 24)); ... ...&#125; 通过变量表达式${}取出上下文环境中的message变量： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; 它相当于： 1ctx.getVariable(\"message\"); 2.1.2 *{…}变量表达式${}是面向整个上下文的，而选择变量表达式*{}的上下文是父标签（th:object）所选择的对象： 12345&lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p th:text=\"*&#123;name&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"*&#123;sex&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"*&#123;age&#125;\"&gt;&lt;/p&gt;&lt;/div&gt; 它相当于： 12345&lt;div&gt; &lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;session.user.sex&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;session.user.age&#125;\"&gt;&lt;/p&gt;&lt;/div&gt; 如果对象没有被选择，那么，*{}和${}表达式所达到的效果是完全相同的： 12&lt;p th:text=\"*&#123;session.user.name&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; 2.1.3 #{…}消息表达式可用于国际化文字信息。首先我们来了解一下 i18n 资源文件的命名规则： basename.properties basename_language.properties basename_language_country.properties basename是自定义的资源文件名称，language和country必须是 Java 支持的语言和国家。basename.properties是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。 创建文件src/main/resources/messages.properties 1welcome.message = 北京欢迎你！ 创建文件src/main/resources/messages_en_US.properties 1welcome.message = Welcome to BeiJing! 在 IntelliJ IDEA 编辑视图： messages是 Spring Boot 加载资源文件默认采用的名称（basename），如果你所使用的资源文件名称不是以messages命名或所使用的资源文件不是在src/main/resources根目录，你可以通过spring.messages.basename属性来做具体的配置。如，资源文件messages.properties和messages_en_US.properties假设它们所在的目录位置是src/main/resources/i18n。 application.properties 配置示例： 1spring.messages.basename:i18n/messages application.yml 配置示例： 123spring messages basename: i18n/messages 静态文本消息示例： 12&lt;!-- 北京欢迎你！ --&gt;&lt;p th:text=\"#&#123;welcom.message&#125;\"&gt;&lt;/p&gt; 消息表达式#{}是不允许直接处理非静态的文本消息的，但是你可以在资源文件中通过使用占位符{}来处理非静态的文本消息： messages.properties 配置示例： 1welcome.user.message = &#123;0&#125;, 北京欢迎你！ messages_en_US.properties 配置示例： 1welcome.user.message = &#123;0&#125;, Welcome to BeiJing! 非静态文本消息，以参数的形式传递变量的值： 12&lt;!-- fanlychie, 北京欢迎你！ --&gt;&lt;p th:text=\"#&#123;welcome.user.message($&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt; 2.1.4 @{…}链接表达式@{}是专门用来处理 URL 链接地址的。 绝对地址示例： 12&lt;!-- https://fanlychie.github.io --&gt;&lt;p th:text=\"@&#123;https://fanlychie.github.io&#125;\"&gt;&lt;/p&gt; 页面相对地址示例： 12&lt;!-- commons/base.html --&gt;&lt;p th:text=\"@&#123;commons/base.html&#125;\"&gt;&lt;/p&gt; 上下文相对地址（相对于当前的服务）示例： 12&lt;!-- /css/mian.css --&gt;&lt;p th:text=\"@&#123;/css/mian.css&#125;\"&gt;&lt;/p&gt; 服务器相对地址（相对于部署在同一个服务器中的不同服务）示例： 12&lt;!-- /image/upload --&gt;&lt;p th:text=\"@&#123;~/image/upload&#125;\"&gt;&lt;/p&gt; 参数使用示例： 12345678&lt;!-- /css/mian.css?v=1.0 --&gt;&lt;p th:text=\"@&#123;/css/mian.css(v=1.0)&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/order?username=fanlychie --&gt;&lt;p th:text=\"@&#123;/user/order(username=$&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/order?username=fanlychie&amp;status=PAIED --&gt;&lt;p th:text=\"@&#123;/user/order(username=$&#123;session.user.name&#125;,status='PAIED')&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/fanlychie/info --&gt;&lt;p th:text=\"@&#123;/user/&#123;username&#125;/info(username=$&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt; 2.1.5 ~{…}片段表达式~{}可以用来引用一段公共的 HTML 代码片段。 语法 描述 ~{templatename} 引用整个模板文件的代码片段 ~{templatename :: selector} selector 可以是 th:fragment 指定的名称或其他选择器。如类选择器、ID选择器等 ~{::selector} 相当于 ~{this :: selector}，表示引用当前模板定义的代码片段 在 Thymeleaf 模板文件中，你可以使用th:fragment属性来定义一段公共的代码片段，然后你可以通过使用th:insert、th:replace、th:include（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。 src/main/resources/templates/base.html，通过th:fragment属性定义一段公共的代码片段： 1&lt;div id=\"footer\" th:fragment=\"footerFragment\"&gt;&amp;copy; 2017 fanlychie&lt;/div&gt; src/main/resources/templates/index.html，通过th:insert属性引用一段公共的代码片段： 1&lt;div th:insert=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; 其中，~{}是可选的，我们可以去掉这层的包裹： 1&lt;div th:insert=\"base :: footerFragment\"&gt;&lt;/div&gt; 若 index.html 与 base.html 不在同级目录，如 templates/commons/base.html： 1&lt;div th:insert=\"~&#123;commons/base :: footerFragment&#125;\"&gt;&lt;/div&gt; 使用th:fragment属性定义代码片段时，你还可以声明一组参数： 123456789&lt;div th:fragment=\"crumbs(parent, child)\"&gt; &lt;i th:text=\"$&#123;parent&#125;\"&gt;&lt;/i&gt; &lt;i th:text=\"$&#123;child&#125;\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;!--&lt;i&gt;用户中心&lt;/i&gt;&lt;i&gt;我的订单&lt;/i&gt;--&gt;&lt;div th:insert=\"::crumbs('用户中心', '我的订单')\"&gt;&lt;/div&gt; 此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段： 1&lt;div th:insert=\"~&#123;base :: #footer&#125;\"&gt;&lt;/div&gt; 除了th:insert属性th:replace也可以用来引用公共的代码片段。不同的是，th:insert是直接将代码片段插入到标签体内，而th:replace则是用代码片段直接替换标签体内容。 1234567891011&lt;!--&lt;div&gt; &lt;div id=\"footer\"&gt;© 2017 fanlychie&lt;/div&gt;&lt;/div&gt;--&gt;&lt;div th:insert=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; &lt;!--&lt;div id=\"footer\"&gt;© 2017 fanlychie&lt;/div&gt;--&gt;&lt;div th:replace=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; 2.1.6 内置对象 对象 描述 #ctx 上下文对象 #vars 同 #ctx，表示上下文变量 #locale 上下文本地化（特定的地理区域）变量，可参考 java.util.Locale #request HttpServletRequest 对象，可参考 javax.servlet.http.HttpServletRequest #response HttpServletResponse 对象，可参考 javax.servlet.http.HttpServletResponse #session HttpSession 对象，可参考 javax.servlet.http.HttpSession #servletContext ServletContext 对象，可参考 javax.servlet.ServletContext #ctx示例： 123456&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#ctx.getLocale()&#125;\"&gt;&lt;/p&gt;&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;#ctx.getVariable('message')&#125;\"&gt;&lt;/p&gt;&lt;!-- true --&gt;&lt;p th:text=\"$&#123;#ctx.containsVariable('message')&#125;\"&gt;&lt;/p&gt; #vars示例： 123456&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#vars.getLocale()&#125;\"&gt;&lt;/p&gt;&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;#vars.getVariable('message')&#125;\"&gt;&lt;/p&gt;&lt;!-- true --&gt;&lt;p th:text=\"$&#123;#vars.containsVariable('message')&#125;\"&gt;&lt;/p&gt; #locale示例： 123456789101112&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#locale&#125;\"&gt;&lt;/p&gt;&lt;!-- CN --&gt;&lt;p th:text=\"$&#123;#locale.country&#125;\"&gt;&lt;/p&gt;&lt;!-- 中国 --&gt;&lt;p th:text=\"$&#123;#locale.displayCountry&#125;\"&gt;&lt;/p&gt;&lt;!-- zh --&gt;&lt;p th:text=\"$&#123;#locale.language&#125;\"&gt;&lt;/p&gt;&lt;!-- 中文 --&gt;&lt;p th:text=\"$&#123;#locale.displayLanguage&#125;\"&gt;&lt;/p&gt;&lt;!-- 中文 (中国) --&gt;&lt;p th:text=\"$&#123;#locale.displayName&#125;\"&gt;&lt;/p&gt; #request示例： 12345678910111213141516171819202122&lt;!-- HTTP/1.1 --&gt;&lt;p th:text=\"$&#123;#request.protocol&#125;\"&gt;&lt;/p&gt;&lt;!-- http --&gt;&lt;p th:text=\"$&#123;#request.scheme&#125;\"&gt;&lt;/p&gt;&lt;!-- localhost --&gt;&lt;p th:text=\"$&#123;#request.serverName&#125;\"&gt;&lt;/p&gt;&lt;!-- 8080 --&gt;&lt;p th:text=\"$&#123;#request.serverPort&#125;\"&gt;&lt;/p&gt;&lt;!-- GET --&gt;&lt;p th:text=\"$&#123;#request.method&#125;\"&gt;&lt;/p&gt;&lt;!-- /standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.requestURI&#125;\"&gt;&lt;/p&gt;&lt;!-- http://localhost:8080/standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.requestURL&#125;\"&gt;&lt;/p&gt;&lt;!-- /standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.servletPath&#125;\"&gt;&lt;/p&gt;&lt;!-- java.util.Collections$3@203646fe --&gt;&lt;p th:text=\"$&#123;#request.parameterNames&#125;\"&gt;&lt;/p&gt;&lt;!-- &#123;q=[Ljava.lang.String;@3308c69f&#125; --&gt;&lt;p th:text=\"$&#123;#request.parameterMap&#125;\"&gt;&lt;/p&gt;&lt;!-- q=expression --&gt;&lt;p th:text=\"$&#123;#request.queryString&#125;\"&gt;&lt;/p&gt; 注意，请求地址的 URL 参数直接通过#request.x是取不出来的，需要使用param.x语法来取出。如，URL：/standard-expression-syntax/variables?q=expression，取出 q 参数的正确姿势： 1&lt;p th:text=\"$&#123;param.q&#125;\"&gt;&lt;/p&gt; #response示例： 12345678&lt;!-- 200 --&gt;&lt;p th:text=\"$&#123;#response.status&#125;\"&gt;&lt;/p&gt;&lt;!-- 8192 --&gt;&lt;p th:text=\"$&#123;#response.bufferSize&#125;\"&gt;&lt;/p&gt;&lt;!-- UTF-8 --&gt;&lt;p th:text=\"$&#123;#response.characterEncoding&#125;\"&gt;&lt;/p&gt;&lt;!-- text/html;charset=UTF-8 --&gt;&lt;p th:text=\"$&#123;#response.contentType&#125;\"&gt;&lt;/p&gt; #session示例： 123456&lt;!-- 2BCB2A0EACFF2D9D249D9799431B5127 --&gt;&lt;p th:text=\"$&#123;#session.id&#125;\"&gt;&lt;/p&gt;&lt;!-- 1499786693244 --&gt;&lt;p th:text=\"$&#123;#session.lastAccessedTime&#125;\"&gt;&lt;/p&gt;&lt;!-- fanlychie --&gt;&lt;p th:text=\"$&#123;#session.getAttribute('user').name&#125;\"&gt;&lt;/p&gt; 注意，放到会话里面的对象直接通过#session.x是取不出来的，需要使用session.x语法来取出。如，取出会话里面的 user 对象的正确姿势： 1&lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; 2.1.7 工具类 对象 描述 #messages 消息工具类，与 ＃{…} 作用相同 #uris 地址相关的工具类 #conversions 对象转换工具类 #dates 日期时间工具类 #calendars 日历工具类 #numbers 数字工具类 #strings 字符串工具类 #objects 对象工具类 #bools 布尔工具类 #arrays 数组工具类 #lists List 工具类 #sets Set 工具类 #maps Map 工具类 1234&lt;!-- false --&gt;&lt;p th:text=\"$&#123;#strings.isEmpty(message)&#125;\"&gt;&lt;/p&gt;&lt;!-- 2017-07-12 00:37:25 --&gt;&lt;p th:text=\"$&#123;#dates.format(now, 'yyyy-MM-dd HH:mm:ss')&#125;\"&gt;&lt;/p&gt; 2.2 字面值所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：18、&#39;welcome&#39;等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。 2.2.1 文字字面值文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义： 1234&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"'Welcome to BeiJing!'\"&gt;&lt;/p&gt;&lt;!-- 'Welcome to BeiJing!' --&gt;&lt;p th:text=\"'\\'Welcome to BeiJing!\\''\"&gt;&lt;/p&gt; 2.2.2 数字字面值1234&lt;!-- 2017 --&gt;&lt;p th:text=\"2017\"&gt;&lt;/p&gt;&lt;!-- 2018 --&gt;&lt;p th:text=\"2017 + 1\"&gt;&lt;/p&gt; 2.2.3 布尔字面值1234&lt;!-- false --&gt;&lt;p th:text=\"1 &gt; 2\"&gt;&lt;/p&gt;&lt;!-- 否 --&gt;&lt;p th:text=\"1 &gt; 2 ? '是' : '否'\"&gt;&lt;/p&gt; 2.2.4 空字面值12&lt;!-- false --&gt;&lt;p th:text=\"$&#123;user == null&#125;\"&gt;&lt;/p&gt; 2.2.5 字面令牌字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）： 大写或小写的字母、中文等不含空格和特殊符号的文本 0 到 9 的数字 中括号 下划线 连字符（-） 点符号（.） 实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉： 1&lt;p th:text=\"Welcome to BeiJing!\"&gt;&lt;/p&gt; 它等效于： 1&lt;p th:text=\"'Welcome to BeiJing!'\"&gt;&lt;/p&gt; 2.3 文本操作我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换。 2.3.1 字符串连接不管是字面值还是表达式的结果，我们都可以使用+符号将它们连接起来： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"'Welcome to ' + $&#123;location&#125; + '!'\"&gt;&lt;/p&gt; 2.3.2 字面值替换符号||可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用+连接符： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"|Welcome to $&#123;location&#125;!|\"&gt;&lt;/p&gt; 2.4 算术运算支持+（加）、-（减）、*（乘）、/（除）、%（模）运算： 1234567891011121314&lt;!-- 6 --&gt;&lt;p th:text=\"4 + 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"4 - 2\"&gt;&lt;/p&gt;&lt;!-- 8 --&gt;&lt;p th:text=\"4 * 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"4 / 2\"&gt;&lt;/p&gt;&lt;!-- 0 --&gt;&lt;p th:text=\"4 % 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"$&#123;pagination.page + 1&#125;\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"$&#123;pagination.page&#125; + 1\"&gt;&lt;/p&gt; 2.5 布尔运算支持and（且）、or（或）、!（非）、not（非）运算： 1234&lt;p th:text=\"$&#123;user.online and user.vip&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.online or user.vip&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;!user.online&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;not user.online&#125;\"&gt;&lt;/p&gt; 2.6 比较和相等支持&lt;（lt）、&gt;（gt）、&lt;=（le）、&gt;=（ge）、==（eq）、！=（ne）： 123456&lt;p th:text=\"$&#123;user.age &lt; 60&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &lt;= 60&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &gt; 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &gt;= 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age == 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age != 18&#125;\"&gt;&lt;/p&gt; 2.7 条件运算三元运算符：(if) ? (then) : (else) 12&lt;p th:text=\"$&#123;user.online ? '在线' : '离线'&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.online ? (user.vip ? 'VIP用户在线' : '普通用户在线') : '离线'&#125;\"&gt;&lt;/p&gt; 二元运算符：(value) ?: (defaultValue)。 其中，value非空（null）即真，条件为真时输出value，否则输出defaultValue。假设token = null，user.email = fanlychie@gmail.com 1234&lt;!-- 你还没有登录，请先登录 --&gt;&lt;p th:text=\"$&#123;token&#125; ?: '你还没有登录，请先登录'\"&gt;&lt;/p&gt;&lt;!-- fanlychie@gmail.com --&gt;&lt;p th:text=\"$&#123;user.email&#125; ?: '你还没有绑定邮箱'\"&gt;&lt;/p&gt; 2.8 无操作符当模板运行在服务器端时，Thymeleaf 会解析th:*属性的具体值替换标签体的内容。无操作符（_）则允许你使用原型标签体的内容作为默认值： 12&lt;!-- 你还没有登录，请先登录 --&gt;&lt;p th:text=\"$&#123;token&#125; ?: _\"&gt;你还没有登录，请先登录&lt;/p&gt; 3. 使用文本首先介绍两个最基础的th:*属th:text和th:utext，它们都是用于处理文本消息内容。 3.1 th:text在标签体中展示表达式评估结果的文本内容： 1&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; 使用外部化的文本内容： 1&lt;p th:text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt; 当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的th:text属性，而显示&lt;p&gt;标签体的文本内容Welcome to BeiJing! 当它作为模板文件运行在服务器端时，th:text属性的具体值将会替换&lt;p&gt;标签体的文本内容。 3.2 th:utext属性th:utext与th:text的区别在于： th:text默认会对含有 HTML 标签的内容进行字符转义； th:utext（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义； 假设：message = &quot;&lt;b&gt;Welcome to BeiJing!&lt;/b&gt;&quot;。 使用th:text属性： 1&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; th:text效果：&lt;b&gt;Welcome to BeiJing!&lt;/b&gt; 使用th:utext属性： 1&lt;p th:utext=\"$&#123;message&#125;\"&gt;&lt;/p&gt; th:utext效果：Welcome to BeiJing! 4. 设置属性值在 Thymeleaf 模板文件中，你可以使用th:*（或者使用th:attr属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以th:*-*来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用th:attrappend和th:attrprepend来追加新的值到现有的标签属性值中。 4.1 th:attr这种方式是不被推荐的，了解一下就行。下面是用th:attr=&quot;href=...&quot;来设置标签href属性的值： 1&lt;a th:attr=\"href=@&#123;https://www.google.com.hk&#125;\"&gt;谷歌一下你就知道&lt;/a&gt; 4.2 th:*显然th:attr=&quot;href=@{http://www.baidu.com}&quot;不够简洁，我们更推荐下面的这种语法： 1&lt;a th:href=\"@&#123;https://www.google.com.hk&#125;\"&gt;谷歌一下你就知道&lt;/a&gt; 其中th:*中的*可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的： 12&lt;!-- &lt;div item-id=\"1001\"&gt;Welcome to BeiJing!&lt;/div&gt; --&gt;&lt;div th:item-id=\"$&#123;user.id&#125;\"&gt;Welcome to BeiJing!&lt;/div&gt; 4.3 th:*-*如果想要同时为标签的多个不同属性设置相同的一个值，可以使用th:*-*的语法： 1&lt;img src=\"logo.png\" th:alt-title=\"LOGO图片\"&gt; 它相当于： 1&lt;img src=\"logo.png\" th:alt=\"LOGO图片\" th:title=\"LOGO图片\"&gt; 4.4 th:attrappend &amp; th:attrprependth:attrappend和th:attrprepend可以将表达式的结果分别追加到指定的属性值之后和之前。 1234&lt;!-- &lt;button class=\"btn enable\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:attrappend=\"class=$&#123;outOfStock&#125; ? ' enable' : ' disable'\"&gt;购买&lt;/button&gt;&lt;!-- &lt;button class=\"enable btn\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:attrprepend=\"class=$&#123;outOfStock&#125; ? 'enable ' : 'disable '\"&gt;购买&lt;/button&gt; 另外，还有两个常用的具体附加属性th:classappend=&quot;...&quot;和th:styleappend=&quot;&quot;。 它们分别用来代替th:attrappend=&quot;class=...&quot;和th:attrappend=&quot;style=...&quot;。 12&lt;!-- &lt;button class=\"btn enable\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:classappend=\"$&#123;outOfStock&#125; ? ' enable' : ' disable'\"&gt;购买&lt;/button&gt; 4.5 布尔属性在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如readonly、checked、selected等。它们若存在那就意味着值为 true。 12345678910&lt;input type=\"checkbox\" name=\"rememberme\" checked /&gt; 记住我&lt;input type=\"radio\" name=\"sex\" value=\"male\" checked&gt; 男&lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt; 女&lt;input type=\"text\" name=\"appId\" value=\"J123654\" readonly&gt;&lt;select&gt; &lt;option selected&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt;&lt;/select&gt; Thymeleaf 也允许我们通过th:*（这里的*表示任意的布尔属性） 来选择是否使用这些布尔属性。 1&lt;input type=\"checkbox\" name=\"rememberme\" ch:checked=\"$&#123;rememberme&#125;\" /&gt; 记住我 正如你所见，如果表达式的结果为true，则自动勾选复选框，若为false，则不会自动勾选。 5. 遍历遍历（迭代）的语法th:each=&quot;自定义的元素变量名称 : ${集合变量名称}&quot;： 123456&lt;div&gt; &lt;spn&gt;你所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 属性th:each提供了一个用于跟踪迭代的状态变量，它包含以下几个属性： 属性 类型 描述 index int 当前迭代的索引，从 0 开始 count int 当前迭代的计数，从 1 开始 size int 集合中元素的总个数 current int 当前的元素对象 even boolean 当前迭代的计数是否是偶数 odd boolean 当前迭代的计数是否是奇数 first boolean 当前元素是否是集合的第一个元素 last boolean 当前元素是否是集合的最后一个元素 状态变量的使用语法：th:each=&quot;自定义的元素变量名称, 自定义的状态变量名称 : ${集合变量名称}&quot;： 123456&lt;div&gt; &lt;spn&gt;所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city, status : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\" th:item-index=\"$&#123;status.count&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 不管什么时候，Thymeleaf 始终会为每个th:each创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加Stat字符串组成： 123456&lt;div&gt; &lt;spn&gt;所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\" th:item-index=\"$&#123;cityStat.count&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 6. 条件判断条件判断语句有三种，分别是：th:if、th:unless、th:swith。 6.1 th:if当表达式的评估结果为真时则显示内容，否则不显示： 1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:if=\"$&#123;user != null&#125;\"&gt;我的订单&lt;/a&gt; 真假评估的依据： 当表达式的值不为空（null）时 如果表达式的值是一个布尔类型，且值为true评估为真，否则为假 如果表达式的值是一个数字类型，且值为非0评估为真，否则为假 如果表达式的值是一个字符类型，且值为非0评估为真，否则为假 如果表达式的值是一个字符串类型，且值为非&quot;false&quot;、&quot;off&quot;、&quot;no&quot;评估为真，否则为假 如果表达式的值不是一个布尔、数字、字符或字符串评估为真 当表达式的值为空（null）时，评估结果为假 因此，上面代码我们也可以简写成： 1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:if=\"$&#123;user&#125;\"&gt;我的订单&lt;/a&gt; 但是，为了代码的可读性，我们并不建议这样使用。 6.2 th:unlessth:unless与th:if判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示： 1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:unless=\"$&#123;user == null&#125;\"&gt;我的订单&lt;/a&gt; 6.3 th:swith多路选择语句，它需要搭配th:case来使用： 1234&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt; 7. 定义局部变量使用th:with属性可以定义局部变量： 123&lt;p th:with=\"name='fanlychie'\"&gt; &lt;span th:text=\"$&#123;name&#125;\"&gt;&lt;/span&gt;&lt;/p&gt; 同时定义多个局部变量时，用英文,号分隔开： 123&lt;p th:with=\"name=$&#123;user.name&#125;,age=&#123;user.age&#125;\"&gt; ......&lt;/p&gt; 8. 注释下面介绍常见的两种注释： 8.1 标准注释语法：&lt;!-- ... ---&gt;，注释的代码块会在文件源代码中显示出来。 8.1.1 单行注释1&lt;!-- &lt;span&gt;$&#123;message&#125;&lt;/span&gt; ---&gt; 8.1.2 多行注释123456&lt;!--&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt;---&gt; 8.2 解析器级注释语法：&lt;!--/* ... */--&gt;，注释的代码块会在引擎解析的时候抹去。 8.2.1 单行注释：1&lt;!--/* &lt;span&gt;$&#123;message&#125;&lt;/span&gt; */--&gt; 8.2.2 多行注释123456&lt;!--/*--&gt;&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt;&lt;!--*/--&gt; 9. 内联表达式内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用th:*标签属性。 9.1 [[…]][[]]相当于th:text，对含有 HTML 标签的内容自动进行字符转义。 1&lt;p&gt;The message is : [[$&#123;htmlContent&#125;]]&lt;/p&gt; 9.2 [(…)][()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义。 1&lt;p&gt;The message is : [($&#123;htmlContent&#125;)]&lt;/p&gt; 9.3 th:inline我们已经了解到，使用[[]]和[()]语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用th:inline属性来激活，它的取值如下： 值 描述 none 禁止内联表达式，可以原样输出 [[]] 和 [()] 字符串 text 文本内联，可以使用 th:each 等高级语法 css 样式内联，如：&lt;style th:inline=&quot;css&quot;&gt; javascript 脚本内联，如：&lt;style th:inline=&quot;javascript&quot;&gt; 9.3.1 none12&lt;!-- [[1, 2], [3, 4]] --&gt;&lt;p th:inline=\"none\"&gt;[[1, 2], [3, 4]]&lt;/p&gt; 9.3.2 text123456&lt;!-- 北京 上海 广州 深圳 --&gt;&lt;p th:inline=\"text\"&gt; [# th:each=\"city : $&#123;cities&#125;\"] [($&#123;city.name&#125;)] [/]&lt;/p&gt; 9.3.3 css12345&lt;style th:inline=\"css\"&gt; body &#123; background-color:[[$&#123;bgColor&#125;]]; &#125;&lt;/style&gt; 9.3.4 javascript1234&lt;script th:inline=\"javascript\"&gt; var user = [[$&#123;user&#125;]]; alert(\"用户名：\" + user.name);&lt;/script&gt; 参考文档文献链接：http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html","tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://yoursite.com/tags/Thymeleaf/"}]},{"title":"Spring Boot 添加 Thymeleaf 支持","date":"2017-04-03T06:44:53.000Z","path":"post/spring-boot-with-thymeleaf.html","text":"Spring Boot 对 Thymeleaf 模板引擎提供了自配置的良好支持。Spring Boot 1.5.2.RELEASE 版本默认使用的是 Thymeleaf 2.0+，本文使用 Thymeleaf 3.0+ 版本，在 pom.xml 中添加以下声明： 1234&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.5.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 然后添加 Thymeleaf 依赖声明： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1. 控制器12345678910@Controllerpublic class WelcomeController &#123; @GetMapping(\"/\") public String welcome(ModelMap model) &#123; model.put(\"message\", \"Hello Thymeleaf!\"); return \"index\"; &#125; &#125; 2. 模板文件Spring Boot 对 Thymeleaf 模板引擎提供了自动配置的支持，详见 ThymeleafProperties。我们只需遵循约定，在/src/main/resources/templates/目录创建相应的页面模板文件（*.html）即可。 # src/main/resources/templates/index.html1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@&#123;/css/main.css&#125;\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text=\"$&#123;message&#125;\"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3. 静态文件Spring Boot 默认将静态资源文件映射到类路径下的目录包括（详见 ResourcesProperties）： /META-INF/resources/ /resources/ /static/ /public/ 因此我们可以将 css、js、images 等静态资源文件放在/src/main/resources/static/目录下。 # src/main/resources/static/css/main.css123456789body &#123; padding: 0; color: #444; width: 280px; margin: 100px auto; font-family: SimSun; background-color: #FBFBFB; text-shadow: rgba(50,50,50,0.3) 2px 2px 3px;&#125; 4. 主应用程序类12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 5. 模板文件和静态资源文件的缓存问题当修改 css、js 等静态资源文件的内容或模板文件的内容时，刷新客户端浏览器，发现内容还是老的，说明 Spring Boot 内置的 Servelt 容器并没有实时重新加载修改过的文件内容。你只能在每次修改静态资源文件时，虽然不需要重启服务，但是你要重新编译一次，IntelliJ IDEA 中按一次 Ctrl + F9 即可。实现热加载（live reload）可参考：解决 IntelliJ IDEA 无法热加载 Spring Boot 模板文件和静态资源文件 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-thymeleaf-sample参考文档文献链接：howto-use-thymeleaf-3、usingthymeleaf","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"解决 IntelliJ IDEA 无法热加载 Spring Boot 模板文件和静态资源文件","date":"2017-04-02T20:24:50.000Z","path":"post/resolve-intellij-idea-spring-boot-template-reload-is-not-working.html","text":"1. IntelliJ IDEA 配置快捷键Ctrl + Alt + S打开设置面板，勾选Build project automatically选项： 快捷键Ctrl + Shift + A查找registry命令： 在查找到的registry命令通过鼠标双击或敲回车键，在弹出的面板中搜索关键字automake，找到并勾选compiler.automake.allow.when.app.running选项： 配置完成后，IntelliJ IDEA 可以热加载静态资源文件了。但是模板文件仍然还不能热加载。 2. 添加 Spring Boot Dev Tools 支持在 pom.xml 中添加如下依赖声明： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; Spring Boot Dev Tools 的作用： 视图或资源的任何更改都可以直接在浏览器中看到，无需重新启动，只需刷新浏览器即可。 对代码的任何更改将自动重新启动 Spring 容器。 至此，就可以完美的解决 IntelliJ IDEA 无法热加载模板文件和静态资源文件的问题了。并且，当你修改或编写 Java 代码时，也是能够热加载的。","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 添加 JSP 支持","date":"2017-04-02T14:13:29.000Z","path":"post/spring-boot-with-jsp.html","text":"Spring MVC 支持多种模板技术，如 JSP、FreeMarker、Thymeleaf 等。Spring Boot 官方并不推荐使用 JSP 模板引擎，如果有可能，应尽量避免使用 JSP，因为当使用嵌入式 Servlet 容器时，对使用 JSP 模板引擎有几个已知的限制，以下是 Spring Boot 支持自动配置的模板引擎（其中并不包含 JSP）： FreeMarker Groovy Thymeleaf Mustache 在 pom.xml 配置文件中添加内嵌 Tomcat 容器依赖，scope 声明为 provided： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 在 pom.xml 配置文件中添加 JSP 编译依赖，否则启动报错： 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; packaging 一定要声明为 war 类型，否则打包运行出错，完整配置： 1234567891011121314151617181920212223242526272829303132333435363738&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-jsp-sample&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-jsp-sample&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 1. 控制器12345678910@Controllerpublic class WelcomeController &#123; @GetMapping(\"/\") public String welcome(ModelMap model) &#123; model.put(\"message\", \"Hello JSP!\"); return \"index\"; &#125; &#125; 2. 主应用程序类12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 3. 配置文件在 Spring Boot 中使用 JSP 模板引擎有几个已知的限制，Spring Boot 对 JSP 模板引擎没有提供自动配置的支持，你需要手工配置视图模板文件信息。application.yml 配置示例： 1234567spring: main: banner-mode: 'off' mvc: view: prefix: /WEB-INF/pages/ suffix: .jsp 4. 模板文件src/main/webapp/WEB-INF/pages/index.jsp 12345678910&lt;%@ page pageEncoding=\"UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;欢迎页&lt;/title&gt; &lt;link href=\"/css/main.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;$&#123;message&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 5. 静态文件Spring Boot 默认将静态资源文件映射到类路径下的目录包括（详见 ResourcesProperties）： /META-INF/resources/ /resources/ /static/ /public/ 因此我们可以将 css、js、images 等静态资源文件放在/src/main/resources/static/目录下。 # src/main/resources/static/css/main.css123456789body &#123; padding: 0; color: #444; width: 280px; margin: 100px auto; font-family: SimSun; background-color: #FBFBFB; text-shadow: rgba(50,50,50,0.3) 2px 2px 3px;&#125; 6. 模板文件和静态资源文件的缓存问题当修改 css、js 等静态资源文件的内容或模板文件的内容时，刷新客户端浏览器，发现内容还是老的，说明 Spring Boot 内置的 Servelt 容器并没有实时重新加载修改过的文件内容。你只能在每次修改静态资源文件时，虽然不需要重启服务，但是你要重新编译一次，IntelliJ IDEA 中按一次 Ctrl + F9 即可。实现热加载（live reload）可参考：解决 IntelliJ IDEA 无法热加载 Spring Boot 模板文件和静态资源文件 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-jsp-sample","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 快速入门 - 1 分钟搭建 Web 应用","date":"2017-04-02T05:02:06.000Z","path":"post/spring-boot-quick-start.html","text":"Spring Boot 不是一个新的框架，它是提供一种使我们更易于创建基于 Spring 的最小或零配置的独立应用和服务的方式。 Spring 对于 Java 开发者来说一定都并不陌生，它作为目前非常流行的一个 Java 应用开发的基础框架，应用非常广泛。然而，由于其配置繁杂，各样格式的XML配置文件，着实让人头疼。 Spring Boot 的出现，可以让我们只需要非常简单的几步就可以搭建起一个基于 Sprign 框架的 Web 应用程序。Spring Boot的主要目标： 为所有的Spring开发提供一个更快，更广泛的入门体验。 开箱即用，以最小或零配置的方式，使我们更专注于解决应用程序的功能需求。 提供一些非功能性的常见的大型项目类特性（如内嵌服务器、安全、度量、健康检查、外部化配置）。 绝对没有代码生成，也不需要XML配置，可以完全避免XML配置 为了避免定义更多的注释配置（它将一些现有的 Spring 框架注释组合成一个简单的单个注释） 提供一些默认值，以便在任何时间内快速启动新项目。 1. 项目依赖1234567891011121314151617181920212223242526272829&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-quick-start&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-quick-start&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2. 控制器123456789@RestControllerpublic class HelloWorldController &#123; @GetMapping(\"/\") public String sayHello() &#123; return \"Hello, Spring Boot!\"; &#125; &#125; 3. 主应用程序类Spring Boot 建议我们将主应用程序类置于其他类之上的根包名之下。这样就相当于隐式的的定义了注解扫描的基础搜索包名，而不需要指定 scanBasePackages 属性。 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 4. 运行直接运行 Application 中的 main 方法： 12345678910111213141516171819202122232425262728293031 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)2017-04-02 13:02:06.791 INFO 7188 --- [ main] org.fanlychie.Application : Starting Application on FANLYCHIE-PC with PID 7188 (F:\\dev\\workspace\\idea\\spring-boot-hello-world\\target\\classes started by fanlychie in F:\\dev\\workspace\\idea\\spring-boot-hello-world)2017-04-02 13:02:06.793 INFO 7188 --- [ main] org.fanlychie.Application : No active profile set, falling back to default profiles: default2017-04-02 13:02:06.844 INFO 7188 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@50de0926: startup date [Sun Apr 02 13:02:06 CST 2017]; root of context hierarchy2017-04-02 13:02:08.030 INFO 7188 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-04-02 13:02:08.041 INFO 7188 --- [ main] o.apache.catalina.core.StandardService : Starting service Tomcat2017-04-02 13:02:08.042 INFO 7188 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.112017-04-02 13:02:08.121 INFO 7188 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-04-02 13:02:08.122 INFO 7188 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1284 ms2017-04-02 13:02:08.254 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: 'dispatcherServlet' to [/]2017-04-02 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'characterEncodingFilter' to: [/*]2017-04-02 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]2017-04-02 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'httpPutFormContentFilter' to: [/*]2017-04-02 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'requestContextFilter' to: [/*]2017-04-02 13:02:08.502 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@50de0926: startup date [Sun Apr 02 13:02:06 CST 2017]; root of context hierarchy2017-04-02 13:02:08.597 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/],methods=[GET]&#125;\" onto public java.lang.String org.fanlychie.controller.HelloWorldController.sayHello()2017-04-02 13:02:08.599 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/error]&#125;\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-04-02 13:02:08.599 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/error],produces=[text/html]&#125;\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-04-02 13:02:08.624 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-02 13:02:08.624 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-02 13:02:08.661 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-02 13:02:08.826 INFO 7188 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-04-02 13:02:08.866 INFO 7188 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-04-02 13:02:08.869 INFO 7188 --- [ main] org.fanlychie.Application : Started Application in 2.338 seconds (JVM running for 2.673) 打开 Terminal 视图，键入：curl -i -X GET http://localhost:8080/ 还没安装 CURL？赶快来试试吧：https://curl.haxx.se/download.html 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-quick-start-sample","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"JPA 多对多注解","date":"2017-02-18T13:03:10.000Z","path":"post/jpa-many-to-many-annotation.html","text":"@ManyToMany 是属性或方法级别的注解，用于定义源实体与目标实体是多对多的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的集合类型的泛型的参数化类型。 mappedBy String 用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn 互斥，如果标注了 @JoinColumn 注解，不需要再定义此参数）。 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据。 1. 多对多单向外键关联123456789101112@Entity(name = \"course\")public class Course &#123; @Id @GeneratedValue private Long id; private String name; // getters and setters &#125; 1234567891011121314@Entity(name = \"student\")public class Student &#123; @Id private String no; private String name; @ManyToMany(cascade = CascadeType.ALL) private Set&lt;Course&gt; courses; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567891011121314151617181920CREATE TABLE `course` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student` ( `no` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student_courses` ( `student_no` varchar(255) NOT NULL, `courses_id` bigint(20) NOT NULL, PRIMARY KEY (`student_no`,`courses_id`), KEY `FKlwviiijdg10oc2ui4yl7adh1o` (`courses_id`), CONSTRAINT `FKa6x7sxxnd9c1pat349a01bsow` FOREIGN KEY (`student_no`) REFERENCES `student` (`no`), CONSTRAINT `FKlwviiijdg10oc2ui4yl7adh1o` FOREIGN KEY (`courses_id`) REFERENCES `course` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2. @JoinTable与 @Table 注解相类似，不同的是，@JoinTable 注解是用于定义关联表，它只能标注在实体类型的成员属性或方法上，常用于多对多或多对一的关联映射。如果没有声明，则使用该注解的默认值。 参数 类型 描述 name String 连接表的名称。 catalog String 默认为数据库系统缺省的 catalog。 schema String 默认为用户缺省的 schema。 joinColumns JoinColumn[] 连接表中的外键列，通过使用 @JoinColumn 注解来声明，该外键参照源实体的主键。 inverseJoinColumns JoinColumn[] 与 joinColumns 参数作用类似，只不过该外键参照的是目标实体的主键。 uniqueConstraints UniqueConstraint[] 表的唯一约束（除了由 @Column 和 @JoinColumn 注解指定的约束以及主键的约束之外的约束），通过使用 @UniqueConstraint 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的约束条件。 indexes Index[] 表的索引，通过使用 @Index 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的索引。 foreignKey ForeignKey 用于生成表时定义 joinColumns 参数的外键约束。 inverseForeignKey ForeignKey 用于生成表时定义 inverseJoinColumns 参数的外键约束。 Course 定义不变，Student 定义改为： 1234567891011121314151617@Entity(name = \"student\")public class Student &#123; @Id private String no; private String name; @ManyToMany(cascade = CascadeType.ALL) @JoinTable(name = \"student_course\", joinColumns = @JoinColumn(name = \"sno\"), inverseJoinColumns = @JoinColumn(name = \"cid\")) private Set&lt;Course&gt; courses; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567891011121314151617181920CREATE TABLE `course` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student` ( `no` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student_course` ( `sno` varchar(255) NOT NULL, `cid` bigint(20) NOT NULL, PRIMARY KEY (`sno`,`cid`), KEY `FKkx4bkddvbfs0ese9v7hc5rycg` (`cid`), CONSTRAINT `FKrfibef5g98fllv2tlxuiii0lu` FOREIGN KEY (`sno`) REFERENCES `student` (`no`), CONSTRAINT `FKkx4bkddvbfs0ese9v7hc5rycg` FOREIGN KEY (`cid`) REFERENCES `course` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3. 多对多双向外键关联类 Student 定义不变，Course 类的定义改为： 123456789101112131415@Entity(name = \"course\")public class Course &#123; @Id @GeneratedValue private Long id; private String name; @ManyToMany(mappedBy = \"courses\") private Set&lt;Student&gt; students; // getters and setters &#125; 产生的 DDL 语句与多对多单向外键关联产生的一致。","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA 一对多、多对一注解","date":"2017-02-14T13:03:00.000Z","path":"post/jpa-one-to-many-many-to-one-annotation.html","text":"1. @OneToMany@OneToMany 是属性或方法级别的注解，用于定义源实体与目标实体是一对多的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的集合类型的泛型的参数化类型。 mappedBy String 用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn 互斥，如果标注了 @JoinColumn 注解，不需要再定义此参数）。 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据。 orphanRemoval boolean 当源实体关联的目标实体被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false。可参考：orphanRemoval 与 CascadeType.REMOVE 的区别 1.1 一对多外键关联1234567891011121314151617@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) private Set&lt;Address&gt; addresses; // getters and setters &#125; 1234567891011121314151617181920@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819202122232425CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `user_addresses` ( `user_id` bigint(20) NOT NULL, `addresses_id` bigint(20) NOT NULL, PRIMARY KEY (`user_id`,`addresses_id`), UNIQUE KEY `UK_i5lp1fvgfvsplfqwu4ovwpnxs` (`addresses_id`), CONSTRAINT `FKfm6x520mag23hvgr1oshaut8b` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`), CONSTRAINT `FKth1icmttmhhorb9wiarm73i06` FOREIGN KEY (`addresses_id`) REFERENCES `address` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; Hibernate @OneToMany 默认会产生一张中间表，如上例的 user_addresses 表。为了避免这种情况，你可以在一的一方使用 @JoinColumn 注解： 123@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)@JoinColumn(name = \"user_id\")private Set&lt;Address&gt; addresses; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这样一来，多的一方通过外键直接与一的一方发生关联，不需要中间表。 2. @ManyToOne@ManyToOne 是属性或方法级别的注解，用于定义源实体与目标实体是多对一的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的类型，因此该参数通常可以缺省。 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据。 optional boolean 源实体关联的目标实体是否允许为 null，默认为 true。 2.1 多对一外键关联1234567891011121314@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; // getters and setters &#125; 1234567891011121314151617181920212223@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; @ManyToOne(optional = false) private User user; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) NOT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3. @OneToMany &amp; @ManyToOne一对多 &amp; 多对一双向外键关联示例： 123456789101112131415161718@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = \"user_id\") private Set&lt;Address&gt; addresses; // getters and setters &#125; 1234567891011121314151617181920212223@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; @ManyToOne(optional = false) private User user; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) NOT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA 一对一注解","date":"2017-02-14T13:02:57.000Z","path":"post/jpa-one-to-one-annotation.html","text":"@OneToOne 是属性或方法级别的注解，用于定义源实体与目标实体是一对一的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的类型，因此该参数通常可以缺省。 mappedBy String 用在双向关联中。如果关系是双向的，只能有一方作为主体端，另一方则需声明此参数以表明将表间的这种关联关系转交给对方来维护。 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据。 optional boolean 源实体关联的目标实体是否允许为 null，默认为 true。 orphanRemoval boolean 当源实体关联的目标实体被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false。 注：目标实体是指被关系注解（如：@OneToOne）标注的属性或方法所对应的类，源实体是指该属性或方法所属的类。 1. 一对一单向外键关联123456789101112131415@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY) private IdCard idCard; // getters and setters &#125; 123456789101112@Entity(name = \"idcard\")public class IdCard &#123; @Id private String no; @Temporal(TemporalType.DATE) private Date expiryDate; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567891011121314CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `id_card_no` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FKar03p8ob32rgj1axxy2q507v5` (`id_card_no`), CONSTRAINT `FKar03p8ob32rgj1axxy2q507v5` FOREIGN KEY (`id_card_no`) REFERENCES `idcard` (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `idcard` ( `no` varchar(255) NOT NULL, `expiry_date` date DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2. orphanRemoval 与 CascadeType.REMOVE 的区别CascadeType.REMOVE（或包含 CascadeType.REMOVE 的 CascadeType.ALL）表示级联删除，只有对源实例做删除操作时，才会级联删除关联的目标实例。如上例，删除 id=1 的 Person 实例，那么，该实例所关联的 IdCard 实例也将被删除。示例代码片段： 1personRepository.delete(1L); 假设 person.idCard = idCard1，如果 person.idCard 属性被赋予了另外一个 IdCard 实例：person.idCard = idCard2 或被设为 null：person.idCard = null。此时，身份证 idCard1 已经找不到任何一个人和它发生关联，这样的值我们成为孤值，它已经失去了存在的意义。如果程序中设置了 orphanRemoval = true，那么，当更新 person 实例时，idCard1 实例将会被自动删除。示例代码片段： 123Person person = personRepository.findOne(1L);person.setIdCard(null);personRepository.save(person); 3. 一对一双向外键关联类 Person 定义不变，IdCard 类的定义改为： 123456789101112131415@Entity(name = \"idcard\")public class IdCard &#123; @Id private String no; @Temporal(TemporalType.DATE) private Date expiryDate; @OneToOne(mappedBy = \"idCard\") private Person person; // getters and setters &#125; 产生的 DDL 语句与一对一单向外键关联产生的一致。 4. @JoinColumn与 @Column 注解相类似，不同的是，@JoinColumn 注解是用于定义外键列，它只能标注在实体类型的成员属性或方法上，如果没有声明，则使用该注解的默认值。 参数 类型 描述 name String 外键列的名称，默认为：属性的名称 + _ + 属性对应的实体的主键列的名称（Hibernate 映射列时，若遇到驼峰拼写，会自动添加 _ 连接并将大写字母改成小写）。 unique boolean 外键列的值是否是唯一的。这是 @UniqueConstraint 注解的一个快捷方式，实质上是在声明唯一约束。默认值为 false。 nullable boolean 外键列的值是否允许为 null。默认为 true。 insertable boolean 外键列是否包含在 INSERT 语句中，默认为 true。 updatable boolean 外键列是否包含在 UPDATE 语句中，默认为 true。 columnDefinition String 生成外键列的 DDL 时使用的 SQL 片段。默认使用推断的类型来生成 SQL 片段以创建此列。 table String 外键列所属的表的名称。默认值：如果是外键 @OneToOne 或 @ManyToOne 关联，则为源实体的表的名称；如果是单向外键 @OneToMany 关系，则为目标实体的表的名称；如果是 @ManyToMany、@OneToOne、双向 @ManyToOne、双向 @OneToMany 关联，则为连接表的名称； 若修改 Person 类的定义为： 12345678910111213141516@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY) @JoinColumn(name = \"idcard_no\") private IdCard idCard; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `idcard_no` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FK56rk440ff4uyhc5vdis0jeiut` (`idcard_no`), CONSTRAINT `FK56rk440ff4uyhc5vdis0jeiut` FOREIGN KEY (`idcard_no`) REFERENCES `idcard` (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Column 注解","date":"2017-02-13T12:45:05.000Z","path":"post/jpa-column-annotation.html","text":"@Column 是属性或方法级别的注解，用于指定持久化属性映射到数据库表的列。如果没有指定列注释，则使用其默认值。 参数 类型 描述 name String 列的名称，默认为属性的名称（Hibernate 映射列时，若遇到驼峰拼写，会自动添加 _ 连接并将大写字母改成小写）。 unique boolean 列的值是否是唯一的。这是 @UniqueConstraint 注解的一个快捷方式， 实质上是在声明唯一约束。默认值为 false。 nullable boolean 列的值是否允许为 null。默认为 true。 insertable boolean 列是否包含在 INSERT 语句中，默认为 true。 updatable boolean 列是否包含在 UPDATE 语句中，默认为 true。 columnDefinition String 生成列的 DDL 时使用的 SQL 片段。默认使用推断的类型来生成 SQL 片段以创建此列。 table String 当前列所属的表的名称。 length int 列的长度，仅对字符串类型的列生效。默认为255。 precision int 列的精度，仅对十进制数值有效，表示有效数值的总位数。默认为0。 scale int 列的精度，仅对十进制数值有效，表示小数位的总位数。默认为0。 1. 示例12345678910111213141516171819202122232425@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; @Column(nullable = false, length = 32) private String name; @Column(length = 128) private String mail; @Column(columnDefinition = \"char(11) NOT NULL\") private String phone; @Column(precision = 5, scale = 2) private BigDecimal salary; @Column(precision = 5, scale = 2) private double assets; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456789CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `assets` double NOT NULL, `mail` varchar(128) DEFAULT NULL, `name` varchar(32) NOT NULL, `phone` char(11) NOT NULL, `salary` decimal(5,2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 可以看出，salary 字段的精度控制生效了，但对于 double 类型的 assets 字段的精度控制没有生效，为了使其生效，将代码修改为： 12@Column(columnDefinition = \"double(5, 2)\")private double assets; 产生的 DDL 语句（MySQL）： 123456789CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `assets` double(5,2) DEFAULT NULL, `mail` varchar(128) DEFAULT NULL, `name` varchar(32) NOT NULL, `phone` char(11) NOT NULL, `salary` decimal(5,2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Temporal 注解","date":"2017-02-13T12:45:00.000Z","path":"post/jpa-temporal-annotation.html","text":"@Temporal 是属性或方法级别的注解，用于声明属性持久化到数据库时所使用的时间精度。该注解可以应用于任何以下类型的实体类属性： java.util.Date java.util.Calendar 参数 类型 描述 value TemporalType 存储的类型，可选值：TemporalType.DATE（日期）TemporalType.TIME（时间）TemporalType.TIMESTAMP（日期和时间） 1. 示例12345678910111213141516171819@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; @Temporal(TemporalType.DATE) private Date birthday; @Temporal(TemporalType.TIMESTAMP) private Date lastLoginTime; @Temporal(TemporalType.TIME) private Date tokenExpiredTime; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `birthday` date DEFAULT NULL, `last_login_time` datetime DEFAULT NULL, `token_expired_time` time DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 数据值样例： 12345+----+------------+---------------------+--------------------+| id | birthday | last_login_time | token_expired_time |+----+------------+---------------------+--------------------+| 1 | 2017-05-14 | 2017-05-14 15:12:49 | 15:12:49 |+----+------------+---------------------+--------------------+","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Transient 注解","date":"2017-02-13T12:44:56.000Z","path":"post/jpa-transient-annotation.html","text":"@Transient 是属性或方法级别的注解，该注解没有参数，用于标注属性是瞬态而非持久的。 1. 示例123456789101112131415@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @Transient private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @GeneratedValue 注解","date":"2017-02-13T12:44:51.000Z","path":"post/jpa-generatedvalue-annotation.html","text":"@GeneratedValue 是属性或方法级别的注解，它结合 @Id 注解为主键的值提供生成策略的规范。 参数 类型 描述 strategy GenerationType 主键生成策略。可选值：GenerationType.TABLEGenerationType.SEQUENCEGenerationType.IDENTITYGenerationType.AUTO默认是 GenerationType.AUTO。 generator String 主键生成器的名称。该名称为 @TableGenerator 或 @SequenceGenerator 注解中 name 参数的值。默认为持久化提供者（如 Hibernate）提供的id生成器。 1. @GeneratedValue1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.1 GenerationType.TABLE该策略使用一个特殊的数据库表来为各个实体分配主键，并确保主键值的唯一性。它不依赖环境和数据库系统的具体实现，在不同数据库之间可以很容易的进行移植。 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE) private Long id; private String name; private String mail; // getters and setters &#125; 在 Hibernate + MySQL 环境产生的 DDL 语句： 123456789101112CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `hibernate_sequences` ( `sequence_name` varchar(255) NOT NULL, `sequence_next_hi_value` bigint(20) DEFAULT NULL, PRIMARY KEY (`sequence_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 其中，hibernate_sequences 表就是用来为各个实体分配主键的，sequence_name 用于存储各个实体名称，sequence_next_hi_value 则是用于存储各个实体的下一个主键的值。 每次保存 Person 实体对象的数据的时候，首先会到 hibernate_sequences 表中查询该实体名称是否已经存在，若不存在，则向 hibernate_sequences 表插入一行该实体名称的记录，若已经存在，则直接取出 sequence_next_hi_value 的值作为本次 Person 数据的主键值，接着更新 hibernate_sequences 表的记录，使该实体名称的记录的 sequence_next_hi_value 值加1。最后保存 Person 实体对象的记录。 1.1.1 @TableGenerator表生成器，GenerationType.TABLE 策略通常结合该注解一起使用。 参数 类型 描述 name String 生成器的名称，它可以被一个或多个类引用为主键的生成器。 table String 生成器表的名称。默认为持久化提供者（如 Hibernate）提供的名称。 catalog String 生成器表的 catalog，默认为数据库系统缺省的 catalog。 schema String 生成器表的 schema，默认为用户缺省的 schema。 pkColumnName String 生成器表的主键列的名称，默认为持久化提供者（如 Hibernate）提供的名称。 valueColumnName String 生成器表存储生成的值的列的名称，默认为持久化提供者（如 Hibernate）提供的名称。 pkColumnValue String 生成器表中的主键值，用于将不同的实体区分开来。默认为实体名称（@Entity 注解的 name 参数的值）。 initialValue int 用于初始化生成器生成的初始值。默认值是0。在 Hibernate 环境中，需要开启 hibernate.id.new_generator_mappings=true（Spring JPA 配置为：spring.jpa.hibernate.use-new-id-generator-mappings=true），否则此参数无效。并且如果实体记录已经存在生成器表中，此参数也无效（即只有当实体记录第一次写入生成器表中时此参数生效）。 allocationSize int 每次分配的值的数量大小，用完之后再分配此数量的值，默认为50。 uniqueConstraints UniqueConstraint[] 表的唯一约束，参考 @UniqueConstraint indexes Index[] 表的索引，参考 @Index 注：catalog 和 schema 可参考 catalog 和 schema 的区别。 123456789101112131415161718192021@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"pkGenerator\") @TableGenerator( name = \"pkGenerator\", table = \"pk_sequences\", pkColumnName = \"entity_name\", valueColumnName = \"sequence_value\", allocationSize = 10 ) private Long id; private String name; private String mail; // getters and setters &#125; 12345678910111213141516171819@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"pkGenerator\") @TableGenerator( name = \"pkGenerator\", table = \"pk_sequences\", pkColumnName = \"entity_name\", valueColumnName = \"sequence_value\", allocationSize = 10 ) private Long id; private String name; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456789101112131415161718CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `user` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `pk_sequences` ( `entity_name` varchar(255) NOT NULL, `sequence_value` bigint(20) DEFAULT NULL, PRIMARY KEY (`entity_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.2 GenerationType.SEQUENCE某些数据库系统（如：Oracle、DB2、PostgreSQL 等）底层支持使用序列对象来为表的主键提供唯一值，而对于不支持序列对象的数据库（如：MySQL、SQLServer），则不应使用此策略。 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; private String name; private String mail; // getters and setters &#125; 1234567891011121314151617181920212223242526@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; private String name; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 这种方式是多个实体共用同一个序列对象，这将导致各个实体分配到的序列值不连续，并且消耗加快。 1.2.1 @SequenceGenerator序列生成器，GenerationType.SEQUENCE 策略通常结合该注解一起使用。 参数 类型 描述 name String 生成器的名称，它可以被一个或多个类引用为主键的生成器。 sequenceName String 序列对象的名称，默认为持久化提供者（如 Hibernate）提供的名称。 catalog String 序列生成器的 catalog。 schema String 序列生成器的 schema。 initialValue int 用于初始化序列对象生成的初始值。默认值是1。 allocationSize int 每次分配的值的数量大小，用完之后再分配此数量的值，默认为50。 12345678910111213141516171819@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"personSeqGenerator\") @SequenceGenerator( name = \"personSeqGenerator\", sequenceName = \"PERSON_SEQ\", allocationSize = 10 ) private Long id; private String name; private String mail; // getters and setters &#125; 1234567891011121314151617@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"userSeqGenerator\") @SequenceGenerator( name = \"userSeqGenerator\", sequenceName = \"USER_SEQ\", allocationSize = 10 ) private Long id; private String name; // getters and setters &#125; 1.3 GenerationType.IDENTITY大部分数据库系统（如：MySQL、SQLServer、DB2、Sybase、HypersonicSQL 等）底层支持表的主键自增长，而对于不支持主键自增长的数据库（如：Oracle），则不能使用此策略。 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.4 GenerationType.AUTO自动为特定的数据库选择适当的策略，这是比较常用的策略。 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 由于 @GeneratedValue 注解默认采用的策略就是 GenerationType.AUTO，因此可以简写成： 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String mail; // getters and setters &#125;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Id 注解","date":"2017-02-13T12:44:47.000Z","path":"post/jpa-id-annotation.html","text":"@Id 是属性或方法级别的注解，该注解没有参数，用于标注实体的主键（映射到数据库表的主键）。 1. 示例12345678910111213@Entity(name = \"person\")public class Person implements Serializable &#123; @Id private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Basic 注解","date":"2017-02-13T12:44:43.000Z","path":"post/jpa-basic-annotation.html","text":"@Basic 是属性或方法级别的注解，该注解可以应用于任何以下类型的实体类属性： Java 原始类型 原始类型的包装类型 String java.math.BigInteger java.math.BigDecimal java.util.Date java.util.Calendar java.sql.Date java.sql.Time java.sql.Timestamp byte[] Byte[] char[] Character[] 枚举 任意实现 java.io.Serializable 接口的类型 在实体类中，对以上这些类型的属性，如果没有标注 @Basic 注解，则将使用 @Basic 注解的默认值。 参数 类型 描述 fetch FetchType 属性值的加载策略。可选值：FetchType.EAGER：即时加载；FetchType.LAZY：延迟加载，当第一次访问属性时才进行数据的加载；默认为 FetchType.EAGER。 optional boolean 是否允许为 null，默认为 true。 1. 示例123456789101112131415@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @Basic(optional = false, fetch = FetchType.LAZY) private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @MappedSuperclass 注解","date":"2017-02-11T16:18:20.000Z","path":"post/jpa-mappedsuperclass-annotation.html","text":"@MappedSuperclass 是类级别注解，该注解没有任何参数，被该注解标注的类不会映射到数据库中单独的表，但该类所拥有的属性都将映射到其子类的数据库表的列中。 1. 示例12345678910111213@MappedSuperclasspublic class BaseEntity &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) protected Long id; @Column(name = \"create_time\") protected Date createTime; // getters and setters &#125; 12345678910@Entity(name = \"person\")public class Person extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `create_time` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2. @AttributeOverride对于被 @MappedSuperclass 注解标注的类派生出来的子类，可以使用 @AttributeOverride 注解重新定义以覆盖父类中的映射信息。 参数 类型 描述 name String 属性名称 column Column 列信息 1234567891011@Entity(name = \"person\")@AttributeOverride(name = \"createTime\", column = @Column(name = \"create_date\"))public class Person extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `create_date` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3. @AttributeOverrides如果需要重新定义父类中的多个映射信息，需要使用 @AttributeOverrides 注解。 参数 类型 描述 value AttributeOverride[] @AttributeOverride 注解列表 1234567891011121314@Entity(name = \"person\")@AttributeOverrides(&#123; @AttributeOverride(name = \"id\", column = @Column(name = \"person_id\")), @AttributeOverride(name = \"createTime\", column = @Column(name = \"create_date\"))&#125;)public class Person extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `person_id` bigint(20) NOT NULL AUTO_INCREMENT, `create_date` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`person_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Table 注解","date":"2017-02-07T16:14:00.000Z","path":"post/jpa-table-annotation.html","text":"@Table 是类级别的注解，用于声明实体映射到数据库中的具体的表。 参数 类型 描述 name String 表的名称，默认为实体名称（参考 @Entity 注解的 name 参数说明），因此如果实体名称与映射的表名称一致时，@Table 注解常常可以省略。 catalog String 默认为数据库系统缺省的 catalog。 schema String 默认为用户缺省的 schema。 uniqueConstraints UniqueConstraint[] 表的唯一约束（除了由 @Column 和 @JoinColumn 注解指定的约束以及主键的约束之外的约束），通过使用 @UniqueConstraint 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的约束条件。 indexes Index[] 表的索引，通过使用 @Index 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的索引。 1 catalog 和 schema 的区别catalog 和 schema 主要用来解决数据库系统命名冲突的问题。一个数据库系统可以包含多个 catalog，每个 catalog 可以包含多个 schema，而每个 schema 又可以包含多个数据库对象（表、视图等）。不同的数据库系统对 catalog 和 schema 的支持方式有所不同，常见的数据库系统： 数据库系统 catalog schema MySQL 不支持 数据库名 Oracle 不支持 用户 ID SQLServer 数据库名 对象属主名 DB2 指定数据库对象时，Catalog 可以省略 Catalog 属主名 Sybase 数据库名 数据库属主名 2 唯一约束和索引的区别唯一约束是用来确保数据的正确性，它不允许表中存在重复的数据，若新插入的数据在表中已经存在，则更新操作失败。在数据库系统中，创建一个唯一约束的同时，也会为该约束所指定的所有列创建一个唯一索引，即约束包含索引。 索引是用来优化数据库表数据的检索性能的。通常，出现在查询 SQL 的 WHERE 子句和 JOIN 子句中的列可以考虑为其建立索引。 3. @UniqueConstraint用于声明表的唯一约束，这些仅在允许自动更新数据库表结构的场景中起到作用。 参数 类型 描述 name String 约束名称，如果不指定，默认使用数据库提供商所生成的值。 columnNames String[] 约束的列名称 4. @Index用于声明表的索引，这些仅在允许自动更新数据库表结构的场景中起到作用。另外，不需要为表的主键指定索引，因为主键索引会自动被创建。 参数 类型 描述 name String 索引名称，如果不指定，默认使用数据库提供商所生成的值。 columnList String 要包含在索引中的列名称。 unique boolean 索引是否唯一，默认为 false。 5. @Table5.1 唯一约束name 列、mail 列的值必须是唯一的，不允许出现重复的值： 123456789101112131415161718@Entity(name = \"person\")@Table(uniqueConstraints = &#123; @UniqueConstraint(name = \"unique_name\", columnNames = \"name\"), @UniqueConstraint(name = \"unique_mail\", columnNames = \"mail\")&#125;)public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_name` (`name`), UNIQUE KEY `unique_mail` (`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.2 联合唯一约束多列联合唯一约束，name 列和 mail 列不能同时出现相同的值： 123456789101112131415@Entity(name = \"person\")@Table(uniqueConstraints = @UniqueConstraint(name = \"unique_name_mail\", columnNames = &#123;\"name\", \"mail\"&#125;))public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_name_mail` (`name`,`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.3 单列索引为 name 列和 mail 列分别建立索引： 123456789101112131415161718@Entity(name = \"person\")@Table(indexes = &#123; @Index(name = \"index_name\", columnList = \"name\"), @Index(name = \"index_mail\", columnList = \"mail\")&#125;)public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_name` (`name`), KEY `index_mail` (`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.4 多列索引为 name 列和 mail 列建立多列索引： 123456789101112131415@Entity(name = \"person\")@Table(indexes = @Index(name = \"index_name_mail\", columnList = \"name,mail\"))public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_name_mail` (`name`,`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.5 单列索引和多列索引的区别当 SQL 查询条件中包含 name 和 mail 时： 1SELECT * FROM PERSON WHERE NAME = 'U79028' AND MAIL = '79029@163.com' 如果为 name 和 mail 列分别建立索引，当执行查询时，MySQL 只能使用一个索引。如果发现有多个单列索引可用，MySQL 会试图选择一个限制最严格的索引来检索，而其他索引则利用不上。 使用分析器分析查询 SQL： 1EXPLAIN SELECT * FROM PERSON WHERE NAME = 'U79028' AND MAIL = '79029@163.com' 结果如下： 12345+----+-------------+--------+------+-----------------------+------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+-----------------------+------------+---------+-------+------+-------------+| 1 | SIMPLE | PERSON | ref | index_name,index_mail | index_mail | 768 | const | 1 | Using where |+----+-------------+--------+------+-----------------------+------------+---------+-------+------+-------------+ MySQL 优化器如果发现可以使用多个索引查找后的交集/并集定位数据，那么 MySQL 优化器就会尝试使用 index merge（索引合并）的方式来查询： 1EXPLAIN SELECT * FROM PERSON WHERE NAME = 'U79028' AND MAIL = '79028@163.com' 结果如下： 12345+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+| 1 | SIMPLE | PERSON | index_merge | index_name,index_mail | index_name,index_mail | 768,768 | NULL | 1 | Using intersect(index_name,index_mail); Using where; Using index |+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+ 对于多列索引，由于索引文件以B树的数据结构存储，MySQL 能够快速转到合适的 name，然后再转到合适的 mail。在建立多列索引时，应该将严格的索引放在前面，这样筛选数据的时候力度会更大，效率更高。 使用分析器分析查询 SQL： 1EXPLAIN SELECT * FROM PERSON WHERE NAME = 'U79028' AND MAIL = '79028@163.com' 结果如下： 12345+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+| 1 | SIMPLE | PERSON | ref | index_name_mail | index_name_mail | 1536 | const,const | 2 | Using where; Using index |+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Entity 注解","date":"2017-02-06T14:16:11.000Z","path":"post/jpa-entity-annotation.html","text":"@Entity 是类级别注解，用于声明标注的类是持久的，我们把这样的类称为实体类。每个实体类映射到数据库中的一张表，实体类所拥有的属性将映射成数据库表的列。并由 JPA 负责将对实体的操作转换为对数据库表的操作。 参数 类型 描述 name String 实体名称，在 JPQL 中用于引用该实体类。默认为该类的简单类名称。 示例123456@Entity(name = \"person\")public class Person implements Serializable &#123; ... ... &#125;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"mybatis-template-generator 帮助文档","date":"2017-02-04T07:36:55.000Z","path":"post/mybatis-template-generator-document.html","text":"获取依赖123456789101112131415161718&lt;!-- 仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 声明依赖，版本信息参考：https://github.com/fanlychie/mybatis-template-generator/releases --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;mybatis-template-generator&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;!-- 打包时可顺利排除此依赖 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 环境要求JDK1.7 或以上版本 项目地址https://github.com/fanlychie/mybatis-template-generator 配置配置文件在项目类路径下新建一个文件 mybatis-template-generator.xml (右键链接另存为下载), 内容如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 自定义属性, 通过 $&#123;&#125; 占位符来引用 --&gt; &lt;properties&gt; &lt;!-- 引入属性配置文件 --&gt; &lt;include location=\"jdbc.properties\"/&gt; &lt;!-- 自定义属性键值对 --&gt; &lt;property name=\"basePackage\" value=\"com.domain\"/&gt; &lt;/properties&gt; &lt;!-- 数据源配置 --&gt; &lt;datasource&gt; &lt;!-- 数据库连接地址 --&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;!-- 数据库账户名称 --&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;!-- 数据库账户密码 --&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;!-- 数据库连接驱动 --&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;/datasource&gt; &lt;!-- 表配置 --&gt; &lt;table&gt; &lt;!-- 表名分隔符 --&gt; &lt;property name=\"separator\" value=\"_\"/&gt; &lt;!-- 忽略表, 匹配的表将被忽略不处理 --&gt; &lt;property name=\"ignores\"&gt; &lt;value&gt;temp*&lt;/value&gt; &lt;/property&gt; &lt;!-- 逃逸表, 匹配的表总是会输出文件 --&gt; &lt;property name=\"escapes\"&gt; &lt;value&gt;none&lt;/value&gt; &lt;/property&gt; &lt;!-- 表前缀, 输出的类文件忽略此名称 --&gt; &lt;property name=\"prefixs\"&gt; &lt;value&gt;tb_&lt;/value&gt; &lt;/property&gt; &lt;/table&gt; &lt;!-- 列配置 --&gt; &lt;column&gt; &lt;!-- 列名分隔符 --&gt; &lt;property name=\"separator\" value=\"_\"/&gt; &lt;!-- 忽略列, 匹配的列将被忽略不处理 --&gt; &lt;property name=\"ignores\"&gt; &lt;value&gt;temp*&lt;/value&gt; &lt;/property&gt; &lt;!-- 逃逸列, 匹配的列总是会输出属性 --&gt; &lt;property name=\"escapes\"&gt; &lt;value&gt;none&lt;/value&gt; &lt;/property&gt; &lt;!-- 列前缀, 输出的属性忽略此前缀名 --&gt; &lt;property name=\"prefixs\"&gt; &lt;value&gt;none&lt;/value&gt; &lt;/property&gt; &lt;/column&gt; &lt;!-- 输出配置 --&gt; &lt;output&gt; &lt;!-- 实体类 --&gt; &lt;property name=\"entity\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.entity\"/&gt; &lt;!-- Mybatis 实体类对应的 Xml 文件 --&gt; &lt;property name=\"mapperXml\" folder=\"$&#123;basedir&#125;/src/main/resources\" package=\"$&#123;basePackage&#125;.mapper\"/&gt; &lt;!-- Dao 接口 --&gt; &lt;property name=\"dao\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.dao\"/&gt; &lt;!-- Dao 实现类 --&gt; &lt;property name=\"daoImpl\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.dao.impl\"/&gt; &lt;!-- Service 接口 --&gt; &lt;property name=\"service\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.service\"/&gt; &lt;!-- Service 实现类 --&gt; &lt;property name=\"serviceImpl\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.service.impl\"/&gt; &lt;!-- 每次生成时总是覆盖输出 --&gt; &lt;property name=\"overwrite\"&gt; &lt;value&gt;none&lt;/value&gt; &lt;/property&gt; &lt;/output&gt;&lt;/configuration&gt; properties配置模板文件上下文参数键值对, 上下文环境可以通过 ${} 语法来引用自定义的键值对。 通过类路径下的属性文件引入: 1&lt;include location=\"jdbc.properties\"/&gt; 直接声明键值对: 1&lt;property name=\"basePackage\" value=\"com.domain\"/&gt; datasource配置数据源信息: 12345678910&lt;!-- 数据库连接地址 --&gt;&lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt;&lt;!-- 数据库账户名称 --&gt;&lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt;&lt;!-- 数据库账户密码 --&gt;&lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;!-- 数据库连接驱动 --&gt;&lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt;&lt;!-- 元数据类, 默认配置 --&gt;&lt;property name=\"metadataClass\" value=\"org.fanlychie.mybatis.template.db.MySQLMetadata\"/&gt; metadataClass 默认使用 MySQL 数据库实现。 其它数据库生成模板代码需实现抽象类 org.fanlychie.mybatis.template.db.DatabaseMetadata。 table数据库表配置信息: 1234567891011121314&lt;!-- 表名分隔符 --&gt;&lt;property name=\"separator\" value=\"_\"/&gt;&lt;!-- 忽略表, 匹配的表将被忽略不处理 --&gt;&lt;property name=\"ignores\"&gt; &lt;value&gt;temp*&lt;/value&gt;&lt;/property&gt;&lt;!-- 逃逸表, 匹配的表总是会输出文件 --&gt;&lt;property name=\"escapes\"&gt; &lt;value&gt;none&lt;/value&gt;&lt;/property&gt;&lt;!-- 表前缀, 输出的类文件忽略此名称 --&gt;&lt;property name=\"prefixs\"&gt; &lt;value&gt;tb_&lt;/value&gt;&lt;/property&gt; 参数 描述 separator 表名分隔符, 用于驼峰拼写, 例: user_info -&gt; UserInfo ignores 忽略表, 匹配的表将被忽略不处理 escapes 逃逸表, 它无视 ignores 配置的规则, 匹配的表总是会输出文件 prefixs 表前缀, 输出的类文件忽略此名称, 例: tb_user_info -&gt; UserInfo column数据库列配置信息: 123456789101112131415161718&lt;!-- 列名分隔符 --&gt;&lt;property name=\"separator\" value=\"_\"/&gt;&lt;!-- 忽略列, 匹配的列将被忽略不处理 --&gt;&lt;property name=\"ignores\"&gt; &lt;value&gt;temp*&lt;/value&gt;&lt;/property&gt;&lt;!-- 逃逸列, 匹配的列总是会输出属性 --&gt;&lt;property name=\"escapes\"&gt; &lt;value&gt;none&lt;/value&gt;&lt;/property&gt;&lt;!-- 列前缀, 输出的属性忽略此前缀名 --&gt;&lt;property name=\"prefixs\"&gt; &lt;value&gt;none&lt;/value&gt;&lt;/property&gt;&lt;!-- 数据库类型和 JAVA 数据类型的映射表 --&gt;&lt;property name=\"typeMapping\"&gt; &lt;value jdbcType=\"varchar\" javaType=\"String\" /&gt;&lt;/property&gt; 参数 描述 separator 列名分隔符, 用于驼峰拼写, 例: user_id -&gt; userId ignores 忽略列, 匹配的表将被忽略不处理 escapes 逃逸列, 它无视 ignores 配置的规则, 匹配的列总是输出到对象属性或文件 prefixs 列前缀, 输出的属性忽略此前缀名 typeMapping 数据库类型和 JAVA 数据类型的映射表 output模板文件输出配置信息: 12345678910111213141516&lt;!-- 实体类 --&gt;&lt;property name=\"entity\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.entity\"/&gt;&lt;!-- Mybatis 实体类对应的 Xml 文件 --&gt;&lt;property name=\"mapperXml\" folder=\"$&#123;basedir&#125;/src/main/resources\" package=\"$&#123;basePackage&#125;.mapper\"/&gt;&lt;!-- Dao 接口 --&gt;&lt;property name=\"dao\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.dao\"/&gt;&lt;!-- Dao 实现类 --&gt;&lt;property name=\"daoImpl\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.dao.impl\"/&gt;&lt;!-- Service 接口 --&gt;&lt;property name=\"service\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.service\"/&gt;&lt;!-- Service 实现类 --&gt;&lt;property name=\"serviceImpl\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.service.impl\"/&gt;&lt;!-- 每次生成时总是覆盖输出 --&gt;&lt;property name=\"overwrite\"&gt; &lt;value&gt;none&lt;/value&gt;&lt;/property&gt; ${basedir} 表示当前项目的路径。 参数 描述 folder 模板文件输出到的目录路径 package 模板文件使用的包名 overwrite 可以指定哪些模板文件强制重新生成输出。例: 只重新生成 user_info 表相关的文件 UserInfo*例: 只重新生成 user_info 表 XML 文件 UserInfo*.xml 生成模板文件maven 命令1mvn exec:java -Dexec.mainClass=MyBatisTemplateGenerator -Dexec.classpathScope=test Java 方法调用123public static void main(String[] args) &#123; org.fanlychie.mybatis.template.Generator.generate();&#125; 使用引入测试依赖包: 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 以 user 用户表为例: 模板文件除常规文件生成外代码生成器还会为每一个表生成对应的 Criteria 类，用于 SQL 条件操作，例: user 表 -&gt; UserCriteria。 Criteria 类拥有和实体类一致的 set 方法，不同的是 Criteria 类的 set 方法的参数接收的是 Criterion 对象，Criterion 对象通过 Value 静态方法来构建，见下文。 日志设置输出 SQL 语句 ( com.domain 替换成你自己的包名 ) : 1log4j.logger.com.domain.dao = DEBUG 保存数据12345678910111213141516171819202122232425262728293031import com.domain.entity.User;import com.domain.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.Date;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"/spring-context.xml\")public class UserTest &#123; @Autowired private UserService userService; @Test public void testSave() &#123; User user = new User(); user.setName(\"张三\"); user.setAge(23); user.setSalary(8600F); user.setProvince(\"广东\"); user.setCity(\"广州\"); user.setArea(\"天河区\"); user.setCreateTime(new Date()); // 保存数据 Integer id = userService.save(user); &#125;&#125; 单元测试: 123DEBUG [save:145] - ==&gt; Preparing: INSERT INTO USER ( ID, NAME, AGE, SALARY, PROVINCE, CITY, AREA, CREATE_TIME ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) DEBUG [save:145] - ==&gt; Parameters: null, 张三(String), 23(Integer), 8600.0(Float), 广东(String), 广州(String), 天河区(String), 2017-02-04 17:33:09.373(Timestamp)DEBUG [save:145] - &lt;== Updates: 1 更新数据根据主键更新12345678@Testpublic void testUpdate() &#123; User user = new User(); user.setId(21); user.setName(\"张三丰\"); // 根据主键更新数据 boolean result = userService.update(user);&#125; 单元测试: 123DEBUG [update:145] - ==&gt; Preparing: UPDATE USER SET NAME = ? WHERE id = ? DEBUG [update:145] - ==&gt; Parameters: 张三丰(String), 21(Integer)DEBUG [update:145] - &lt;== Updates: 1 根据条件更新123456789101112@Testpublic void testUpdate() &#123; User user = new User(); // 期望更新用户的薪资 user.setSalary(9000F); // 条件对象 UserCriteria criteria = new UserCriteria(); // 姓名等于张三丰的用户 criteria.setName(Value.eq(\"张三丰\")); // 根据条件更新数据 int result = userService.update(user, criteria);&#125; 单元测试: 123DEBUG [update:145] - ==&gt; Preparing: UPDATE USER SET SALARY = ? WHERE name = ? DEBUG [update:145] - ==&gt; Parameters: 9000.0(Float), 张三丰(String)DEBUG [update:145] - &lt;== Updates: 1 删除数据根据主键删除12345@Testpublic void testDelete() &#123; // 根据主键删除数据 boolean result = userService.delete(21);&#125; 单元测试: 123DEBUG [delete:145] - ==&gt; Preparing: DELETE FROM USER WHERE id = ? DEBUG [delete:145] - ==&gt; Parameters: 21(Integer)DEBUG [delete:145] - &lt;== Updates: 1 根据条件删除123456789@Testpublic void testDelete() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄大于 30 的用户 criteria.setAge(Value.gt(30)); // 根据条件删除数据 int result = userService.delete(criteria);&#125; 单元测试: 123DEBUG [delete:145] - ==&gt; Preparing: DELETE FROM USER WHERE age &gt; ? DEBUG [delete:145] - ==&gt; Parameters: 30(Integer)DEBUG [delete:145] - &lt;== Updates: 2 查询数据查询全部1234567@Testpublic void testSelect() &#123; List&lt;User&gt; user = userService.selectAll(); for (User u : user) &#123; System.out.println(u.getName()); &#125;&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER DEBUG [selectList:145] - ==&gt; Parameters: DEBUG [selectList:145] - &lt;== Total: 18 主键查询1234@Testpublic void testSelect() &#123; User user = userService.selectOne(8);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE id = ? DEBUG [selectList:145] - ==&gt; Parameters: 8(Integer)DEBUG [selectList:145] - &lt;== Total: 1 条件查询唯一记录12345678910@Testpublic void testSelect() &#123; UserCriteria criteria = new UserCriteria(); // 年龄大于 20 criteria.setAge(Value.gt(20)); // 用户名为 \"用户08\" criteria.setName(Value.eq(\"用户08\")); // 条件查询, 需确保数据是唯一的 User user = userService.selectOne(criteria);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE age &gt; ? AND name = ? DEBUG [selectList:145] - ==&gt; Parameters: 20(Integer), 用户08(String)DEBUG [selectList:145] - &lt;== Total: 1 列表查询123456789@Testpublic void testSelect() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄小于 25 criteria.setAge(Value.lt(25)); // 查询列表 List&lt;User&gt; users = userService.selectList(criteria);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE age &lt; ? DEBUG [selectList:145] - ==&gt; Parameters: 25(Integer)DEBUG [selectList:145] - &lt;== Total: 7 查询条数123456789@Testpublic void testSelect() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄小于 25 criteria.setAge(Value.lt(25)); // 查询总条数 long counts = userService.selectCount(criteria);&#125; 单元测试: 123DEBUG [selectCount:145] - ==&gt; Preparing: SELECT COUNT(1) FROM USER WHERE age &lt; ? DEBUG [selectCount:145] - ==&gt; Parameters: 25(Integer)DEBUG [selectCount:145] - &lt;== Total: 1 分页查询bootstrap 插件分页12345678910111213141516@Testpublic void testSelect() &#123; // 分页对象 Pagination pagination = new Pagination(); // 条件对象, 根据情况设置 SQL 条件, 此处不设 UserCriteria criteria = new UserCriteria(); // 分页查询, 无需提供任何参数, 极简分页 pagination = userService.selectPage(criteria, pagination); // 查询结果总条数 System.out.println(pagination.getTotal()); // 查询的结果集 for (Object row : pagination.getRows()) &#123; User user = (User) row; System.out.println(user.getName() + \" - ¥\" + user.getSalary()); &#125;&#125; 单元测试: 1234567DEBUG [selectCount:145] - ==&gt; Preparing: SELECT COUNT(1) FROM USER DEBUG [selectCount:145] - ==&gt; Parameters: DEBUG [selectCount:145] - &lt;== Total: 1DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER LIMIT ?, ? DEBUG [selectList:145] - ==&gt; Parameters: 0(Integer), 10(Integer)DEBUG [selectList:145] - &lt;== Total: 10 bootstrap 插件分页 Pagination 参数说明表: 参数 是否必须 描述 rows 否 分页结果集合, 返回字段, 无需设值 total 否 查询结果总条数, 返回字段, 无需设值 limit 否 每页显示的条数, 默认 10 offset 否 查询的起始索引值, 默认 0 sort 否 排序字段的名称 order 否 排序的关键字 search 否 搜索的关键字 field 否 搜索字段名称, bootstrap 分页插件不发送此参数, 如果有需要, 需手工设置, 建议不使用此参数 普通分页12345678910111213141516171819202122232425262728@Testpublic void testSelect() &#123; // 分页对象 Pagination pagination = new Pagination(); // 设置第一页, 普通分页必设 pagination.setPage(1); // 条件对象 UserCriteria criteria = new UserCriteria(); // 薪资升序排序 criteria.setSalary(Value.orderBy(OrderBy.ASC)); // 薪资相同则按年龄升序排序 criteria.setAge(Value.orderBy(OrderBy.ASC)); // 分页查询, 无需提供任何参数, 极简分页 pagination = userService.selectPage(criteria, pagination); // 查询结果总条数 System.out.println(\"查询结果总条数: \" + pagination.getTotal()); // 查询结果总页数 System.out.println(\"查询结果总页数: \" + pagination.getPages()); // 上一页的页码 System.out.println(\"上一页的页码: \" + pagination.getPrev()); // 下一页的页码 System.out.println(\"下一页的页码: \" + pagination.getNext()); // 查询的结果集 for (Object row : pagination.getRows()) &#123; User user = (User) row; System.out.println(user.getName() + \" \" + user.getAge() + \" - ¥\" + user.getSalary()); &#125;&#125; 单元测试: 1234567DEBUG [selectCount:145] - ==&gt; Preparing: SELECT COUNT(1) FROM USER DEBUG [selectCount:145] - ==&gt; Parameters: DEBUG [selectCount:145] - &lt;== Total: 1DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER ORDER BY salary ASC , age ASC LIMIT ?, ? DEBUG [selectList:145] - ==&gt; Parameters: 0(Integer), 10(Integer)DEBUG [selectList:145] - &lt;== Total: 10 bootstrap 插件分页 Pagination 参数说明表: 参数 是否必须 描述 rows 否 分页结果集合, 返回字段, 无需设值 total 否 查询结果总条数, 返回字段, 无需设值 limit 否 每页显示的条数, 默认 10 offset 否 查询的起始索引值, 默认 0 sort 否 排序字段的名称 order 否 排序的关键字 search 否 搜索的关键字 field 否 搜索字段名称 page 是 当前请求的页码, 页码从 1 开始 prev 否 上一页的页码, 返回字段, 无需设值 next 否 下一页的页码, 返回字段, 无需设值 pages 否 查询结果总页数, 返回字段, 无需设值 逻辑操作多个 Criterion 条件默认是 AND 逻辑: 1234567891011@Testpublic void testSelect() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄小于 28 criteria.setAge(Value.lt(28)); // 薪资高于 8000 criteria.setSalary(Value.gt(8000)); // 查询结果 List&lt;User&gt; users = userService.selectList(criteria);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE age &lt; ? AND salary &gt; ? DEBUG [selectList:145] - ==&gt; Parameters: 28(Integer), 8000(Integer)DEBUG [selectList:145] - &lt;== Total: 4 支持简单的 OR 逻辑: 123456789@Testpublic void testSelect() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄小于 28 或 薪资高于 12000 criteria.setAge(Value.lt(28)).or(criteria.setSalary(Value.gt(12000))); // 查询结果 List&lt;User&gt; users = userService.selectList(criteria);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE age &lt; ? OR salary &gt; ? DEBUG [selectList:145] - ==&gt; Parameters: 28(Integer), 12000(Integer)DEBUG [selectList:145] - &lt;== Total: 15","tags":[{"name":"开发工具包","slug":"开发工具包","permalink":"http://yoursite.com/tags/开发工具包/"}]},{"title":"commons-httpclient 帮助文档","date":"2017-01-28T02:40:33.000Z","path":"post/commons-httpclient-document.html","text":"获取依赖12345678910111213141516&lt;!-- 仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 声明依赖，版本信息参考：https://github.com/fanlychie/commons-httpclient/releases --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 环境要求JDK1.8 或以上版本 项目地址https://github.com/fanlychie/commons-httpclient GET 请求12345678910// HTTP URI GET 请求HttpClientUtils.get(\"http://huaban.com/search/\") // 请求参数 .addParameter(\"q\", \"2017\") // 请求参数 .addParameter(\"sort\", \"created_at\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); 参数 类型 描述 statusCode int 响应的状态码值 responseText string 响应的文本内容 完整示例 ( GET/PUT/POST/DELETE 拥有同样的配置项 ) 12345678910111213141516171819202122// HTTP URI GET 请求HttpClientUtils.get(\"http://huaban.com/search/\") // 请求参数 .addParameter(\"q\", \"2017\") // 请求参数 .addParameter(\"sort\", \"created_at\") // 请求头参数 .addHeader(\"arg\", \"value\") // 设置响应内容编码, 默认 UTF-8 .setContentEncoding(\"UTF-8\") // 设置连接超时时间, 默认30秒 .setConnectTimeout(30 * 1000) // 设置读取超时时间, 默认3分钟 .setReadTimeout(3 * 60 * 1000) // 设置失败重试次数, 默认3次 .setRetryTimes(3) // 设置 HTTP 代理, HTTPS 代理通过 setHttpsProxy 设置 .setHttpProxy(\"116.226.136.135\", 8118) // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); DELETE 请求12345678910// HTTP URI DELETE 请求HttpClientUtils.delete(\"http://domain.com\") // 请求参数 .addParameter(\"arg1\", \"value1\") // 请求参数 .addParameter(\"arg2\", \"value2\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); POST 请求普通表单提交键值对参数： 12345678910// HTTP 普通表单 POST 请求HttpClientUtils.post(\"http://domain.com\") // 请求参数 .addParameter(\"arg1\", \"value1\") // 请求参数 .addParameter(\"arg2\", \"value2\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); JSON 参数： 12345678// HTTP 普通表单 POST 请求HttpClientUtils.post(\"http://domain.com\") // JSON 请求参数 .addJSONParameter(\"&#123;\\\"arg1\\\":\\\"value1\\\",\\\"arg2\\\":\\\"value2\\\"&#125;\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); 文件上传表单123456789101112// HTTP 文件上传表单 POST 请求HttpClientUtils.postMultipartForm(\"http://domain.com\") // 普通参数 .addParameter(\"arg1\", \"value1\") // 普通参数 .addParameter(\"arg2\", \"value2\") // 文件参数, 或输入流参数 .addParameter(\"file\", new File(\"pom.xml\")) // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); PUT 请求普通表单提交键值对参数： 12345678910// HTTP 普通表单 PUT 请求HttpClientUtils.put(\"http://domain.com\") // 请求参数 .addParameter(\"arg1\", \"value1\") // 请求参数 .addParameter(\"arg2\", \"value2\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); JSON 参数： 12345678// HTTP 普通表单 PUT 请求HttpClientUtils.put(\"http://domain.com\") // JSON 请求参数 .addJSONParameter(\"&#123;\\\"arg1\\\":\\\"value1\\\",\\\"arg2\\\":\\\"value2\\\"&#125;\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); 文件上传表单123456789101112// HTTP 文件上传表单 PUT 请求HttpClientUtils.putMultipartForm(\"http://domain.com\") // 普通参数 .addParameter(\"arg1\", \"value1\") // 普通参数 .addParameter(\"arg2\", \"value2\") // 文件参数, 或输入流参数 .addParameter(\"file\", new File(\"pom.xml\")) // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); 调试日志1log4j.logger.org.fanlychie.commons.httpclient = DEBUG","tags":[{"name":"开发工具包","slug":"开发工具包","permalink":"http://yoursite.com/tags/开发工具包/"}]},{"title":"commons-jsp-tag 帮助文档","date":"2017-01-25T17:06:37.000Z","path":"post/commons-jsp-tag-document.html","text":"获取依赖12345678910111213141516&lt;!-- 仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 声明依赖，版本信息参考：https://github.com/fanlychie/commons-jsp-tag/releases --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;commons-jsp-tag&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 环境要求JDK1.7 或以上版本 项目地址https://github.com/fanlychie/commons-jsp-tag 引入标签库1&lt;%@ taglib prefix=\"f\" uri=\"http://fanlychie.org/tags/function\" %&gt; resource 标签此标签用于表示 web 项目中 webapp 目录下的资源文件。 12345678// 脚本资源&lt;script src='&lt;f:resource path=\"/statics/js/index.js\"/&gt;'&gt;&lt;/script&gt;// 样式资源&lt;link href='&lt;f:resource path=\"/statics/css/index.css\"/&gt;' rel=\"stylesheet\" type=\"text/css\"&gt;// 图片资源&lt;img src='&lt;f:resource path=\"/statics/images/logo.png\"/&gt;' /&gt; 资源文件版本默认每次服务重新启动时，资源标签输出一个新的版本，强制客户端刷新资源文件，避免客户端缓存旧版的文件资源。如要自行控制管理资源文件，可在 Spring 配置文件中添加如下代码： 12&lt;!-- 引入 p 命名空间 xmlns:p=\"http://www.springframework.org/schema/p\" --&gt;&lt;bean class=\"org.fanlychie.commons.jsp.tag.WebappResourceTagConfig\" p:version=\"1.0\"/&gt; url 标签此标签用于表示链接地址，可以是 http 或 https 的绝对地址，也可以是相对于项目的相对地址： 12345// 绝对地址，输出 http://www.baidu.com&lt;f:url href=\"http://www.baidu.com\" /&gt;// 相对地址，输出 /项目名/user/home&lt;f:url href=\"/user/home\" /&gt; date 标签此标签用于将 java.util.Date 对象转成字符串内容： 1234567891011// 日期，输出 2017-01-26&lt;f:date value=\"$&#123;now&#125;\" type=\"date\" /&gt;// 时间，输出 01:41:41&lt;f:date value=\"$&#123;now&#125;\" type=\"time\" /&gt;// 日期时间，输出 2017-01-26 01:41:41&lt;f:date value=\"$&#123;now&#125;\" type=\"datetime\" /&gt;// 自定义模式串，输出 2017/01/26 01:41:41:236&lt;f:date value=\"$&#123;now&#125;\" pattern=\"yyyy/MM/dd HH:mm:ss:SSS\" /&gt;","tags":[{"name":"开发工具包","slug":"开发工具包","permalink":"http://yoursite.com/tags/开发工具包/"}]},{"title":"Redis 哨兵集群和应用","date":"2017-01-19T14:11:15.000Z","path":"post/redis-sentinel.html","text":"1. 哨兵在一个一主多从的 Redis 系统中，主 Redis 主要负责写请求以及将数据同步给从 Redis，从 Redis 可以接受客户端的读请求以及接受主 Redis 同步过来的数据。当主 Redis 异常不能正常提供服务时，可以手动选择一个从 Redis 并将其升级为主 Redis，以使得整个系统能正常对外提供服务。当原来的主 Redis 恢复之后，再手动将其降级为从 Redis 加入系统当中。这整个过程需要人工的介入，不能实现自动化。哨兵是 Redis 的高可用解决方案。它可以监控 Redis 系统的运行状况，当主 Redis 出现故障时，可以进行故障自动转移，它将选择一个从 Redis 并将其自动升级为主 Redis，当原来的主 Redis 恢复时，会自动将其降级为从 Redis 重新加入 Redis 系统当中。这整个过程由哨兵来完成，无需人工的介入。 2. 部署概况 角色 IP 端口 master（主） 10.10.10.127 6379 slave（从） 10.10.10.128 6379 slave（从） 10.10.10.129 6379 sentinel（哨兵） 10.10.10.127 26379 sentinel（哨兵） 10.10.10.128 26379 sentinel（哨兵） 10.10.10.129 26379 3. redis 一主多从部署此处省去 Redis 的安装步骤，具体可参考另一篇文章：Redis安装和应用。 10.10.10.127（master）redis.conf 配置： 1234567891011121314# 是否以守护进程的方式运行daemonize yes## 端口port 6379## 当redis作为守护进程运行时，它会将pid写入到该参数指定的文件里面pidfile /usr/local/redis/run/redis.pid## 文件保存到磁盘的快照文件的目录路径dir /usr/local/redis/data## 日志文件logfile /usr/local/redis/logs/redis.log 10.10.10.128（slave）redis.conf 配置： 1234567891011121314151617# 是否以守护进程的方式运行daemonize yes## 端口port 6379## 当redis作为守护进程运行时，它会将pid写入到该参数指定的文件里面pidfile /usr/local/redis/run/redis.pid## 文件保存到磁盘的快照文件的目录路径dir /usr/local/redis/data## 日志文件logfile /usr/local/redis/logs/redis.log## 配置该项说明当前服务是一个slave节点。它会根据配置从master节点进行数据同步slaveof 10.10.10.127 6379 与主配置不同的是，多了一个slaveof配置项，表明这是一个从数据库。 10.10.10.129（slave）redis.conf 配置： 1234567891011121314151617# 是否以守护进程的方式运行daemonize yes## 端口port 6379## 当redis作为守护进程运行时，它会将pid写入到该参数指定的文件里面pidfile /usr/local/redis/run/redis.pid## 文件保存到磁盘的快照文件的目录路径dir /usr/local/redis/data## 日志文件logfile /usr/local/redis/logs/redis.log## 配置该项说明当前服务是一个slave节点。它会根据配置从master节点进行数据同步slaveof 10.10.10.127 6379 与主配置不同的是，多了一个slaveof配置项，表明这是一个从数据库。 最后，分别启动这几台服务器上的 Redis 服务： 1# redis-server /usr/local/redis/redis.conf 4. 哨兵集群哨兵本质上是一个特殊的 Redis 服务，不需要额外安装其它应用来支持。 10.10.10.127（sentinel）sentinel.conf 配置： 1234567891011121314151617181920212223242526272829303132333435# 是否以守护进程的方式运行daemonize yes## 端口port 26379## 当redis作为守护进程运行时，它会将pid写入到该参数指定的文件里面pidfile /usr/local/redis/run/sentinel.pid## 文件保存到磁盘的快照文件的目录路径dir /usr/local/redis/data## 日志文件logfile /usr/local/redis/logs/sentinel.log## 配置哨兵监听redis的master节点# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;# &lt;master-name&gt;：自定义master节点的名称# &lt;ip&gt;：master节点的ip地址# &lt;redis-port&gt;：master节点的端口号# &lt;quorum&gt;：当有quorum个哨兵主观认为master节点失效时，才会认为master节点客观上真正失效sentinel monitor mymaster 10.10.10.127 6379 2## 哨兵连接redis的master节点的密码（没有设置密码可以不配，如果配置了，那么redis主从节点都应配置相同的密码）sentinel auth-pass mymaster 654321## 哨兵会周期性的PING主节点（master），如果master节点在规定时间内没有回应，哨兵就会主观上认为master节点失效了。默认是30秒sentinel down-after-milliseconds mymaster 30000## 当发生failover（故障转移）进行主从切换时，有多少个salve对新的master节点进行同步# 如果slave节点用来做查询，应尽量配置小的值，避免在故障转移期间所有的slave因进行同步而不可用sentinel parallel-syncs mymaster 1## 故障转移超时时间sentinel failover-timeout mymaster 180000 在10.10.10.128和10.10.10.129上的sentinel.conf配置与上同。 哨兵可以通过监控主 Redis 自动发现复制主 Redis 的从 Redis，以及自动发现监控主 Redis 的其它哨兵。哨兵会周期性的发送PING给主和从 Redis，以监控 Redis 系统的运行状况，主和从 Redis 如果不能在规定时间内应答哨兵，则哨兵会主观认为 Redis 服务下线。 最后，分别启动这几台服务器上的哨兵服务： 1# redis-sentinel /usr/local/redis/sentinel.conf --sentinel 5. 简单应用# pom.xml1234567891011&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 单元测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class RedisSentinelDemoTest &#123; private JedisSentinelPool jedisSentinelPool; @Before public void doBefore() &#123; // 链接池配置 JedisPoolConfig poolConfig = new JedisPoolConfig(); // 当没有可用链接时是否阻塞，直到超时 poolConfig.setBlockWhenExhausted(true); // 最大空闲链接数 poolConfig.setMaxIdle(8); // 最小空闲链接数 poolConfig.setMinIdle(4); // 最大链接数 poolConfig.setMaxTotal(8); // 最大等待时间 poolConfig.setMaxWaitMillis(30000); // 获取链接时是否检查可用性 poolConfig.setTestOnBorrow(true); // 链接归还池时是否检查可用性 poolConfig.setTestOnReturn(true); // 哨兵 Set&lt;String&gt; sentinels = new HashSet&lt;&gt;(); sentinels.add(\"10.10.10.127:26379\"); sentinels.add(\"10.10.10.128:26379\"); sentinels.add(\"10.10.10.129:26379\"); // 链接池 jedisSentinelPool = new JedisSentinelPool(\"mymaster\", sentinels, poolConfig, 5000); &#125; @Test public void doTest() &#123; Jedis jedis = jedisSentinelPool.getResource(); if (jedis.exists(\"myname\")) &#123; System.out.println(\"=====&gt; \" + jedis.get(\"myname\")); &#125; else &#123; jedis.set(\"myname\", \"fanlychie\"); &#125; jedis.close(); &#125; &#125; 6. 与Spring集成# pom.xml1234567891011121314151617181920212223242526272829303132&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.18.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; redis 参数配置： # redis.properties12345678910111213141516171819202122# master 名称redis.masterName = mymaster# 哨兵 1redis.sentinel1 = 10.10.10.127:26379# 哨兵 2redis.sentinel2 = 10.10.10.128:26379# 哨兵 3redis.sentinel3 = 10.10.10.129:26379# 当没有可用链接时是否阻塞，直到超时redis.blockWhenExhausted = true# 最大空闲链接数redis.maxIdle = 8# 最小空闲链接数redis.minIdle = 4# 最大链接数redis.maxTotal = 8# 最大等待时间redis.maxWaitMillis = 30000# 获取链接时是否检查可用性redis.testOnBorrow = true# 链接归还池时是否检查可用性redis.testOnReturn = true spring 配置： # spring-context.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:redis.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"org.fanlychie\"/&gt; &lt;!-- redis 链接池配置 --&gt; &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"blockWhenExhausted\" value=\"$&#123;redis.blockWhenExhausted&#125;\"/&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\"/&gt; &lt;property name=\"minIdle\" value=\"$&#123;redis.minIdle&#125;\"/&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.maxTotal&#125;\"/&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.maxWaitMillis&#125;\"/&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.testOnBorrow&#125;\"/&gt; &lt;property name=\"testOnReturn\" value=\"$&#123;redis.testOnReturn&#125;\"/&gt; &lt;/bean&gt; &lt;!-- redis 哨兵配置 --&gt; &lt;bean id=\"sentinelConfig\" class=\"org.springframework.data.redis.connection.RedisSentinelConfiguration\"&gt; &lt;constructor-arg name=\"master\" value=\"$&#123;redis.masterName&#125;\"/&gt; &lt;constructor-arg name=\"sentinelHostAndPorts\"&gt; &lt;set&gt; &lt;value&gt;$&#123;redis.sentinel1&#125;&lt;/value&gt; &lt;value&gt;$&#123;redis.sentinel2&#125;&lt;/value&gt; &lt;value&gt;$&#123;redis.sentinel3&#125;&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- redis 链接配置 --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;constructor-arg name=\"poolConfig\" ref=\"poolConfig\"/&gt; &lt;constructor-arg name=\"sentinelConfig\" ref=\"sentinelConfig\"/&gt; &lt;/bean&gt; &lt;!-- redis 字符串序列化 --&gt; &lt;bean id=\"stringRedisSerializer\" class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; &lt;!-- redis 对象转为json串序列化 --&gt; &lt;bean id=\"jsonRedisSerializer\" class=\"org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer\"&gt; &lt;constructor-arg name=\"mapper\"&gt; &lt;bean class=\"com.fasterxml.jackson.databind.ObjectMapper\"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- redis 模板 --&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;property name=\"keySerializer\" ref=\"stringRedisSerializer\"/&gt; &lt;property name=\"valueSerializer\" ref=\"jsonRedisSerializer\"/&gt; &lt;property name=\"hashKeySerializer\" ref=\"stringRedisSerializer\"/&gt; &lt;property name=\"hashValueSerializer\" ref=\"jsonRedisSerializer\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 单元测试： 1234567891011121314151617181920@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"/spring-context.xml\")public class RedisSentinelSpringDemoTest &#123; @Autowired private RedisTemplate redisTemplate; @Test public void doTest() &#123; if (redisTemplate.hasKey(\"myinfo\")) &#123; System.out.println(\"=====&gt; \" + redisTemplate.opsForValue().get(\"myinfo\")); &#125; else &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"fanlychie\"); map.put(\"mail\", \"fanlychie@yeah.net\"); redisTemplate.opsForValue().set(\"myinfo\", map); &#125; &#125; &#125;","tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"commons-file 帮助文档","date":"2017-01-15T14:06:03.000Z","path":"post/commons-file-api.html","text":"获取依赖12345678910111213141516&lt;!-- 仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 声明依赖，版本信息参考：https://github.com/fanlychie/commons-file/releases --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;commons-file&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 环境要求JDK1.8 或以上版本 项目地址https://github.com/fanlychie/commons-file 读取文件12345678910// 读取当前项目下的 pom.xml 文件的内容String content = FileUtils.readFileAsString(\"pom.xml\");// 读取到 List 容器，容器的每个元素代表文件的一行List&lt;String&gt; list = FileUtils.readFileAsListOfString(\"pom.xml\");// 按行读取FileUtils.readFileLineByLine(\"pom.xml\", line -&gt; &#123; System.out.println(line);&#125;); 写出文件文本内容12345// 将字符串内容写出到 readme.txt 文件，若文件不存在则自动创建此文件，若文件已经存在则覆盖此文件FileUtils.writeFile(\"readme.txt\", \"Hello, World!\");// 将字符串内容追加到 readme.txt 文件FileUtils.appendFile(\"readme.txt\", \"\\n你好，世界！\"); 文件拷贝123456789// 拷贝到文件// 将 readme.txt 文件拷贝到 readme2.txt 文件// 若 readme2.txt 文件尚未存在，则创建 readme2.txt 文件// 若 readme2.txt 文件已经存在，则将 readme.txt 文件内容覆盖 readme2.txt 文件内容FileUtils.copyFile(\"readme.txt\", \"readme2.txt\");// 拷贝到目录// 将 readme.txt 文件拷贝到当前项目的 readme 目录中，此目录必须已经存在，否则抛出异常FileUtils.copyFileToDirectory(\"readme.txt\", \"readme\"); Base64 图片文件编码图片文件1234567// Base64 编码 URL 图片，将编码后的字符串内容置于 &lt;img /&gt; 标签的 src 属性中即可展示此图片// 此方式将图片转成字符串，可减少 HTTP 请求，适合小图片，大图片会导致字符串内容过大加载变慢// 如下图可 F12 查看 src 属性值String str = FileUtils.encodeImageUrlBase64(\"http://www.qncye.com/buttom/images/hk06.jpg\");// 编码项目下的 logo.png 图片文件String str = FileUtils.encodeImageFileBase64(\"logo.png\"); 解码图片文件123456789// 编码后的图片文件字符串内容String base64ImageStr = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAIBAQEBAQIBAQECAgICAgQDAgICAgUEBAMEBgUGBgYFBgYGBwkIBgcJBwYGCAsICQoKCgoKBggLDAsKDAkKCgr/2wBDAQICAgICAgUDAwUKBwYHCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgr/wAARCAEbAlgDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9PhuB4PUelKCc7sH2AajDMoPmbT147U4fLkAAgEjJHXFfjkVc+xegYyDhumMkDNCZyAR0HJI7UsKSSg4AAB7fypTGxbYMbjyB69a1UW0pJEXV7BEFZSu4YHpT1WFBtkPU8etNSO5AAERHQ5yMZqWWSOJVE3J9B3ropxSheWlu5Em76C25gLFTnPOAaSSK53FlJwTxjpS28sQJIjIz3PSmO1w0pwPlHTBNbXj7JfoZpPmf6kjqfJxcLn6dqiMduv3g3OMZ471MJCsYM/4Y/wDrVAfIILMWwPXtzSq8qt6dRwv/AMMMu1kIyGzx0Xgg8mqymUrt3Y64z68VZndN+5W4PcHpj/JqvM2JcjPTkHt1/wDr/p9a8vE257pnXSvy2FkmZohhgcjg9R9ff/PWoQrRIwCnJbIO7r+P+TT1MgUqp49D39+PamKfMIIcEEDJzx/9ft/nrx1Jc1m9zaKtoth3Eiqx3cDgcYPSlTP3iMkZ5BPr2pChUjEfOOQQDk/5/wA9qcMsxRguQDk5Pr0oinfXcG9CRELdCCR146/5zSRwyxv+7yvI4z/n3/8A1VLGgPzAH245/wA9f88U5lXsoB9f8iu9UE0pdjnc2tBrNwDlxwOVA/z/AJNOs4hHuaIndgYJOT7UwEZI9+pXk1PD90lB8x655zW9JKdRSf8AXoRN2hYazMqFEzkggYP+RTFidiC/Bwcj1/P/AD/KpNxKghWJ7UrDLDKENjt6Vq482t/6/wAyE7CRoGYyFsnqAeMcc0zfIF2uMYH3cHoKcp8sMy8tkYpFaRU3SAdOu32qW1ZJeY7DXTcoLMQ/oGz/AJ/z1oQR5I6sCSox79aTDzklV+7x9T71IGUHLJ8wyTkGs4xTd/6/4cptpWEeSblBJhR1Uc0x9/8AEBjPNSGT5s5K88Y7UyQs2U+UYwSSPypzTa3YR06CKDjduGDjqc/5/wDrfjTlHyDeCMDg+tNVvmG4Z5yc9aerHy9gVSo4BznPfn/P+FTTswdxsp+XeV3DB5//AFf54/GkiaPy96Dnjocg+n4f596Vm3jaV42nPt/9f/PtTFiWNFVAMAYGe4olJ891sNJWswdVbJA5B5Oc84/z/wDqqKPp+9JPPAxnH+fX09KkUFWOXzz0Pbj/AD+fftGse+fchb0IyOPxx9O/5muad3JNLW5rHaw0MOFIzhjk5I/H/P8ALrIl4HQKAhGeMcjrx/n+nUaElhjORjkkcf5/zzzQE8tVyvJ44xx/P/PrUx9tF+Q3ySRDLAtw5ufmG0cAsuM46/XqPYemeZIrYo26SUkBTxxz+Ix/h9O6EuG2lgBkYwfXsP8AP9amjXDb92SFHbg4zx/n8PWinCnKfM1r1HKUoxt0G/KZCnIw3bjn1PHfP/6ulICBlXddwzyR0H+f6Z44qTa0j7iicYHXk85xj8f5/WmOCzsgdyeN3Xp7Y7den4etb8rRmmiOOMnMhl53sWYAnvjv9Of8ilZFBKhdnJ2lunPUn06//r4AfHHs+UwqRyFBwc9en+cenHJVyEJYSknJHzd/8/y9OplR5Y6lXuyFkhhdUZhuI7tgrngk/ifzx1IAqJxkGFVPQ4fdgjPccH8c+gHPQTyPuRRtYk42p3H/ANbt9PTuyYCWNSj5JXgEnn6jjjB9se3fKS35S4va5ESu4yHapVAqsMAjk/X8uevcmpI0iUjZwwXkEAde3A/x59T0a8bLMxLY3KBwAdwweoPt/PsODIyKxMT4ZTgqWAwpHfnr2/rgYFRBO7KbREUWSUxInysQMZwB1OP5cY68jJyRAI445vs7RrsIIQgYCjngY/EgDpnPPUXpg5DKCpQY6nPOOv8ALr/9jTGAYBkYblbJGOox1P4dz+P90uVLUcZlEWcqRL5ZCsp/djnAxnAGPx9Tyev3g2SITRpiVo5I487Yx06HAwM87eg69v71XXTDBj8vdxt/MnPbgDkdcZz0qKdNjAPKQME4ZeGPr3PYZJzz1BOBXJOhGKt0No1W2ZU8FsSXOyMEAAq/AOPlUdMnB4x74xyxTyYk3wOmIzgBAARtOeFxg9Cc88DONq/Mb7RuEe2RSyiP7m7IPzYJJ5PJ7+v948CC7VJ94imKbEAbB/hJPPfB+9g88k/eI+XjlRSd+p0RqN6FGPTpCklrNLEpZgGRSDuXGcfw9gR9Dj5Rkl5ZY4dtxCiyBgOCMkAZxkDJAHpjoOi9ZxOzTJGxChFG8qAWUep5PPBGSDz/AHiSQ10EZIEmN8g+aNyD144A4JIOCPrkt8wmME27/wBf1/w5bkyvcL5OLmWIOzYDIZMsxAIxk4zgHk8cZ6Dg1xDKtw5BGyRWKgybWOFCledpAAPU4wMZ2r8rXFc2kptLcLyw8vKgYyTjpnvyMZ7nk5YQizS4cCXYHiIOVOTgksvA6H7xHXnJGT81YOHM/wCv6/rqaRlZFE2y2s7Q3MgRVjJdiyguQozk8cBRjjoDgkDCs2S2nS3e3is9kioWdpGIJI5OSQOMhct1GQWxnabN554tYpUWMyBsHy0IA7j3JyOMeh93qKINO63dtIpAjUxusnBIBAwykHJIX6847uY5G+un9f1/wdC+YjuYpY4Xmh8qRiDt84k9Omc49VyTj37KD7PN5i6iruI3I81WOCwzyW4yQATx34Bz8qVYmETXWyFisZ/1RSQDB5UAHPXuMde20AuYgmxJLYAgeapi3ScYPJUHjom7A4GOm0AsceWSjZ9f6+Romm9CG6hV5gzxBRLkkyHadxHJO8e2OScn7wJCpTFtjNGYnhZtrZfzMkMcnJORnGRzySflyCQFE5aOVN8whbyVC8ZDqQvKjYBjC+mOPl+VRuK26OZkuvNywZgSAAAQOQQMHsevIBx8o+/FpuOn9f1/XnV0nqMaGY2sTJc4ZWPERzjJxubGSDkEAA4LdmyAGvDaxyJcSyIQ24OmchWOOc/Nhic9zk9mbG29ITDMstygUPwB5gxnphWIBbgHIOMAn7oOGbEYDcCzlICFCAyPt3DCkgH5R0IBHp12jCnaNO1l/X9f1ozNzvqUb1DDFG9wnmh0PzFQWXuWyQcc5A+8QegY4IfaM8bEWsJZGydquww5OcjGed3OAxGScbmyQ5rR7m0ktQzdHBAXB6ZZSh4Ixxg9sAhV2pVm6meW3lu3Koyb3eNcYdupyGxkZA6j6j+Cs1Dk0T0X9fh/w+ti3K+5FPNaxKttauhLt+6cHH8QACkA4JJ7EnuMklwjRxC3SUtt2bQhABKDkg85O7B6c46jkFxPdwtMftLguXG5jCpBOSPm2n+HkHkcZ5yAEqve6XHNZ/YAzxRXKeU8kchUqGXaTuQg9GA3ZJyOc4CirT36f1/X9XJTgz8/P2y/Gerfsp+KvD/gn9m7xPqmi6ZbztqkvhrRknmnubkfbZ5blp5JAbtZJRGs0DSAqo3KkrON+j+3jZW/7QcXh/8AaNsNb0G48Mf8IiJNMj0tVu7oTN5n32tflby7rj5nAUHaVLblP1F4q/ZJ+HHj/Wb/AFH4tWqeLri7t57eB/EAV/sqyEFTFHEqRqybmUTAGcZx5mSVr4W8TeM/Dfh/4yeF5/2YvhzHeeOb7X7EwaFrlpDp2geNbC0fy4r2fLtFBcxSrMEuon5aICRJA6Rx+7gZ0K7cJK0kt/u37ev6Xa/ZOF+IKmErYbGZZSdSeGjL2vNyXamm5uE2k9VH7alJe84vXlPmxWl1YmU3c9/qkd0PsWlxWDTvdMWJMe0Dc0h+UBNrbg2AQQAfrn4V/CT9uL4EfFrwZ+0J8Jvg6JLK/vL0eMmuo7SKy0+2vLKwdZNiXJl2JFB5oMgiVZTGshXLk8H4i/aE/wCFn/tb+FYvgJ8MdP8ACX7Q9h4onsviHa+MtHsI/D9rdW2nywPLHNaS+ZLdTphI4/tPlrIOdj7GL/2p/ir8ZP2Sv+CWvjrxp+0bp2qRfEz9oPVF0ODTNW1Kef7PpkMcjfaNsrCZCIHWBhIxb/VEgqNle1hcBOniIrRuWn3+W3mtf8z6LxB8U6/F2SKMaCoU0l7s/edTnk1JQklB+zUYSbkovmacXa9jzn/gqL/wVB+G/wAbP2hLz4afATwy2rfD7Sdft73xRcWV8sZ8f+ILbbFYxqd3NlHMiFvJA8xRI4Ks0b16v/wSp8D/ALOHwz/ZY8Y/tU+J/jrbWHjT4h6pf6TdXuo6Qp0qG83faUsf+POaJFRrhGcQgAbJCPu/J+Z/7Cfgfwp4t+NGleJ/i34y0DSPBdhrtrb67L4p137Ms5mjeJ5IJMqDJED5oJLCP5GKyKGVvqz/AIJ56n4Hnfx78P8A4u/GmHWvg/4X+Jl1qj21pq+nW914immgkthcwyXVzC3zRQ2jYj3YMjrgM6bfosxpRw+ElSpO3Lytvvd7aef6dj8OyCGHxuPwzxzl7F8yahZ1FCCTfKpKW60XMktGrxjdr9YPEH7aHiT9m2DZ+074aRtPbw9Jf2Pi3QZRdRatcK8EMdoLeI4hupDKjKu4xMrk+aoRsFfPfxt/Yn8T/Hb9n3W/jv4c0rUdB0mTSrxPBPgPxQplbStENq8ey3s9kscN5cHDIqjfGBEFdWLqCvl6csuTf1i/N/Xmvn0vsfT5ZwLhuIqLr4TEUo8r5ZKTlBp7/CozS3tpK107K1j9IGG07E4HXCjp6U4JnlgDyeg5/WlC78PsyPQHk1KI5VfcItvpk1tCnzM/G3KxFGkroSGyAeWzipVClCtuMMBgbuo96dKtvK3PLHsGxTlWKIhFTB9cf1rpp0nGW+nf+tvxMpTuiqovFAaWRunXf1/WppihVVl+Zsfw/wCfalfaGySTjstQ3AzhtvQcis3FUoNJ39dS0+dokS42gqVJwTjjv+FNMpYHZ2PU9vaomaNjsGRgk5H+NMAkKEiPdyMZJHtWLxEtrlqmtyyXYLgsTn9Kik5Q8Y9PY5pCztlY4uPT0/KmtIX+YgZzxyPWoqVU0OMBjuXPfpnax5HOOf8APagqFHXcScfpRIUkAR35xjkd+acVBBkYgj8v8/8A6q5WuZ9zZOyGCOMg8nuMD8v6Uw28LHILLhudp6nmpmCrnLjg9cf0/wA5puMkDIHvtx7/AI1E6cXZNDUmhJneE5WLeB6cfjjFRRzBUBe3ZOPmOf8A6+fSrAjYHAGeev4UyWIOmGjXJBz06UpwqXck/loOMo7MdH0YRqQTzySMZqdWzGoJGfr1qJGRm2pG3XBBU+tKgTeGRgcEYPBrrpPl2MZq5IkYZt2QMDBAqRS3ZsHjoKYNrgiMZGOuadEoHY+5FdcEk1Yxle2pIWGAGB+uaR0ywIycjkZ6f4UBQV+QHOO1O3ruzty3IwBXVZNamV7PQjYQ7MMhJ56ihduGUKwPGOaHAJG4YPYZ9qBleDng9ce1YtLmLvoNCAdGYcZIH4e3FKSh7FmxnFPKZ/HjJ70Iq78EEkZx/n8Krk5XYObqMJUvsaNuCRwD/n/P40jKDwASe350+UgrgAnOcimgEHKA/hUyikNMYEUYbHYEcUsXlq2xM89D7/5xTsHPzITk9aDiPDNnHcj/AD71nyKLv2HdsbIgOQAMFT+AqJkcIEyThun4Yyff/PFTYT7iDORj0z/n/PNRQsGVT2OMZH+H9KzqxTlZ9S43SuVleaJzCW6dEb09ef8AP0qRXVl4AyfTsPX+X/6uKnAEyhgnB6DH+fX8/wA6YIAr+YM7iemPy/z/APrrlVGpHZ3X6GrqRfTUapkLZb5QTzkfnn/Pb8KcZRjawGAOg5/z+Pr+BbtIZVORk/5+n+fc02MbmGVBzn8PT9M/55pqU46ILJ6kYl3fMyj5W6lcY49x/nv6VJJLsX5lbkZ4U9B/Xp/nApkNmoZfMRFJTLFQMFsc46ccH/63Uzrbx8jZnJypxwOPb/P0rOlCu0y5yppiLIhwGYjkD5lI+v8An/8AUHuSwyduVPIY9j/P/PfioyDFJgupYj5cqf8APf8AyOajl3yOZYFTzGIVpNpVtoBPQYJ68DI4OeB139o4xs9/68zPlUnoSBH2FicknJJ+vA4+vp9cmgDcoymGBwxUEH/PI9fxNDuAjSIAgGSS3GAOuQcc4+n4Cue+KPxS8JfCHwy/ibxbfKqglba2V0WW4k5+RN5VST7kenGQpuEXOSUdf6/r8flvhsNicZXjQoQcpydklu/I6FycIVGQ2Pz9uv589O55phDF2yRgjAJORyRgf/X7/gTXxf8AEP8A4KTfEDSJpNR0jSNA0+wIJs2nt5JZB0+ViXTcScAptRv7ueMeTfEb/gpV+0zr3xI0LxnL4N0i18GaVbsuoaHeWEjW+pzbvnnmbeZURUHy/KwiJLvHKFBXvp5Via0+W6Xz8v19fmfY5p4d8XZRlzxtXD80Iq8uVqTiut0t7deW5+kpiM2WkVgwA+ZO/JOM5yT159zgnlqefN2ggZIx26+g4/p+H96vLv2Xvi54P+O3hC4+Jfwxs5rPQLhI4H0+RAqWmoRPKt1HGfuMn+p+ePMbkk/eLg+oSCSBgEc44BBXgc88npk4yD+XRa82tRlh6soSTut/U+Jp1FVgpJ77CyOxICA5ZsYx6DpkcA/4ccfNUY83OBn3A/HjGRjj+XGOpf8AMzmMPsyTxgHHHb8vf3yTgEseY1iwyhWyXQjg56DOc/Q5/E4rGS5ve/r+v67lp20GEKqlSqgAfKQSP6cdOOnB7Dk1wLswBfN6DCEDAOPfoOP58YHJsybT8ruwXPOzqcHoPXkdP5npVnSGKVWilVY2+V1xyTxgDg5Oeevrwx5GFVWdzWm+hDcrJs8/LEAHKt6+xJG0AE9cDGPujqyeYLIWkRQCud43ZBwc+nQdjjjrtBAMrjcxyWCuDyACdxPAzk5B545OfU5IpTW6z72EZOVG3b0kXJwBzyOWPrnkdNx4ajdjqgkOaOVbiRAkbCQljvXg5ABPfjaSCDj1OB8phW3uJw8Jum2jayiY7iTwSSG9SOh9sgABDYcyTKJRbAOXTcpXdzx8ucc87gCO+cd2ELJG86XyYypUFwy/LgEj7uRjIJyDkZ44Jas0pItO4whrgRxo2CrsSzyls8EEnPUZxkH8eMI1a4leBnli8vErOAJCduDyeMHPUZBwTxnnC1bSQi6WOSIOryZVnORnaeQcdgRzxwTjjLmrcxTefsYEoynDM+DnqOwHAI5B45xgZasMRzqKtv8A1/X3GtLlu0yMSvE5DweaCjAeYDx03lic5yQBgjORjnhBWtPt0hns4zIuB+78zeSeoBIYnPRcqQecj5iAosNA728USoQY0wcH5BtwQQEAAGMYI6DONoJYxxsrk+VAIWRFWNQ4CKNpAJIB2jHIPHy5Pyqecrvmtc0skge4luYNoKRSAEFmY4C5wTgDqW543HPB3NwsaS3xud9zGrq0mXZBnau4HJJBJPbuRjPLcK+QGGRZCH8t4eAVA4GcE5AwNmB0UAdSq4ymxZZDBtJB+4kiAH65UALhSQOgwOdg4OUkpW5Xb+l+Vv60Li+XdBdXTmdQluixO2NpOC46gd8knd64I/iYnbGk4guBbSbgPNYx+SGJXKtlcD72WU+uO25vnEi7XWS1MZEmcgyDhiv8TccEndyccckKvytWszdGNTKd5hYo0kkaq5wp+bOMA/K3UKrBlztUhSm5KUVFafqNKNm2Pez1KSKKxiKKUIO2LKnqcccg52ghhkg9NzfMDTRqF1amHULQRMoxKiYJIJ3DjkEc9eT1xnl6spEYYobmGaRUUkuX+baSoBPI4yMcHGe+AVQv8mS2nIhmOZAW2uBznbk/U7hnPXj2SlySjJOz+/8A4bqHMnGw1YiALuWVoywXzI4gWCDGcAKOvJwQOnTj56ljMtrMhhhjiQ4VFib5QB0xjp3wRweowMyGO3klEktrMs3mKrKrttyR/E2DkY+bJzjt1JCB6LIyO2HLgnczEgL8xB4OeemVOemPnJ2jW3Mlb8/6/ry2i9n/AMAjkge3It5pI8HGxmXJIxjO5eRjOQRt4OBtGWPNax8T/AegyLp+u+P9B0xwSSl7q8MBUKPm272UELkDIXGDxhSSei1KzSeGS2MW6MqFeJk3jlsEnII3fd9ckfxt8o5+0+EvgDRdR0zVfDPhKxsV0e1lt9OtrCFYorRJzHvVYUGAWMagcEj5iMtnGM0ra3t5f1/W67HTQ9je9S/yt+p4744/bj+F9lqul/DOfUDHqPinWJLTw/qfhjVrS6WTyyFEskoZIbZG/eIAXBIjkXKBk8z4K+NXwr+LXiH9qXwv4Y+Nf/CL+HLG8tYrSPV9Cmk/szVjGGXynuJWdI5fNEcTySKpQguyPwz/AKTfFn9lD4I/GDxvonjn4meD7fU5dJtZLWG0aNfInQs42SKATIAzuQhyAc/eOa+CP+CiOlfBfxvLZfCP4PeNdCXwrpd1eXEdp4cmkgl0vXHeadrpZ48eazi4kVF3vGN8iAb8tXq4GtQ5lTiml10vbfX+vwZ+yeH9b/bkshg1WlTl7RyTioSV3FQqLmSukmvaJRbuuiPRPh/+yX4I/aK8ceD4tC+F7xeEfDkY0y5jttPtFvNTEVwZJNSFyt5H9lMlw1zJFJCfOCeXMCyzIi/k1+1fDq/jL9szxP8ADH4QeIPGHifT5/FM1n4ctPGV+tzfwyyvH5qyR27GMN5gKsAMbVw6hlIX6q+CfjH/AIK5/C37b8Kv2YvFHjPxgsPg6SZdHutKhsL7RWlaNZHWO6jMk+0oixlW+ZH+QKWOPn79ib4T+PPAP7eeo+FNb0HV5fFfhrRNWvI9Phs5YLuW4S1ZpFWO4RWDGF5SN6nOQcMMA/dZEnh41ZyqRnZXVm27ab3Sa+e/mfnvFqzDEZhQwWIi6cYuMY3iovknKUuZ8rcZqXM2mm0lomlY+yPiJ+x94G+H3wG+GmvyfBDSbPxjo+tyaXb+A9L8GN4hjvhb21zPdzaqbBZTf3DF95G1VtYbgrCIW+dt7/gmJ/wT78C/HzWvGHie5+Fw+HEGkfES2t5/BniGxvkju4P7MM0qQreCK6iDmZSilnkiRt299kTV9hf8E4PhJ/wrf9lDXf2lbW20uP4ma/HqMi3+u2L/AGCIo+IxDb24R44JhbxSOIxvcqvURxInJ/8ABM2w+HP7Rut6r+138RPh2tr4h8L/ABR8Ux+GJn1m5voHM7wwS3VoySFfL3LcQhmjclYV2FAhrjqY2P1Wbqzte19dFq2tP89RY3GTyPMqtHL/AHZYeVSCmoR55NrlkmuaS5d4ppvRt7WS+xPC3wlg8CeF9J8B6HoVmNI0i1js9Ot2BO2GPZGC3zKGJVRkMfnI3Hn5KK3rjx/obRZltrgjeqlkZdkhIzxhtxHGMYzyT0BIK+YSytSfv39b/pCX9d9z4irVzKvN1KifM7tvu299ZLc6dYnaIvE3J/ln+dIIboNw2PTJ7VNFMJEyh/KlbOcf1r6z2VKSTu/kfP8ANJNjTFAz5weCMYNEiNkkdcdSKHUCTCjB9uB/9eldjjDdx0FU+USuV0CrxMpZuOe3502RlIxsPOehqdJI/LG4ducDrUTqGO/AwCevauWUGoaM1T11ITCGYbXO/rkcE8epz/KntH5XPcngY/z7UplaF8GPPPZCf0pFHmcgFtx45BAGO2a5lGEXZbml5PfYiZHK4YHgZyv/ANb/ADzRKilCVI3EDPBB6+tThGx5nOQM7ep/+tTWjJQkgDAGeff6VDo+78hqepXEOG67fmOCOg/zzQQwHzLnbyMen+RT3ALA+vak+ZRtOTz0Nc3Io6G17iKoRQNo6DA6j6D/AD/jSrFu4JHJA4oBx0GSB+B/OlYbWUKQMnn1xVJRtcV3cWNHY7A4+U4JxQ8IAxuAPOSD+tLGhU7nBYgdv8/5461JHul+YNkE8ZGe9dEKcZqzWpnKTWoxIJPulhz1pfIcHdvBJ/vDmpRGwGSvc9D704ruOG9OuOldEcPC1mZOo7kcaBQRnJ9c5qRVYfLv698c0Kpz0x2OTSCP5sZOcDNbRhypWIcrj/LbGUPbqaTlsZAHPXNOZGVcYAJzyB3pPL3uHIzx69K2s1oiL9xDECQdy8HPWnKmSdoBwP8AP8qaY3T+HHsasaXY3OqahFpVlHvmnmSNFB6sxxVQjFyStqJtpXuNTT7+eFrm00+Z0T78iRMQv1IqNXP3x1z/ABf59q+J/wDgu3/wX9+NX/BKn9pTwT+yt+yV4R8Fa1LY+FF1XxuvivT7i4G6eQrbQJ5FxC0T7InlYktkXER4wc+V/AL/AIPE/wBnzxzJBo/7aX7DmoaQ7kLc+IPAWqRXyknq/wBnuBBJGo6kCaQ46Anivonw9U5VKM9e1tP6+R539oxvZxP0rAU9Rznpn8qWNBnIYjBH41JonjP4K/G/4KeGP2pf2aPGceveAvGFss2m6hHuHlliVKOrgMjB1eN0cBkkUq3PAhWJyd5kOAO3fr/n/Oa8Kvhq2FrezqR1X9XO6nUhVhzReg11w5+YLj8h1oaNtobAPHqfrStG6sO59z/n/PvSxxsyc846Hp6/5/zmuX2d5NWNuayIWSUSH5sgj7pAwKRUQ4UsUJYBRjpjj8sf5ApxTBK9859P896Ro9x2gty33h19P8/p61zODXS5qmIyocyKR19M9vr9Pz/Cjep6jt0P+f8AP6UiMkK7I9u0dABjA9v19v50hboc9BkgY/z/AJ9M1nzW2+ZVmK67iD36H/P+e/Wmx7VyZGPTk8+vTn/P9FON4ySM8DjtTvLG3ByTjn05/wAn9fxOVuV0gvZWEO3aAWDErnk57Dt/OkRFdSyoOwAI/L/P9aayJGTIp5Jy2RyTj/D9PQVKIW/jHOPQ9PT/AD+gojFzlsDaSGBVLAMqEEgjK5z7def8fU0SQxyqU6g9eef8/wCeTUiowJjB4JBwf8/T+tOLMqkyI77R/AuSfYe/+fatY0YyVmhOcuZWOW+Jfj/R/hb4Vm17Wv3kihhZ2m4hrmQAnaMZIXALE4OAM8nk/mj+2J+0d471PU9S1rxdrEc41LENnbRIVFtGQSIBFuKyR84D9T8xLdTX2B+0ZbeNtb8X3eq3F+tlBb2yeW7EvtRi3lQoAuVaR8rvI4l/dtj5N3y58QPgXrus+Irq5+J3hCbzvKaKwWK1P/EsUDJ2qAfmzkyDtjgbBXZGWHwKs009r9D+pvCfh3K8lgsXiHGVaaTe14rR8sfzk09fSx80+D9W1jxCW1DxVeMktpDi0Jw0Vqedm4HlgeglzlcEcAEV6G/iWU+FhqVvaSTXW82ssDSFTcXDqBGMDOJAxXDjqo56AhviL4C6p8L9NvfExuN1haRC4RVbK+XwGljOMFOm+LqoIPIALcx4dutV/t/TdW1mxaGxTEulQ2yZWNWwVkbqQWBPlg8x9ONxA76UuWC13/q5+9V54XG0f3Vml/lqfpd/wTW8W2eo/sz6f4AstPtLU+DXGklbKBYknRUWVZyqgAM6yZY9S25icljXvzhCPLQYbGVH4fp0H/1up8q/Y1+Cl78GfgtBFrts0Ot6zOdT1uArgwzSgEQ8cjaoUHr8xbqMY9VndVYMrE7jtDLz/nn65Pqa8PEqLqScXofwHxVPLanE2Kll6Xsed8ttvO391u/L5WGsA+GzzvA4AJPvn+vHHoOrTy6iRSqsCckdsZ6nA6fp6DgyOylskg5fg+/0H5d+ffmoRKiyNHGSzNkgc9RnOcdOc/jnGTkjkmknZnhRu0IbcQM6opCFiXYjp65/z+QwDAY4irCVBtxwzDOM9SRx1x+I9BgGYzGYhVJOBhS68N/hzn8+PWql/qNvpsEc0ocJ5m35FP3j3+Xt1/E8cjdWMaMsRUUKcXJvZJXb8kVUrU8NSdWrJRitW27JebbI74P9mZ4eSsZO+Rd2OxHHIJH6j0+UxTQtPIXjidCVYYKDOSMH7w649e/B/uVbuZRkMobJX5QwwM59ufw/LHJrNHiKxm8v7PNNIZjiPybRgUbaXG4EDacAkZCjGORuBbz5QcpO3kdkZpNR666eStf5K6v6klypik82d2CKFDNMcKAT1OfqeT3AByflDWZHkNqY1baTiRGztOcE5PfIIP65PyjIsPHNhP4QHi7WrG+0e1jgMk0OpW4glt1ViCZEGNuQCw/2cH5RzWrDqW+2int41dOGRox8pTaCpGME8AHBx1/hGMzVo1qUnGas02u+qdmu11f+rmsGpw51t810TGybhZrDHCMLyE29PrwfmGV555/vH5RG7RSxi8ERDZyAi4IyRx1PqARyM4+8wAGRc+OdSgF/q9h4ffULOKBJdMl064Ev2tSDuwSFGQQMpuztGflBAazd+N/DekTacmtTx6Zd6o/k2djcFRIZWTcEwDtYheCM49wpAaq2DxEWk1e9rWalvHm6N7LV9tU9U7VRk6ivGL3as007xbT0dnbTR2s1qtLE9zMXcTvbONxAwODg4OFJySd31yR/E3IrPFHHP/Z7wxsJox8sUQ3EMxyAQTz+eTyN7ZIuSPG0UqsShI6RpnjaNxIwCeCOuDwAcLhS1odkYkmOxoFGyVm+6Puk5bBHA6Y7gHaPlrznTbev9f1/w3Y3UrIgeWTY8RcGRgqgBf3m4kjaByGGegzyc4zywQj96pZwkpIBI5ZwzZAUdeueh9cE/fFidUZfPu3ZAqbpfMj42jhhg46jvz6Hj5C66mmjdppSBEyjzMnJALKCS3foMhjkAAEHIWlGKlHXp+Y3LX1K0WyQpeyRrKjS4MqKSc9lUjqud3AzkjjOGeorXy45MWoMsRkKrgBgzBc7QP7oCMevc7ccvU0obfJFKiozAhmlYkr2IB68nIP1GQThBFDcXE0fkQORKCxUzkKc5Ixk53H5cEgEjcM5bCjNWei1/r9P6vqVqtWTC5YSrbNbRIwTbGzr8znHGwKDnjbkDHU4xy9D2zzQoIySwwEDsDtKqT8oJ4wGPHYDsCzs62muZEWaWNvMG1nBbBHPTb9dvJJ99zEKJZLyGSEOI0aMxjD/AHTzjA3dxuZeeenO5umjjzU7L+v+H/4bqiU+WVxoT7TAbiAphE4Y9mVTyRwcYY9wQP7vJMkZgQRXdoxDNDJtwMLjBHGCM4yeeABn7oPzJNNAjsoaRUbAY4UjcTxjJPOSRxnJz95hxO8huJHs3kUkKpAAKnJfjjnI4IByeeRubkaQukv6/r+upEtSsWuJC0jQbY3fCqc4A2jnkDA6f3doIJ2rwSWEQExzIJAWJjJA+XgDvjOAeM9uu0bQZFBdCeZSrAh0UEt/dG5eoyByDgkkDJywrpJEFR7d1EpZBuXbl8ZKnAzjnpt4PI5yXGU1rtv/AF/X/DFR2Kgt7V1ZJ513hiQJNvRd2GJGc9znjrzgbYz8zr+wo1h+174f+PXhy80OHwtpVtNLceHXsm3G9AO2by8+W8vmZkE/ylDGi7OgX6YdbEh7x2Tyt+1mK7QcFgOBjHRunB/hxkyGKzFvLqIt5TIFXPlOiZ3EjgkgDHCuuAwHPy4ALnCHNCb5HZv+n/X/AAD28szvMcohVWGnZVYOE1a91JW2fXs91d23ZW1bRI77T7mCxaK2uLzS3tW1ARb5kyjKTv3BsoSCCehfGMkIPxP/AGhdZtf2Hf8AgqT4M0X4Iaff3GqeIrFdK8SeJfH+j3VnNfNeT3OlzvbmYgrCIY4jHPGT+8ViGwSg/byGEpCi20xywJRRMFWQhSwIOPlGAOF4wDt4JZvxy/4OAPgP8YfhR4k8Iftoaz+0HLrWrxeLzY+H9LtdOW3g8PWwD3Vl5SgyAv8AuW3SMV3lV2oVGa+h4WqQljnRk/jTj1s3bTZbfh+ByvE1KWDkubROMraX00dtH9lvRtL16fpR8Xf2o/Cn7FHwg8LfAzwFo0viHxm+h22m+FNEguBFbtMY/IgmuZbqYm3tjKMMxkaQYPD4NeLf8Ewz45/Zi+C9r8IPj/Pcar4h1fxS1+fEfh7Vn1WzmttSYyw6g10QVihnnW4jCsNzTMRsO4V45/wT78J/Er9prwlF+1D+0J4eXxbqPxP0O9kvLK0htI5Wu7e+Y2+8vKv2S38o27KsRDsXyQsaqz9H+wzqPxB0b4o+H4fjNrPg7VvCh106LpS3mszzX2j6vJb/AGi2jh8yFImV3s5PKdJGIeR2jIErlorzqU6VXCTak4u77txTVl5b9PvPsKnD2R1sllmGEqylOEabqJp+9Ko5NtWXucjSjaTtLdO75V9+63Fa39xNHe3ausqtG/mDf8hO0hgwK5JBG4gjpncRtUpY/O+yrZxrtTzt1sWfKscgNtOAE43EfdHuqjFFfJStU96V2/JX/wDblY+Oi3BWjp/Xoz16MqUxGuAPWnKWXlpBgk8fnVAXD+QRGMBskH0P+NNR3Y75Z2ORwA3Sv0n68k1Zfoj4r2Dd7suTzwq2BJlsdM4pheOY4AYHOfXOKhnaB+GTfg8BuKdA0IcYj2ntzR7ZzqWdrf1/W4+RKN0PLZjyF4HoDxSSNhflcnk4bPHao1glx5jncQevH6UsqosYFwm9ix2gc89cZrNznyNtW/r+u5XKr6DS4VgZFPJwCTx0+vtSeWSeTuxz1p4jh/itsjdgbTuC/nQ0LEfIisuDkHFY8kmrvX+vQvmXQfBG0UXzr6ZTrilLD5gEHTpn3pioyKflBH93HFMk3ImEiQcYwDnH8q2dT2cErdP66EcvNIGYMeTj03dMYHNRmQtIVx19+9LHEXUsxA5yBjnrUcskcEbSzEAA8s4AA6euPX9a45Sm0n3N4pXsifDADnPTgVR03XDqN/PZvp08P2c5Eky4DduM/X8arand69barb2+nWkBt3AMomc78A8kDPT6CrrRz3Uiq8ka7Jf3gwzZXBwAeMHoe/f61osRKGFqqFJSqWXLzScUnfuou97W2tftuefXjialaMqUnFReq5V76a6N7JPW67WLqeTsOWBJHQnrWfYeJrW/tJ5IrOZLyCFpX0p2QXO0dPk3Y+bGASQDkcisb4mfDLTPiJBp4ur3UoJtKvBe2X2HUpLdXmQfKshT7y5x79cH1b4U8BadZeIJPiL4o8KaZZ+JtSi8ie+tckywqVCg5JAPyqMjqFHNehh6mE5VCcZObTdlHRNW0cr7NNu9rq3zOirTvWpqlKTbUnJcuis1b3tel9LLrvYtnxV8SpfiDp2i2fw2/wCKdutNM97rk2qRpLaT4YiFoBkseFBIOMsf7vN7XPG9j4Un0mw8RW1z9o1i/FpaGwspZ0Vz0LsqkRr6s2AOfQ413IKuGk8vHAb0pLaWZrqeJ5SwV1Knyiu1SOgP8XQnPvXpRrYepyp00klbRu731d3Kz11skrLRX1fIkqdZSm2076XS3WnS+lvPrfynAbbtJxjpn68VxnjDWPEOtaotp8NfFYN1oF/CNf0e3tYneeOTawQvKyiP5MtkHv6jFT+A/i/8PviH498RfCjwt46hvde8NPGdcjSzdEsBK0gjRpGXy2bMMgwGJ+XkDNadlosUVwbPSpbi0gtp/O8xLwyGZ3dnljZZAw2cjnORkhdgHO+Fn9WxCqQcZct170VKLTTT0l6q3u3W6s1cWIwqq4eVLEQnFtRlZScJLWLWqabTXRSV09bxunTvdR+Ki/ES2tLDStJPhVrY/a7syt9qWXDcAA467eMHgnnNFz8XfCtj8QNL+Gd9FqUWq6xayT2cb6bKYwibs7pANqn5GPJ9M9Rnaufstlp88cE0dl8pAlCABCejY6HlvzJrPsrXVLC5tb7VfGizWsURDoIUQSO2cF5CT8uCuAMHOCSQcVzUcXh6lRKo1eMdUnZ32Te70d76K9mtGVOvF11TVK6ta6stb2Terbet9FZpWumbTMVG7cRjitPxL8V/hL+yH8EPEX7ZP7SXieHQvCPhHTZLlp5yN9w/3ESJSRvkkdhHGg5eRwB6m0bPwF8MPh7qnx8/aE8XWXhfwR4fsmvdT1PVZvKj8kdyeuCSAAAWcsFQEsK/mp/4L6f8FsfG3/BVH4sx+A/hrJc+H/gj4J1Jo/CXhuRvLm1W4VSn9qXSKcFypZYowSIUYjhpHLe7lGXTlNV6ui6Lv5/5f5HBi665XCHzZ80/tv8A7Vvjj9uH9rHx3+1Z8RQY9S8Z69LepZ+ZvWytQBHbWqt3WGBIoge4jB715XgHpn8q9U/Yp/YB/a4/bf1F7D9nz4ZS6rp8N8LS71u/1CCy06xk2CRhLcXDqi4QhyoJYjopPFfrd+xL/wAG2nwG+Afi/Vf2rP29/wBoGy1T4N+CbGKZtSOnyadbeIbwf65LcM7Ty2QfEUc4WOS6LHyYgrRyt9Q5JI8yNJt+9ou56v8A8G59r8bfgJ/wRq+NHiT9oPT7zSvBj+ITf/DoahIMyXMlvCjeUCSVRrsWyheP3vmjG7dX3x4I1dtd8LWGrvw09ursD155r5H1n4sfFH/gpd4+0Pwv8PPBD/D39nnwRcQ/8Il4SgtFtn1LyBtiuLiOP5UVVH7u3X5YxydzYK/YOiadBo+mW+mWqfu4IlRR6YFfJZ1iKVbERUd1oetgqc4U3fZlo79/Lfhn/P8An8qaA2Mnk55J/wA/5/SniRQSNn0yabLcQW8TT3Mqoka5Lu2Av19K8aMFN2WrOuUlCN3oiNj82H7nkg/5/wA/lWfqnivwvpM91Bfa3brNaW32m7txIGlSHO0MYxltpIxnHJ/AVlfETxH4DbRLzQvFms28EO1Ddy3CSeTCv+sEkrKVCJhCSxZQAOSK0LCxtL6zE0TwSNKMxXC2o2OmdyEckMBkEc4zzx1rnp1sK5Ru+ZczTs1o01dX1V901a6dt9lrVhUpRSlFxcotxbWnSz3TaflZeZpRlJIg4bIIyMr2/H/P8qhuL/TbV4rS5v4YpZ5fKgjeUKzuVLbVBOScAnA54z245/XPFul+BYtB0jV7LUp117XDpkcoiMq20rrK4812KsI22FFcK3JXPBzU82r/AA00fw9pM+sato0emyXEFroEtxPEY5JHHlQpCzE72cNtXackNj60qFNScZ766L/g/wBehq6deSXs03d6aXvv2b10/rc39pwHZfXGT/n/AD69aU7DhQ+WC5wT2zyen+frXN2Xh+W48TyaloPi10tILsLeW8TxSMpRNv2PDRnyocFZNqlWDdwDg615aS/aZr6xjglvEUKjygjauQdjbfxP5VnKMIT5Vd6duqt3fXo1cxqe2hb3dU9Vrovu1v0S013Lv8WMkEAcbep/z/nPNOCl02njb0Ycfj/n/wCvUMV5HePPbmKTfbsEkLQOqltobClgA45HIyM5B5BAsEMvAGM+p7f5/wA9qSjqzSXNGyejGsI0Ay45C4yOf8+n0/GmkSKAyruCkEqP4vYcjBP+fWpREOW4GSOe+ff/AD/hTZUZ1MZO1j/FgHP5/wCc+vSr9m1rYUKjhJNdDxHxb4l0zWPFt5qOoaistlp8E91HcvDHIIZJSULyxnhkXZKsyDgM4lBX7y4vgrxTo228h8WGFE0+0jcXeouwjSPe21Z5T/yy+VhFdAdtr4YFW8U03W/jl+x38YJvhb8V/DOveOtL8Va2IvDniJiz3M9xNMzBvMSNg335CV2748srK0W1q9PfwrpfiHUrXTfiBbXNraQXG/S/DNlpLLHbyF4yxxLl5pFIBW3Ki2OAygOoI8HH4DO4cRQr+0XsdGtXaS66bfft99/3zh/M8rznLeai2rJKSuuaDWrXKtd72ekWtVqrHhf7WPhrTfG9lquvMZtM8Jy3KS6XpN3H9mlvLnaQZNoP7k87ljbCy58wBc4PoP8AwTm/Y+htNNsvjb4+0mRYIcSeGrK5T/W55+1MpAIU8FEP8S7+MIx9Nsf2VLv4q/EGy8S/FiyI8NaHKf7K0m6UGXUQCCrTpk7YOh8pyz5yCcZB+gxBFFEtvEu1ET5Qi4GO2B6emP16j6GtWSp8kfn/AJGvGfiV9V4fWRZXUvKa/eTTuoxtbkjLrJr45dLuK1vysl2ITIQqts5k8vGP8jOenHoOrJmSQPEz4I4wO3A49+nPsew4L5AZQyA4C4PLHsc5OPp2/nk0rCB0+QYAAwQfxB/z6/jXmTTd7bH4NF2sM3ARsXO35vmLY2rx0/L/AOvjpWzbfC7x9qFimqWfhK9likAYN5BG4beoB5OR3/wArN06W3sNTt9Qu4fMgguEkkgAB3qpDHP1HH4/8Cr47/4OHv2iP+CuH7I9t4f/AG+/2C/2ovs3wWi0200/xJoVpoOm3I0i+edkS6mW5t5DLDM0kUPXMUihSBvBr2cnymlmnP7WbVtrfPX+kcWNxs8JZwV7n1r4jjvfC08MGu6NfxPPcJEY1sJCwLHA3KASE9WOAvc/w1QWLUFkuPtN5E0JOY0MYAEfcdeg6ZI7c9hX5s/8E/v+Dp/w1+0feW37Kv8AwVx+GOhDQvEbpYp8SfDiSWcVs7MArX0CuTEhbGbi3ZBHgZi27nX9SfFfwwvfhbdJ4ZuvE8OoWt3G9xo+sNp6jzLfd8ifKdrPGhRSRwwIfC7sVnm/Dc8BQ9rCfMr7aK2mmt7d1ra3z06MJmGExNJSd1Ui/h1tJW3VtNNbp/3Wr624vxT4S0rxro7eHtTu5ihCyCe0vHhJdHDKcxMpI3AZGcHGCCcAZi2XgjwBp+seJ9Y1zS4HhQ33irUokWMYVSxefOSuF5JP9zJ3HgZXir4mWUp03VPDmrRT6NNbzHW1hgYTx2au0BvLdzhT5Eu0yIAT5b7uMKsmUvgux1PwybPX9CbU9V1WAeFvFGoW0Atv7QtpI8fbJFIjB3KTtClgDN5a9xXydL9xQdO/LCzSinyxSuvs3UbaK2lr2R9LhcFOpyqalaOiSvpdq71aV7K1972XVnb3Xijw4NHTxWPEunnSjtke++1x/ZmRjhW8wkgruPUHk/3jwMPw5480jxl8RPGHw4GiajbQ+GhZpLqJVGhvJbiEy+VEI3z8mFDMRuDvwHODTNN8C6f8Kv7M8MeGrZpby90+O0W4uFxZwiAy3D5jRlIkcSznjlgg3YVSDTni8deDvFi3fhDw7YNpWs+JJrjXBceZH9jtfsqp5+5QQvzx7iWB3Exx4jEgKdNLCxlVm6bvBfDdWbSas1pe9u3Z73s9auGwntJxoyb5ubkbdtE1ZtLuk0r6X7NK/TaRpPlpEEkUKMSW0RRsLwdo28kEDaCf4mGcFiWTK8TeIfDujahbxax4ikjkd2ntNOVkd7kKMEqgDSOi7wSyg4PUnkrf8IXOrfErSzFD4O1rS9SmiPm6YbRZLqEM7LF90sqSOipIY2O9FZA4XKqZviD+zj45vvCd3r3ir4I3V7qdpaXNrpl/BYy3F4kMo2FkkijSaFnTBdUIAzt3NtC1nSy7EVsY7qSi9LKKla69130Tj8OzV1do4a1FUa0frDScZJ8rly3T3aeu6vZpSS0fYbZa1pF8ZLqyuI2+ztsuWkRl2tgkEjjGMN0BPYZ5cTRrZ2d+2Wjy6rkbApyM4JwewAx6buMks9cnZ6n4IstQtNGubXVn1GzP9nPYSQXRntA7BQ88Mu5grGDImlUjGGzztPSJZ3reIGuHu4zYR6e8LWbocl93BAclABgghlY+p+YIOSpltTC0YrEXU7y3jyxauuWyvJ3d9b6bAsVTr4qUaDXLGKum7yUtbq6VmmknHRO9+iu7e1FkFvDCVyg2uicrjO0gL06cYx0OCPvmCO2YeXbLKjCJwQHiCkt1zgEBcgtghTxyOhY3VikmTzo3iY/MpLZcghyNucZ5KjIbo2cliAKrXFnZm9WWNt5kdQzFgQTkfLnk4DDPII3AE7iABxqMlG3z/r+vvNrpsicSh47iHEbLJ+8MfROCQT07ZIyMY5+VfnL/ACoIniuoZRlSdoMahgdpwe3OAQBxkHsvNW200LMyyqzeaOA0ilQT/d4IwOR0JJ7sfugjbyvscy+cgJcI2WHQnGf4lyByQeRj5jyqlRhHYFUbM+x0+SxuyyFXHlnZIzfKh2j2GDyvoSP7gOWnsrRZpQWmkG6LfxkrjBHGQvaTv1UfwqPmtvI0q+TFIGKsQrI+N5JORxnI3EZ46jjcckR22q6RfXH2fS76C5aJFaS3glRmTc7Lv+UkjkMO/KMBkhmBCjCMOUJTnJ3I44SyOJPKiYAgqjneOACeNv8ADxggA5A+UYBlnuY5o2upJRhEbOIs8Hqh3cjoAQR+XAMtxbWxdGjK7XjUnyxngk9eeBjOCORzg5+akhhWN9tpLl2YhGwAW54IA6Ljp6ckHq9Xy2lZf1/X/Dk8yauMjkiW5LwoV+UK+cgFu4OcYP3c59gQMBCyS3S5u28y0WMl8SNt3CQHrz9MEgnAwM9kqYxxmZ7a28uMKy7Dt9+DwehIOPTkjH36jSF44kiWRTjHfDqMHDnBGeB2AwMngZYjTTstQTTKrQQyf6NJGgXHyHyvTqoY5PReQemcE5wohKRquWt8tGrb9xAYkNkr8x5yVwd2SOM5YBRkeOvip4I+HWgat4o8W+I4tPsdFET6ncXj+WsSycxkM+wSBs4QJySdq9cHzLx1+1n4Qj8FT698CdTtvEWoywXMukiJhLDdfZbf7TMo8vlJGVXRYjiY7XkWMxRljz+xqzeiPYwWV4/GpSpU3ytqPM01FNpPWWy011e2ux86/FD9pDxz8KP2v9c+LGpDWtK8AzahJ4QbXJtWe/tU1KCGG5KCxwrQF/IZGaUFSS0izEuFPxl+2n4v/a2/4KWa14m+EEmveHNZ8N/CIT694n8V+DrdxogUSyxpiW7dSZIoHu13xljI0RVgxjaY9H+1j8dvir/wUP8AAUvwq/Zp+FT6n8QvC1nqep/FTxnpbgW9tptu8scVhAsZc3r+WYmGwSSKzERgNJNjlP2a/gx8Vvh98LZPhv8AC74TeJdP8ReIfDkXh/xpomr6U0ci3kz+eJDE5DPGBCrMZ18lVuCj5jk2n6vB4ZZdSjiWrVdIpPW2/vNb7bL522T/AEihgcLxHmCy5qHNh42nKTiqc405QhGHtYtWUle9W6TXKkk7s+uv+CQfxS+FHhjUZPhRFezJql14Ps7NvKsrp2hTS5rpFM1xl1x9mmiAKKsS+Xg5kOa9t/awvPgdq37MHin4q/DXUftF/FaaZrDw6L4gm0+9e0sr+O4eG23MotZHje6USKqndISXcgsPg39mn9oP9of9l/xNYfCTW9An1k6bqF1HdeAUtXtdR1SV7pI5rJpbe2uDcswimj2YihRriTMpChV91/aGH7R/7a+o654Ul/4J8eOvhpf61od1pvhe+0vT9Okmurme2lEjanqss6/Y7T94oaJYXkdS2yQMwjPFLL5PFRr+0Tu03qulvRtW+701XNxlTy7A8R1KlCnOhSafLaSlFqLfKkmo+62oreXLyt3k9D2T9if9sb4tfH/UPDdsPgtHp/hM6Axu/EVstwIZJl+WGGEykh9jRyRsuXYuu/fnGSvRv2Xv2IYfgFYvcXlpdW04L+XpXh+e5i02yUxKhWTcQ13JtTcbiYZYkfKAscSlfO4pQpVnaLS+f+T+8+X4lxmTY/MubLYKNNRS0T1d2+Z80m7u6TtaKtZJpcz+sGt5AM7ByOB/KhrUOMSD6CrHmLnrxQWU4wRj+VfoLoUmflaqTKxtgRwg/H9aQIAQxi/IdKsbuck5PHFPIVW3FBx04qVQhcftH1KaxADmMHA9Og701oyVwVAwDg4q6II5QMfhR5ajqFyO+Pal9Tug9tqUUgeJgcsxXgM386kcFs7wM/zqz5CYIAHsfSgwk/xkc8dKUcK4qyG6qbuysYgqYQZyM9emP/r0jxMYypbGcZHtVl4GKhXPGDUV1HJFaSGCLe4UlUBxk+mT0qalFQg21ol/WiBVepWdCmZGJ9iX6d6x/H/hyPxT4Pv9HOi2eoTNAzWlnqJIgknUbow5XJC79uSOgq/oniDTNfklTTiS9u4WdWQjaxzjnvyCM1o2dpPqUyQafG0zyN+7WMZLHHSsvqlalVSlF300afXVaaPU66WJnhq0ZxdpR1W6at+KPPvhX8RrzxFIfAfjW80SLxrpNukniLR9HmkaOySTJhKl153LsJGTjOM4xXXrcW41lLRtScSiAsbVVBVwSMMSRnIxgAEdeR0qPw3q412O5um8L6lps8F49rPFqdoIZWKcbgCTlOeD9fes74t+KvEngbw5aa34e0Ca9B1O1j1B4bdZjbWruBLcFTLGSEBydu9gMkIwBp47DVI15ThHls9VvbulZq2u172WjctzoxNelicV+4iqa05uZ3im171nZJRvfl3cVZNyau5p/H+iQapq/h22f7XrOj6et9caLZSxvdvC/mCJlQsMeY0UiqWKglDk8GuV0zxX468d3ng74v8Aw28RpfeDdfS3e/0a50pRPb20ttOyzrJnekgna3V0YEKqyd+mJfS3/wAQfF158XPBum2sereDWjbRdTtro/ZPEehXMMc0luZXRFO4/MrqWjSaKIiQ/vox0vgnwnN4g8PeJ9I8OajDp+ka1aTtZTWUsvnaZc3EjyPuikAVSTceYV25DGRWJG1VmFOVNOT6Le19Lq+y37JK8tldnRh40cPC0pxUnZPm5XpLeyte9veTjZpKUdXvxngy0+NOgftZ+LIJPG2o3/hnVJ1vNP0W6cTQWsZsVQGNzlo1a6gm+RSB8x4r0zwvLrniqy8F+KfGOs3Hh7W5dLW4v/Cttdx+Vc3EturSwusieZIIWJIKlSCMt6VofCvQG0bwVZNqKM2oyQyfa2ljG+FjNI5gyAMrGzugOOQue9aHwY+Dfivxx8Qtd1PXmWc2urf8S7WJ0SE2mmvFCzQJ5agvtcSY35JJYEhRx62FlPMqdNUqavGNn0u9WntrvHfVrexrmWKpTqP20Yx9jT5G4Je+43gpWe/NzRu9ZWV15eVfs4aJ4M+Gmp+Lr3WtbtLTUfE/xFuY5Lm9mSFbq5eIXP2a2JOZwrPcMAOQfNwMLmvXINL0/TrW4XQLSK3M8jS7gm4Fz3IyM/TIrgYNC/4J3/t9Ta/8BP2XvjJZa54p+GOvC/1Kyt9Rk/0wNMsk5t5OFaJ2LWxuIcrGJGUYEiMa+l6P8SfDvxR1zV5vESx3mtNAsHhW4to47Dw1p1vJIZ725cKJHuJSXwm8LvYjBVJJE9rG5dUwVR01dJ7X6+uulleTey73av58MPDPU583JWS96Mm7aJJOLtfWN5NtJRty3bcU+4vNWt4PE0HhqXw1fzi9hMkl4sG+2QqD8rMTgHjpjuKy9K+BTT+M/GHx+/aY+O9nF8FPD2hC/m8N32kxWkGlSW0YeW5e9VhI8YjSVmU8Ylx2U10Fp4Osfjkz+BoYrxtP1aFULRGe0ZEDNucSoVkXAUdMHjqd1fld/wAHUX/BWDw34P8A7L/4JT/AHWpZdI0N4L74s3djdAm9uU2zWukM5JyqtsuJ+uX8lM5SRa2yjKaXtp050Yxg48s+aKle75npKN4tPV2s919pnzmIzGhQw9PEYOclVi3ZxdttmpKW7u1aySte7vp8d/8ABcP/AILF+Ov+ClXxgubnSdT8QeGvgZoUJtPAngVrswPq1xGXA1W7gUALJIGwqsWMMQAHLv5n52aRpHiT4oeM7Tw74c0lp77UJ47axsrVCQo4VVA5OAOpPPBJJOTVTXPEGveLdQS51a9mupsCOFXYsQOyj/OSa+lv2W9I+FPwH0a/8Z/Gu1bzZNMaS3ntbrbJDI4Hkldp3Mo5ygwSSM5AxX6DlOVUs1x/s1LkpR1lJ20S+5Ju2mp8xjc1jgaNOFa3NN2S13fybaXpuz97/wDggF/wRRvv2Hv2a5/i/wDtC6LceJfEfiKCLWbfwOscJVJYv3sCqs7rF5pKxFS7IA6qWZVUVb+MXwM/bX/bv+Otv4x/bb+H974E8CeHrwt4N+GqTrLaW2PlE00sZMd1cleC4+VASqBQTu/DL4if8F+P+CrniS7XQ/AX7bHxC0PQbN1i0iztdXxceUnCCScL5kjYAzljn37/AKBf8Ehv+Dn34023xv8ADf7G/wDwUt8U2fjjwv4mvodHX4hXthHbX+i30h2x/aTCix3Ft5rJEZCBKnMxkYDZXjZphHW9pHDzXKnZNXs+1r6npU8WvaQ9pF67Lsl+HX7z9X/Bfgfw/wCBNCg0Dw3psdtbwRhFREA46dv8/wAq3LeyurhSba1klIzkIhOP0ra/aX8X/DP9h74P6h8cfHHw38XePiuqx2eheGPBugyaheXU8xIt4vKTjkjaXY7ckAAsyqfgf4nf8FWP+Dja+0m9+I/wc/4I26T4C8D2cfm21h4q0681nWGiBBy0FrdW0kfyZJH2clTxzgmvl8Nw5iqiUqkrX267fcehPMqKm4Q1t+p9umN1O2dNrA8jGDxWPdWtrb60893qTTPfWYhtdMuGURMY9zsQMEkncM5zgAcV8m/8Ev8A/g4h0f8Ab5+Ltt+zD+2d8CNH8Ka3rOpDTfC/i/w1cSrZXWoEsotGhnZ5YG3hY1kEkivI4QqvU/ZPi+x+D/7Efw18dfH39rH4q39h4H8N6lNdzajrtyJHuBII/KhtxEoZlJZYo4VBdpMqMgDKxGQYvDVFZ66WbXnr6eTOiVeCoP2is3ayavdX1t223/NaPgE8Pz+Mdc0/TtS+HVhawabcSvf2099FNGZZ7cmZUREbzNxuQCZNmcEgYILbp1C10Wa7mnPmypMLe3so98CBUZSsaq7mMv8AOAG+VWZkXgmvE/2cf+CnX/BUT/go5oV58S/+CXn7B3w28G/CuC+ltNE8dfHnX7uL+3GiYo7Q2mmLvXaw2sQ0qblZfMLKyrxXx/8A+C1P7Xf/AAT9+Lfh74b/APBa3/gnv4SHhHxHK8Wi/FH4SahLfWMZG3zDHDd7pNy5VmQyQyhRuVH4rvqZU6tuaVklsr23v1k3uZ4fMowklWTktLvS8tbu9kr38mrX7JI9+07Sfid4n1Gx1jxdd2X2C0itpoLOxhJjN5HM5kcO+HKPGyhFcAq45wybja1/4Z/8JRaXGs+ItIjuNX0u5t7jSLpiN1w9qrS28jIvyowllmUBc5Vs5BOF5b9pX/gq94Y+AHwwvfjh8B/+CX3xN+K3w5tdDOuW/wATNIl086Be6csIna9WYT3E6RKoJYzQRuhRtygrXiv7K/8Awcp6/wDtNfsiftI/tY237Dei6VpnwG0nw/ead4aPjBpn1RtQu7iBxJcfY1WLy0h3jbEcnI75HFPIa1SnZVOV9LLZP7uh6P8ArDGnW56ULLttZdk1rqnrrru9dT3jxPaeLvCs09xoyz2EcFg1zdnSVBjkMki3F1IqP8stzNKFhiL4KCSRxnJVu68N6pL4x0KfWIYbm2tbktHYzhlPmxD7s8eR0bOQSCCACMqQT+Y7/wDB5lot/Ymy13/glFpF1byIFeJviWpRl9NraQQRX1d+1L/wcvfsPfs6WqeJtE+CVh400K8+G+m+INF1PRddtVkvdUvnlEekeS0JaMxpC7TzMcwkbTEWwDnT4ZqKz9pdrv8A1sZPNVjHdU0pLW97ber1/qyPo3wX4a0jwr4fht9H0qS1S4Z55vNt1ilnlZjvnkVFA3uwZyQBknOBmtfQYL3xRfmw0OwuZpy/lqvkkFmHXAODgevT0OMmvkP/AIJJf8HE7/8ABWf9rq0/Zg8L/wDBNC38MaUNEvdU8R+Lj46j1BNJtoY8IzQ/2bDv8y4eCEDzFIM27naRX1J8QP2i9W8L/sY/tMfHH9lzVdNvfEnw68O+I28K3rQ/aooriwt7l4/ly3mgPETjkPtGQaVXJKjxUE5aSbv9zf49OxzzzKVdzqSTct/vPRZvgX8SILQ3n9ixsduWhW4Qv78A4Jx6H/6/JzpLa3T281v5ciNiRXUgqRxg+h6/r061/ND8Ov8Ags7/AMFOf2fvjJH8abD9t/xh4q8XXNw819p3ibxLPqOmEZAeGTTzJ9nETKxCxqqmM4ZDGUGP6Ofgf+1p4D/br/Yx+Hn7engLShpq+KbdLPxXpKybzpuoKxhliY9wk6MiuQDIkkTY5FdOZ5AsHQ9pSle2rT1MqOMm6vs6iOi2FDgkckngY/z+n4Dr5j+0v+054Q/Zy8Ktq2rx/adQnVja2Sg8AA/vJT/CgIxnjOcDHJr03e0sfyfKewB6H/P1/Gvj/wDaI+A+r/GjxBeWWo+IYLlbq+YG2uoiqXIG390GHKhQUyAeeFHyjLfJ1KtCjFTqO0brtq3stbf5n6d4f8P5XnecJ5nO1CFnJa+95XWy7v8AFbr5x139vj9oD4xrfWWh/FjVNGstTt5beWWw8uJl3Ahlg4BiOBhZOG44I5YfZf8AwTy8e+K/iX8B28SeNvENhqOoWepy6cZbS38p/Kg4jkmGAGldXBLjgx+WGLMGLfAvxY/Z91b4V+Obf4c+DxdTahcXZjKW8Rl+zylVMcaMv3mfIwV5AKn5ThV/Q79i74P337PPwVsdF8W6PdW2s6xcJJqUMEBmWCQgRRRfugwVVjjUl2wAXJJHbpr2lheVLe3TX/P1P1vxhyXgrBZHhsVl9ONOtJ2pqCtzR+05JbxStZvZ2S0kz2UKWJLjI7k9x6c/T/HsKRsRkqyk89SvRv6dB9T69KoeINZu9MsCumafHdX8yN9ksjOYxMVG4rvVSF+UHkjGcDI3bjDe+KZNNg1LUNY0O7gsbHaYri1Q3TXChdzFY4N0gwRtxjJxxxk15kaE5U1KOt9LXV+nTfqraa672Z/OUbyny27P1u7aPq7rVLVdehqMWO2MEkk9dnB9z6f19+gi8T/B3w98cf2RPjh+zd4l0yC+0fxX4J1ForOeMOI7p7V0EyA9GWVIZFI+7JGGBz0fJDBdW3kSwhopUKyo4ILKVxt7EcHpjP0HNd5+zzifxFrfh2OGAwSeHJfPBn+ZMsqou3HKlS/OeNoAGDmvRyN1IZpBJ73T9LHFj7Sw7Tt9/W/+R/FzqNnZ6dMlm2sW01yyBmt7dmYx5GcFsbcjjgE/oa/pM/4IZ/tr+I/2q/8Agi3eH4iSXmqeKf2etV/swXSx+dcXejxRJLbsQT85W1eaADqfsaMcmv5+vGfgTwx+zJc3914G+JM13q4082UeuQWcsMMkssBFzFbCRQ7RMshjLyKpZWYFVDDd9r/8G+3/AAWT+GX/AAT/ANQ8cfA39trwrcy/CT4qWVtZal4g0q0Z7jRpljmTfLDFiSW3liuH3mMNIhRCikEiv0avRjVoyhPqv69DgnhamX4mLkmpR1cV0SfV7p2v0P2q8JaL4S8Ua7ZfE34bwzSLfM0V7aqhjidXj+eZS+0rn5N4jyHkRdys6B07jSPCkNlay6Dp1kbKK1mDw2/koAFJYgrnJypAOR0xxzyHfs66z+w9+1HpFvrH7GP7XXgvxv5dmfLsbLXoZryNcLgXEMbCWMhVA/exB1HHAJB9e1rw9qPgnwrs1rw3GNRg2mx1h1FxDbuVYYycEjBZcvt+9xjg1+ZYjLMThqsnWpWgtU91f/t2++2qXotz6J5lg8ROPsn2snvHsr6XS8l8uh5JdWDR3jPPKqHyCYt68xHJ5PYHqMZz6ckmvRNY/wCGj/Bv7G+q+KP2WPDfh6Xx1aQSapoeleL7SWS11qIHzBbMYJY3ikkh/dpIThJApZWTOcXXfBOr+LdMsjo/hdpP7SvhE8sCSbYVIV5I2bGQGZHUMR0kRjjOB8y/8HBfxd/Zw+H/AOwOP2evi9+034l8NfF7U4Vi+F+kfC/V7iPWdRvXzFDBNBDIu6ylGYpGmwh5Me6VVU+5wtg3Cs5OFt0n0tdaejfbsceeV4fUoxuuZv5pK/5v8j4/8U/8Hhb+JP2W/GHiD4T/ALGP/CKfFSBLe3g8SLdw6no0W+REluZBiGbeqnEcbCSMyMm52UEH4X8Nf8HT3/BZ7wP4gvdWv/2lrHXWurkSDSta8GaS1rbJnPljyLaKTP8ACcOAOeM9Oi/4J73nxq+K/wABPhr+zr8APid8Efh7o0Gs6jqvif4lfEKGC31ixuWWPzdBbziEura6tIfPjs5FMN7HdTqwc2k7R/OXwT+Bf7NP/BQ/9onXvgF8FbWP4ceL/GEhv/hBbXt0RpVxqcsInm8M3DyEtGpmMsFleZyTHHHMr+crw/bynSh7tOKX4/1/T7HxyhVnLmqSb/Da1vy+7Ta9/wCqj4fa54R/bL+DHw98V6J+0l8M/EvjSbw3b3Wu6n4JuUkstRdoUaYQQrcSyxxCQ8bnZkDEcFiK8S8aeItf8Hy3MfgTw5H4k1G219rHWbGLW4kFmy7ll5cnG3b9xQpABI2qDu/FH/gil+3l8ef+CNP7SutfAzUv2UNE1jxZ8R9T0/w/remeMdV/si70K5ivJYQz36xzG2tw02Z4nhbHko2QVwf6Lvjr8ANe8X+KfBP/AAjXw2tNP1DUZ5J/Guq+HgkdjHLtjOZiQklx85coxXcdgLAcAfHcT8NL2scZGleas3F81p3slflaaaXZp9z2cjzyPtoK0Zwi3v0Wt7NNfnrstTy7RvDfiLxHqiaB4f0mTULpY1by4Yd7Ip4BYjgZAOCdo7fKuSe6079k74uavaN/aDWNmGAKx3V5lvofLUgjHb5ckYG0V8B/8FVf+C3nxV+BHx5tv+CSv/BGX4fN4s+NF3frp3iTxallHfvp98ULNa28cmYpbmNcvNNMPItwHBUsHMVX4pfsN/tOeFf2f7DwP+1n/wAFj/h54f8AiDOF1TxhqnxG+KsqXpvGjJe1RmlVLO0i3BBFChQmPzOshUPIfDvA46ooY6ty6XbWy+5cz83ojTNeKq2DpynQhe2y6t9Fq7K/zPvnxX+zv8XPDFoLyfRvtsEZ/ePpj+awX0CjBwBwSAOMgbR8rcRcAkI8vyGJiJEC4GdpBVjjjngnHHTgfIfyL8E/H3/guT/wTH+K6fGZf2mY/iD8GJbn7NoWqaf4xTxd4O10YP7tZ0ZjaSEjcVBt5jxjKgmv1q/ZK/bN+B//AAVg/Zovf2lPgdpz6V4v8MXH2Tx14SS43tBcKuS8bgDzo2AdopgBv2SIQJEO3m4g8Oa2X5d/aGAk50rySva7UXq0t15LW+29gyjjCjjMWsJiUo1bJtLpdbP+vyZh/FDUPih4W046p8OfCsGqymzuA2miJFaWUIPIHmTXMSIuQUbIOd6ElQmxvkn4CftHfF/9nH40+LfBXx28I+J9Str7Q7bxHf6D4Z0SO9h8PPNLMrqXhupBDEsZjLEbhhk3eWEBk+4rSKK4t0u0KKWG5JlYBkBXg5GRnuDk9yO7jj/jH4d8Ry+Ada8QfCi1htPFAsCbHUvsKTTcIB8ivxI/l7giMVQtjJC5evzem4pJSjf8H5a/18z9TyjNlQw1bAShBxr8sXKS2tJNPms2kt242l8rp8B8Qfjt4T+O37OH/CSfs7fH7SdMuvENy+n6DrcMaXsD3rLMDbTCMSeRkK48wEEMisRIP3L5H/BO74uXPij4JzfDTxZdXq694IvJLGd9V1O3ubi8t2ZnimDxSSKYjkorBmUiNDlwVFfOWr/sy/EP4OfslT/tdfEnw7BF8XLLxDBr9t4qfUJLDVbQySRwH7TJE6Jdq8IigFrKv3C+QSxUfGOs/tgfFH4S+L3+JHg+S70/WBBeQ6nqHh65giuv7PuH86SO3ttiiMJIHJlVw2J1IH7pRXVDDU68nTpP77Lbpe6v5bX8j9IyrgXF43hLHSjVhKjTrxhzRvP95G65lyrm5Ep2bd1ZuSjdK/7wyK5TzzCx2kfMB8zncMjGDjle/XPOSQBQ8Ta3ovhfTZfEGu6raWtjbxl7y9u5FSGAA5Z3dshF4BOTyeeSAB8F/wDBOH4/+LPG3wX8b6P8CfiAviXxhO32zTtF8eaoq3llcZ4hlt5p1uCZIyp89kiicx4BIy57P4l/t9fH22Gm/DT4Z+CvCuteLNM8CxX3xQi1O+hgg8Eag8lvGPtL/azBcA75QLOKUzExgB0RgTzzweIjOVPZre+lvvt/w5+e4rh+nTxfLhK8a0L2TV1J6J35fesrvli7u8k7X0OR/wCCrnjf4NfAT4da38Z/BOvjRfEOs6bKLTU/DviOCOe9u3ubJBdtbLJ/pwiVkzG29SC6lR5hdfgr4k/DD/goZ8dPhj4Xh8VeD9f8O/DzRRfHw5qlx4cubW81TT2uVJnksBJOLRN84G3McTo+1A4Xaf0E/YV/ZL8DftgfBt/2yf2wo7n4jeKPFesa5Fot54hge3i0TRxdTWsIsrEOYbR3SJZyyDzF8xf3mV3P9tP4Z0Gx0Z/DdraTQ2k1n5MjWt7NHKU2lMiQNvQhT94MCueCvRuz6/HK4OhCPNNPVtXtbpH06N/cmdeD4gp4SVGMoylCF1KKnKPPFpqzknpGzaajFNpyTdpWXzV/wRr+EfhX4K/sJ+Gfh9pHjnw14h1PTNT1J9c1Hw07FFupbyQiKZggZpETYmZFyQi7AQFYfR2reGPDGt6wLvXrSS7KwSW3kv5gjRC6rI21VYbjtABGcYIUjc7HC+GXwR+EPwJsptE+EXgmx0SC8kuZrp4LXczNKU3DLlmKjYuV+ULtUYUALXY2ltfzRthbjMfDIj7gQeqrhuQAwB6EDBOMBa8zE4hV8TKpFNtu707u/R/efOYiVCOIlLDtqD2vo1pquul9tdVa54nZ/wDBMj9njWdKsbXxVZ3V7JB4quPEepTwxy7dX1FjAqyzi5MqSKYrdFZAArEsyBNzBvoHWLO107SrhbfTUflmjeMAeVx1G3acjJPAz9eTVe6i8UzQL+6lilIXKfPiQ47sylhycZwMckjohZq/9oTWaTTIXFzF/qJMuW6HkEFgOvG3A438AKemtiJOk48juuv57p+Xn+BnisyzLMvZQxVdzjDm5U3dR5nzO1u717GJJfSAm0GpP9mSQ7Io1IQg5OQAQc4UtgjjqOheioI43maYTTq0U4I/eyfeY8YG7IIJBHIJJYbsnagK+dnUataKa8/6ZvCCfWx6UXYICw4A9KBJxuHI5+6P89qnhXbEWugFC55YY/8A1VD/AKAW+WdgM4PP/wBav0CUHFJ81r99z5BSTbVhI5ycgvgg5AAqTz3cgtzjGVFMnjVW5TgDg4/SmJGzOqpGwXucVPPVpvl3K5YyVyZbzAAY4HTmpTcgDIG76VnvIAh2uTgAEhevPSlSVuFaMg84wvB4B7VMMfKL5WxvDpq5oNPECWPBBPX0pVlBPfNU1cljzg59+Pxp6OQeWHXuPyrrjiXJ6mLppIsO7BNpJ6cYGaQuDHliw46elM85idwHBGMYqG0tJbe7uryTUpJVnI8uJ1XEWARgYAJ/GtedSd0zJ80XFct79e39eRPHeadfA3enrEqs3z+S2QW75Oev+NUtM8VeGtWu5rTQfEllcXVrKyXEVndI7wyKcMrBSSpB6g9CfWs3SfHfw+1i1uY9D8UWUogvmsrj7DcKzRTZICHYTtPUjNcD41+H/wAB/h58RNL8QanZ/Dvw0mpXV1NLc31pBZ6hc3jqPMkt7glWWQgruKsG5yc5qZRxVCilUj71lfda/PU1h7CDlSqKbqrlSjFJtX6yUmmlbXq7Xdj2f4beC/GHj2yvNU1z7D4dttOcy6jeXtys0S24BJYsGUKdoY5JwoUk+lXvH/he6+Hmm2OsHUYNU0fUShs9UtmJtyjYIJkUELkHKdn6AkmuD/aO0fQPF/8AwS2+P+gX9hrt5Yt8LdTuNQ0/QtWjF9c2y2EskkMFxKkq+Y6I8YdlkHP3SOD+In/BOf8A4LUftWf8Ey/hNqfwv+FGoDxX4D06eWe20f4ixtcwadOSd9vZNbyRvCgbmQ7jF5hfYgOWk+oyjAYbMMBHEcjpylfS+yu1bqrPe34mmU4DNcViJUqP7yNNauTUW9L6tRS6Ppay81f9r/Avw80PT/GGneIPhZpF3Ppmu29zOLSCwdra180JLJJH8uYPNZVLw8K7guAr7y/p+lfCPx1qk1xpP/CJ6hBbzRPJFdKwgCtuVthbKtuJycgYIzk5r8QPiR/weK/8FFdf1OTS/hv8FPhJ4a09YlUX9/ouo3V3NKQvESG8C87hgGNuOfavmj44/wDByX/wWZ+LeqnT9P8A2srjRYRcyIth4M0Wxs9gcAIhmih3uwCsciQgEnpgY7o5FQUOWbv/AJ36av7tV+nLiq+KnzqaT6b3e/TTXr6q/a6/p0svgP48vywns4LQMThprkcZxn7m418hf8Fq/wDgoH8BP2Kv2DfHHwH8LfGuw1T4meN1OiDRvDN/HLf2EMykXTSKrE24+zJMil9p3yggYDEfzkfEn/goT/wUN/aMRtF+Nn7dPxN8RaQ2/wC2R3Hja+ezESlAxW18xY5CclVwgye+ASPL/FHxBk1WytfD/hJ41tQrQWNii/vLfcFL7n2gSFizbnJ+ZlzgBVr1cFl+DwtT2yWq2Xf/AIC/yXoqTvH2+KaSVuWKXxO9+/wrrvd2S6tehfD79vX45/sz/tC+G/2lvgB4xutH8VeG3jk0fUI7jdGLbbsezlgB2SQyKGEiyAtICD8vBP8ATf8Asp/tefDv/gsD+xL/AMND/C7wzp2i+PdO8mz+K/gOW5AktrqNAxRmAZmhYKGjdlYvEJISBIjBP5IbGeKxEd8kYku4W/0XzF8yOWTdzwePlyCAeDnJ4wD+q3/BqH8S/i58G/26/F/xLuFEPwz0b4dardfGnxXf3pWx0nS4IzcW1y5I2+YLmEqowXZZbkjiOSunEL62nKo7vf8ArzOKnmFehili1L94mn5aWevXdeVrXT2P1u/4KWft1+Hv+CKn7BWs/HHVfFLa78ZPiNu0/wABaZqLYiF4Y/8AXJa5Kw2lrGyyuo5dvKjdy8m+v5OPGXjLxX8Q/FmpeO/HPiG71bWdZv5r7VdTv5zLNdXM0jSSyux5ZmdmYnuWJr6c/wCCyv8AwU68c/8ABVT9tTXPj1qkl1Z+EdNLaV8OvD07YGnaTG52MyjgTzHM0p5+Z9gJWNAPlrR9Mn1jUodOt2AeWQKpPqfYdfpWFKnZKETixuMqYqtLEV3q99LJJKySS0SS0SWiWiOq+H+i6t4diPj2fTpYFtZ1WznvLRnhkLIxwuMfvPukHOPxwKj8Q6T481jw+L/VLO4h0jR1xZQywMqKHfBAPPzk4JDHPPtXdpr2h3Pw/j8JWF7cmTS/JaB5rlWjSYkAMqtwIzuLHByrE5yAKpwaOPE876FqGr3MGkpuu9WYXK/6VIq7iygopAJOFBzty3U4z9U8DTjSjRpzbuumicnvfyTS+5dT4ZZjVdeVerBJp9VdqK2t5tN29Wtji9OTTfDfhVvEWrW4k1C7iKaFGBjygGZXuDjHIIZVPPzLn+Gvrn/gn7+zx4a+H/wRP7XPxF8BT67rPii4vtL+HH9oRyQWOntbKBc6j5rgJPNG7IiKCyphi3zMgHzf8Jvgld/HX4iPouiBLfR7aUSX1zt2mJSSRBGCT8zHgdlLZP8AtfX8HhD9pL49a/4O/Ye/ZS0TU/E3iMQvpvhPw7bySSW2j2Ylkmlfc52W8CSyvNNM2ELSck5zXsZDlVKFP+1caksPS0Xecu62vrb8ujOHNs/nRxiy3AtyxVWzf/TuOlr72drvZ6+9bVH7efsZft3/ALUOsf8ABErRfjh4Om0e98c+H9fXwtZ6h4kspbmG8gS9S1SQrHJGTIkcipuJILQHcDurpf2HPCn/AAVC8T/HvSviN8cP2sb/AFnRDMZfEHh9tIs4rBrYo2I0SKFfLbdt2suG45JG6tn9g/8A4JVxfsFf8EtbT9j74ifHS0kuLjXh4n+JPi2/k/0S2lNxBc3CWpmKiKNRbRxiSTAz5kxXLbK89+N37W/xK/bgsr79j3/gmV8VfD3wz8AgPYeM/wBoPxXqEcUkycJNDods8sc13JjcpuvkjDKVR0+WSvhcdRxWY5pUxNJclHmbdtldtqK/yW/RH2eFrUcvwFOhVlz1eVJX3dkk2/1b26s/Pe/+CL/t4/8ABy/qngn9j/yrfwL4L+L+n+LPG+taQn+jQDTJbee9RWT5QZr6OX5hwXmQ89D65/weHfGbW9e8a/C39ljUfGaeHvCtj4bvfFmoXFyzGC91KWZrO0RkU7maOKK9CkAhftJJ7Efo9+xP8Av+CcH/AASM/Zh1XQPhL8SvDNvpul6dPrPj/wAa6pr9tPqesSQxNJJdXLIeQF8wrEgCJkhVyzE/hn/wcT+I/ip/wUQ/Zh/Zy/4LBRfD86R4Z8YaZ4i8NXNlAztHpUdprl9/ZnnEkjzri2EjMR8peJwMDaK1xOJVaqpW0SSXy/r5vU9bC1UpxdWPPZPS78362Xlb1P0R/b8+Hmq/DD9mP9kz9h3wH4o1rw74N0z4fpc+In8OaqLP7dcwWtkkDSFZY2ly73kxQB9ztuK5UEWP+Cn/AMG9I+Kv/Bu58SvDfiLxVqXiqX4Y6laan4R8Qa8JpbmHyLu2JAmnGZtsF1dW4cFgEbYCdtev/BLVbj9vz9j39mL9sr4O6rdX9qPh8ujeMLTRoYp5obvybeK4jcOrYWK6tLmJsLuPmIwwuTXIf8F6fiN4U/ZV/wCCFvxC8Ia1MdM1H4gajYaB4e06/mcTTSyXUDSJiU7/AJbS0nfnso6Zrwfa1lmqp8r5bb6W/wAzrk8H/ZSXL+8vvfp5q35Neh8gf8ENfjp4q8f/APBuh+2R8EPEl/LdWXgHwZ4qfQvNckW1rfaDcTNAnooninlx/enavNP+Dcf9lbxZ+2Z/wTZ/bX/Zr8A32n2mt+OLPwvpmnXWqyOlvDIp1CQPIUVmAHJ4BNfQH/BHn9kXxp8Bv+Dab9pT4q+ONMbTr/4w+APFWq6PFdjyj/ZSaLLa2sr7vuq7i4lDHgxSRsODmuW/4Ncvh1rtl/wT0/bAsraO5fVNZ8OxRW1pYxyGcMdK1IRKgUBvMYvkBcnJUcHivUekW+x59LD1qtOU4r3Y7vtdpL8X/Vj7u+PP7Zfxn/ZQ+JXhj9hH9gT4S+DfFGifDvwJp2na1ca7HcS/2bJFGIYLTNvKgVlt44nYEE/vV6c12HhP9vL43/Bn9kP4p/tp/wDBQv4d+BfDXhXwLpfn6JaeG7e4WfVJwCPKJuJnGZZ3t7eIADdI7ZOAK8s/Yd/Zd0v4TeFNGsfhbpa/2tqk8Bu3kH7/AA7qJJHY42FMs7ZycITycCvn/wD4LY+LtV/4KHf8FE/gX/wQE+B3iG9Ph6w1W38TfHHUrKYl4rdImn8mVwRtZLQzT4PytLe2oGGUCvMweJqYqrKX2V08/wDhjtxGGhhqMeb4n+C9P66kv7BU/wASP2Tv+CZ/j7/gpT8QpV/4X9+2Z4uFz4dl8oq9haXXm/Y/JU58uOO3+03iAfJta2jOQqk/W37FP7PumfCf9if4ifC/xFa29r4e1T4d3Y1i8kYAAva3CzM4wABsZmLEktzkKAN3lf7Qs/hT9qb9vq0+FnhbQrZ/hz+z/pyaBpWkwW6m1j1Tai3BRM4AiRYrYAjK+RJjhub/APwWa+Nb/sU/8EOfi94o8O65dJrPxAI8MaNNcT5kxqUwt540YYKhbX7a646Ede9L26r5koRfw/1+Gm/c55c1Ol8Pxb9LdtOt9fSx/K2vn3922gaJbW082oyFJEVcPuBz5jP0VTknCnaAuSMdf3v/AODVfx6NZ/YJ/ac/ZPuvEC3UPgu7s/FWnTndhJruzmzgEnCLLpURGCMht2AWr8F4bCTR7BbDTLxJdSmKSaozqGW2VWDKpcZ2qMKXz1JC4yhr9vf+DWTSE+Gf/BP39sn476pbIzTabb6UlxIDm4uoNPv5fLJ6glr6Bdv8JPrk17eIUHh5Ka1/Ly/V/d65zhKlUS6/1+P6n6WWfjq21nRNItb6V4LXXNOxb6jCjARz5UBHfAVS+5Qik7nbIA7V4z4d+FX7QFhp11oXxN0q3ml0OciPxdYapBu1OFizfaPIdgLaQfxM4K7icLtZhXrPwUVIPg/4XtLy9tlk8pGa1uLfe022MsDGdwKurBTkK3APTrWr8UbLxNqukkeGJLW+tHt5bfWNHktkka4Rmj52t99AgkR4xgsk5Kncqh/yjG4LD4ykozgpWd9dbNNpNbfNa/kffZHnWIyrExng2k2rTTu4vqrpWaaT79b7NnlHhD4R6H4S+IE/xHvPDsviLUdJtbtNBs7VlkhtbuNGkdJSWL/bJQQd7IygEfMzNlvUvCvxNt/G+gWfiHSPDl/E9xaJNPZ3KhXjjkVyG3AlZTmMDCEt8yk+lXfC/wAB/Fmo6VLaWdnrNzb3Jtnhnto5N8scRXyzK4UMz+WqxFyzlgqk9Mnv7b9lzxt4n1S2v5bCPTre2tXht4bl1VIySo3qi5KNs3p93kORkd9o0MZiZOmqTv0l0ta/Tu2vuOvOs+pZxL2+OqKU0klulFRTaio7Wbe61um3e7v5h8Kr/wAU+KPhnoOuePk0ybVLjTluNTXT0IiHmjzEiVWZ9yqrIMk8ld2W6C74z1eX+z55tO8KXWvXNmY0fSdOkiWfMrIC26aSOMBVJZgWJ2ggbmwtXPGvwj/ZJ/Z+1W98S/GT9r7wx4Ku5Zhdz2za/bWkpeO0+zJlZJA0yxoSQhQglY9wZUCV5H8UP+Cz3/BJn4WaXP41+GP/AAnHxpvbG7n0wx+AfDdxdRxXISKR4Xkm+zwdAjE5bAzjuK9h8O5m+WrOLUL6czaTd7u/Lvddmn9x8tWxeU4zEulh5c8mr8kVdxa1WjtdJ7P52Wx6f4K8X+IfFUEaR+Db6W4mVvIgsrK48xnQlXBSWJDEMj5S+N45XdnNev8Aw+06D9mzwl4u+Onxs8SLonhjT9HnvNQfWbpFSygjAkkfJ+6p2sdrMTkgADgV+Venf8HNP7RH7Q3jDSvgX/wTv/Yq8M+Fk1dDHaX2q3J1KeEhnZgLe3WCGOZY0LbC0qgyLkk5Wvyo/wCCpn/BSD9qn9r349T6P+0B+0F4i1zStNWFLfw1aa0bXSbWdlyZVtYlEKsA20tt3kEc8V6uW5HSwL9pzuVm7N2vZvROyt7q6pJu7u2erj8kzKWUvM6qjSouUIct9XJqT5ox1aTitbyaTVo63t8069qCeMtXvPEvii9hE0pkltbGNv3NrE3zqzMTgnc33cszMGDdSRi6rcXfii4udVvLtPshijM135MYcbVEagqp4dtn3Af9o8DdW5pvhTxp450g2ET7tJhuXmm127kISVEVVdkMgUsi7Wbp8u7Bxn5q+uQaes+neHrGe102xt1MzXRl8x0VuDM+PvyONpAAG3Cgbea+gfM1qeXiKFepD2k07Ss7u652/PayTet0u1ldqTwBeR/DzVLb4iG4mWTTbmJrGSxmw0dzhSJmKEldnzbRnLOvoHx+jX/BMT/g53/bU/ZB8fWHhv8AaT8bax8XfhE0sUOt23iWb7Rq2mxPtDPZXb/PJIhJ/cSkxOq7V8nO8fnT8NPhv8WP2ivGNh8Lfgb8O9U1/Vbhoo9P0fQ9OmuLiWby0TcsEAZnclD8wUnkk4HT9Ef2Wf8Ag0x/4Kh/GuSXU/jfB4e+DWg2qRzfbvGGsxXkzQuD5jRW1m8hEiqMss7QAbgNxO7aOV4cvQ8zE1oOiqVNLlV3fq31fe21v+Cz+mP4W/F34feLtE8HeKPhdrVhqPgzx5oa6r4U1S1+QTpJGtwmM4yHifcAQGG0g+383H7bH7Ef/BU74Nft8/GH/gpl+0r+ytrOveH/AIceKLvxfa+ILjVrf+y71ob1F0llbzDLLaRE2krwRpu8u28kiFQZE/TKx+Lv7PvwA+EfwZ/4JR/sjfH2T4i6j8NoiNc8c2F4m1J/LuAIkmhZk80vPNIIo2fyhBGjMWFdV/wUq/4KE+Jf+CPP/BOzWfFvx4+LFx4++KnxJil0z4b+DPFENtNHasYtsksyKgM0MKyebMZCwd2hgyN+8+fRxE6eKnQSdrJp9Etrfen/AEjlqRc6Kqt7tp921+P9dz8af+CfPg3/AIJl/ty6L4M+FX7Z+p+K9KtPhl+zzq0Xinxf4UvU0+5vtXj8QXeo2FhGZo3jumh0hrnmROlrsQkQqT9qftj/APBMz/gif/wTX/Yu+IHir9m7xbq/iH4tWmlJr/g3xt4k8Rx3d7o0+leI7C3It2hjhhgL3X7nzFjLsgkw+0/N8Afs6/8ABGf47fHf4Q6R+1L8df2iLX4aW/xF8D+MPiJHqviZJ0hbR9Hu9Hgnv7kwguPtKaxetEqoS4jjx8tzlfNvi5+zR+1MfiLo/wAKvifqmutZSaLpMPh7w3fXHlX95BqaW15Y2slsHJE8kZsppYxuKSFQxLKSPYwWGqV6q5FdrW3kt2+iS6/ceNmOMpYSg3Udk9L9bvZJbuT6W9eh+0H/AAVS/wCCGfib/grR4H+H/wDwUZ/ZT1XSdB+I3jX4f6RqfjHwXrVwbe21yOWyilVo5lB8m4VZFibdiNgFJZGBL+Z/sj/8E2P+DmH4TeENR8PeLv21NQ+FXg7QtNaSz/tr4hxa7FYWkUZZlt4h9pICqoVY2khQDJ3DgD65/bL+GN5L8e/2cP2Nvhz401rQ9e+HPwzWw/trwrrMllc20V39jskCyxyIwH/EsZiuckY4PGPiz/g6l/4KGfGfwT478H/8Eo/gP441iPw/beF7Kbx7O+pyzX/iK4m+S3srqdmMksQiVJpAzHzmuF352DOWFzKpisXPCwipclldq+6srenT5DxWX0MNho4mcnHm1spW21d/Xq+1/M/NP9gmP466F4y179pzTvi/quj6x4ktbq1uNUh1IwXd9FcSrLcS3F0GVl3yCPcCw8zf852/K3t/w7/YW+OX/BQn4yyeDdN1G18T+F7JzL4vk8O/FrRhqSSPLuYzR77icszfMx+zsM45GCG7b9mD4X/8E1fAfhnwx8D/AI1+O/iV4+8WaorT6l4X+Dmlw20OnAsWZry/1BkURqWOEgjblVAckkV9BX+r/wDBD34XQD9lH4Vr8b/hRqviBZox4lsksdYgRmXMj30fmtNJEvcJgknapBPP65DCU8PlkMDSoyVONlWlGLlz1Hb93vFtXaXu6bJXvc/F55pVxWbyxlStB1ZXdGEpqPJSV/3j92cYuybXPZ6tu1mjlvh7dfCH4D61q/wL/Ykn16O58OWD2nxm/Z5+MWmNEnjTRFDNcC0uYkiB1COJd8SSxQ3KBfNiMjBo36P/AIJG/aP2FP8Agud4Z+C/wb1+6uvg38YfALXXha6vYwDe6Td2sl5pysgwBc29xay2sxwCHjlXAya4f9pn9mX43/Cn4DaLK/xZH7QvwaivFtdH+PngW8eXxB8OrtGLxzXSvJ50EUb7W/s+ZzBkhY5LWUo9Zf8AwRe1S6+Nv/BTb9mr9njwJqb6jpfwJfxDdXHiaNWli1DSpba4vbdkkYhtjXl3dn5gGUzBWVTlR8zm1WNWjOXNpblaWmqV1FKyf7tW5r2a21XLb7bK/a/WIOS1TTT30bUeZu7Xv6qFm07X0fNf9b0lt/D/AMSvF3w7sZNy6H4hube1VsjbEWEkanPUBHReM5IB6EKJnuXMq8/JJnKsSVbJ5JPPqvB5OBkE4VeL8JeOdP8AG37Svxf1rTZkmtf+E8vLSGRQWVmtyLdiuBn70TcjGQTggfMe4+1faLUGT70YUlGOAvtuwuR056YH8K8t/KGa06dPH1oQ2Unbta/9f1qf0Dg5SlhoSktWkQa34f0zxFot54f8SaJY6pZ3cbCe21C3E0Eq7txV0bduG4DseVHDHp8uftL+MP2N/g/8QtC/ZF8b+EPC3gDS9Z0dtT0XxbPYWltbWd7JfeWttEJITH9omAncsrB1VGOd2019UT3Dx2Mk6ToXWM+WJwQqPg43YAIGDyem3+6vB+UvjB/wTtm+O37Rvgb4tfF8+HbnTYYLTVPiJp1pbyOmpavYp/o1rbrPuaDT2lkmuJUY/vPJhDqMknPCyoP+LKyt87+X5Jffoe5l2KlhXKTquPL70UrtOd1urpKyTd2pXaUeVp6cx+1R/wAE+vDP7VOmeEPh3onwYsIfDmk+IWt5PH2qQi21zTtPVLiaKCwMaRyJYxzLFbqHcny2CxI/yzh37bH/AAT90u9+CuqeBf2LvhHP4b1y2t7Fp5NLjjSy1OzXdmCXfJuuJQYUkJ+Z2mMZZmLvKn2jHJp0l28cgUsSzbXYqGxjJ5A7Kvb+IZwMKXtcS5+zSRiQo4wCTyF24zkjnlep6deyFSx1WcYx5rxjsr3V2+v9bG+VZ5mGSY+OKwjcJxaejavZp62ab2T6Weqs1pyfwQ8PXvgj4QeEvAGr6ObGXSvDdjZS2S3Zn+zSRQKmPMJPm8g4dd3QnJILjpg0jKsccpynMYRTtxng8c5PzYwc8nAyN1KkiSor5cMHbkqVC8nOcgHAznng4yecJTJL+KNR5ihC0uyQOvMjcAsS3ccgg8HvnIWuGU/ebkzzKs3Wqupb4ne2vV+bv9935laZ5r21Fxc7FeOJT5SPwgA+XLDJGCCVIPqc4y1WEkudIlW9ay2ymQCOJ/l8sHJxs5ycljkYHX+EFyRNPHexzSRRkKPMIdW6jB+7wV+Yd8kkD+LCieDVBdrJHf2pYAF1MSbATkZJVhkfMcbc454yflXKlBc3NN2d7r1/H5aee2ynLSyV0bNjNrN1hLyBViBKKCzK7djxtySOfm4zjsMM0OoaNG+nXCR2qxglRIH3YRiMcAYIO0jnI6HoCN2SniO7j2NZmOGNGUNDOgIIyASNgJDE5xy2ckfMeBbvvEsN3pi3l4qAb1E2EBdQrZwQFc5yMAe5Gdxr1VicLUotTd2urt2729PxOF0a8KicVZPt6mHKZ7ESJLaxCSOUEyB2Xam0HgLySF7gAYJ+6uSSmtLavcNPK8hE0uN0zEFPmyCpIAOW44x83AVmzRXhNRf2lFdOv+R6d5L7N39x6OyK1uy3Y4I5BOKh8q0Y5UkZPfNJ+9aEtdODgZJwV/rxTkEExwHbqeDxX3UpRqNXS+e58uk4rf7thJJJFI4wBwMCoDNNHw0m4EAYcgEHnnp/Sp7wAOGPyqCMEVGgbgMT7nGa56yn7SybRcOXlvYaI4UtxGyHBXrjp71JBtclWDYBPOD04PWkijLfIhJGMA8DFSxIgG1mPHbqccU6VNtppaf1+ATlugeKJEIJIGTgZoQANkL0HcYNSuUKgRg+3NM8vIwQM+3Wut0kpaJGKk2tQZQPlVQflwVHaqHiLxLpfhbTmvtW1GKzi2sPtt0CIIWxwZH4VBnA+YjJIA5IFaSbQ2ckcD15pt1YWOo2/wBj1e2MluSPNjYBgwB7g9foa6KMYe0Tnt1sZz1i4mX4a8OaN4dsnk0zQdNtbi8kM94+n2qxLcTHq5wPmJ9Tk1xXxg+JHwq0LWbPwP8AEzxhZaK13FLfxTjxn/ZUm2NSqswSaKaRScqQu5cgdSOO71jX9D8PxT3E09wYYZY42EdpJK+ZHCIdkasTksMkDCjk4AJqj4F8aeHfij4WHibw/a3TWcsksBj1PT5bZ2KHYwMcqg4464wRn6Vc44ybdWnKVo2V/Xa713tp6aHVTbo14V3Kfute8naTta65mpa20fWz3Oi/ZN0/w1rFhqPgbxBqrX2leL9Hn06SJfE0moQXK7Gz5Ukjsw3RNKcZyB1r+YX/AIKZ/ADUf2KtSu/2TvF140eo6N4su4dSuo2Ja9toG/cbckiNTE0RUdT8pI+8R/SjL+y9+2N4mmg1z4U/EDQfDwttfj1HStU1/RH1C4t41Jcom+WNVV8mLAj4jY/MxAJ3v2if+COv7HP7WX7W/hL9tj9oL4X2uueIfDOlL9q8LyRRSadquoRhPs9xcb1DTeUAyBGIjkAi3qRHtP2WSVKywnLUUrrq+qf5/hud8c+w+Co41uXPPE0+VO7bg1KN09k1KHNF6t99NH/O9/wT0/4N9P8Agox+3/osHxO0XwfY+Bvh5rNl59j44+IhFuJo3Kkz21tGjTzkqJNr4SMhhiUEHH2d4B/4Ivf8G/X7DNvNpX7WH7YPiP47eNHUQXugeBpHSEMCC8Qi01pHt2PQ+bdoSMgYyQfuX9o39ir/AIKh/t4+P77Sf2kvFlj4K+FcErDTfh/4I8Ql7ee3BG0XbxhJL1yAMq6iMH7qLzn1H4Ff8E5P2Q/2W/Bt3488f+E4dP0Xwtpz6lq2ua9ElrBBDChkkZxydiqpZiTjj3NdNbGVVUUKcG2/JpfefJyq1a1qkpWSv5vXc+Bv+Ctf7G//AARg/Za/4I76n+0n8Nf2EG+H/jDx9Yw6T8LtP1rU7qDW/tc74Sd8Xsw2LapJcEOzAx4RwGk21/PXJp+oaSSHuGga5i2eVZyA/aBnAVCvDDIwWyQfc8V9s/8ABd//AIKu+I/+Cof7XR17QILqH4e+E2lsPh9oMoeOSCzDjzLqRBwk9yYxI5xlIxDH/wAsiW+SvCvgjxn4w8WaP4I+GlnPrni7Xby30rTdIs7VzMlxcMkcNtACTl2Zwg6YO4c5Br0oU5ON30OaUuSPLJ3a89Ff9T3X/gmH/wAErP2mP+CpPx6HwZ+BWdFbREN1418VaxbONP8ADdm5xGTt+Z55GDiOFcM5UnKojuv7F/8ABST9hD4P/sCf8G4vjj9n3/gnZ4obxs11410q2+KnjDQZFu73XrhbyIXSym2LhESQQR/Z1JEUe5WLM0jP9Yfsof8ABIvUv2GP+CVFl+xp8PPjRovw+8Q+LFS8+NfxPkjLzzXNwqrcQWzCSEAcpaRyF12xKzBfMkyL/gf4Q/Fz/gmL8Mbj4P8A7MnifQZFtiL68svEli8thPI6BPtIVJY5ISdgBAkxlOc4yebE4mNJpte69BUaDxDai9ei7n8iUnhnXYdUXS9V06exmaRVdbyB4ymSByuM9+gBPtXV+D/A+s+L7yT4f+A9NF3cM2/UNRJVo4I15LqxxsG3g9zyO+K/rz/4bP8AjN8I/wBjbx9+1h/wUT8FfDuDw/o+nAeF9A8O2c4m165KsqQn7XNKn7+UxxxgdMu7kIu4/wAvWr3o0Pw9eaV4c0vRf+Em8T63caprN/pqFbeCK4OWtoY1yoRM4XgYzjkAEfQZHgljYyqyTVNbvq77Rj5v8EfKcRZi8vUaUGnUb0i9lbecvJdurPY/2Dv+CH/7Zn/BQHQ7bXv2bPh6B4OtJpLTU/F/i3UBaaZczrIwdImwZJdp4YQo+0jBIJFVv+Ct/wDwSw+PP/BKZPBvgn4u+OvBut3HjWyu71H8I3lw/wBjEEkaO0v2iGIjd5q+XtBXKSHAK5P7b/FP/gvH/wAE5/8Agn9+yf8AD34P/sV3ml/EfUYNCg0zw94Z0/UBptvpcUMKg3GpzSx5tyWO5wULu5cnaTuP4J/tfftg/HP/AIKg/tc6t8Zf2kfFNnfWOnIgvBYQNDaWVlG7PDptqCxMcYJYn5ixZpXLsxLN2YenjsXWVKEFBS91LZ/O+qSSvJ9Ffqzzq8suwtH2k6jqSj7ze6WvS1k227RV9XbojP8AgDpWjfBL4Lz/ABX1kPb3viGIJomnW0rb2ClgJ2jxyXONqgY+QMQQCR+yn7A3wU8Yf8EjP+CbOrftL+MtNgtP2kv2ipYLHwXp97biW60SwYbreIq2SohjeS8lBG0yvbxyDcBXxT/wSh/ZX8MfGj9rr4VePfjj4ctJtL1DxPbHwn4Pnt32y25m2G4mCkhGRVZ44mAUqm5j9wP+sHx68HXf7Q//AAVK8S634qvludG+GWk6fo/h60DZiheW2ivLh8Zx5hkn2MeDiFFP3BXbxzi55ZlWGwcFamo3iustfja6c0r2XRJavp5fANCGZZtjMfN81Tm5ZPpHTSCfXljy3fVtvTq79rf4U/A79sj9jD4WfCP9p7/goddfCzVfDPh+CHxLJqutwo2u3y20ETXNyl1Ki3DB4nlVzvwZm7k18VaR/wAEBv8AgkZf310NM/4LGaXqmuavmCwlgu9KuZoIwSREkSTkn5mLEnlm5yea/Rn4j/Ar4afFOFLTxt4Zt7xYuE82MHHSrvh/wDoH7Hv7Jnxd+M37Kfwt8NN8QvD3hW81TTjqlgWW5S3t2mW3by2R9reVJhVdQX25PHHwmWcSZjNQwkZ2Svbayb3fq++/3I/QcbkeXKc8VOF5NK+92lst9vLZ/Nn5seNP+DWn/gnjotpbap43/wCCvNnpmlfalmu31eDTLdbxyc4kke8UBjjAGBgcY4GPrjRfiH/wSx+B37HHgX/gj54v1q3+Pvw/Ph2407xVrnha3jvLTTozcNPHcym2lbZJ5sjMv2aR5ojEHABK5/MrwB/weaf8FF4/GDD4lfAP4Q+JvDJEgvdKg0i/sJ5otpwqzG6mVCeB80Tg5xx1H6a/8Evv24v+Caf/AAV60jWvEX7OHwmsfhx8XNHsBdeKfh/dwQxtJGxCm4geILHdQbyFMyojqzr5sa703XiamI5XKPvM6aKgoKGyOG/YN/4JYp+xH8WTe/8ABOH/AILjvofwd8Rao154h+GGu6VpOqXiHYRmF7ltkE/yojObVJNqAP5m0CvpL/goRaf8EWfiFqng/Wf+Civjrwh4+1zwIzjQNK1bW5NQuA8xTzJJdJ04+VLv2JuZ7fZhR0ArE+J3/BI34SfEXx1qHxa+P8Phrw/oel6esOnyXNwgWJn+e4upmbaik/JGuW+URyHP73A8+8C/s2/8EK/AHxI03w/pv7UPgbVvFmoulnpp0fW7a6hZ5HIWEmDzY1cspwrOG6eozyrEYjku4W07rftq18zqo4SeIqclFOT7JNu3fRM9C/bF0jTf2rdF1D4a/Dj/AILP/Cn4bfCjVdANhL4D0jw3os8ktibdUeGW7l1BZFiwHOyJICqNsJwuT89fsQ/8E9tW/YK8S6n4s/ZS/wCDhT4YW+ieJL1JNd0DUvAui39lqkkLMRukbV/MRlErqTC8Z+cZ6AV9H/Gr/gl/+ztBew+Ib/wTYahY3yAW2p28AwwILBcgnGRyDnBHT243Qf8AgkL+zd8T3g8O6B4TFo1pFuXUd5byMLtV2zkSnJztfO4jnPJrk/tepCqqLptNvb9fPoelGvivqn1ZVUqV7tcqV2krc1km9ut9dd27/TX7QX7Vnwc/Z4/ZW139vnW/iLoPi+18F+ELmGW78MXEX2HWtVDpCkULrJL5TNdAwBTI/l+cwdjsJr8nf+CBc+ueAPgR+0x/wXw/aCQat428baleaN4P1C8jZTqV1LcJJMYlJO2CW/ltLZAv+rSxcYxnHoH/AAcP/s3ft5fGv4ffDr/gnR+wB+yR411n4XeD9Fi1LWtY0G1ihstX1Fg8VvbF2eNWWJDJPIeVaS5GQTGRXsvxc/Ztm+CPwl/Zk/4JKfDvT5b638F+HoPEXjp7CNpPtl4m9POYKCSJ7yTUJyD/ABKh5I49CrKGGoSmkk3q7d9jz+WDpxindv8ABJ6enX/gddP/AIJ6fAmx+EnwmfxTexed4g8WXDan4j1Sbma/upMs8rv/ABMWLEn1J9a+Rf8Ag8u+O58E/Br9n39kXS9QjFxPeXvijWLFj0aCBLO2cjsCbq+w2QQU49R+tPg74QWvw68PQ+MvihrWmeGfDehxJPfXOsXkdvHHEgBJkdiEjTjBLEY/Wv5g/wDg4q/4KCeDf28v+Cl3i7x18IPGMOu+CtB0i18KeG9SigV4prW0d5JZoGJO5JLuW5dXGNyFDyMGvNyXD4j2tTEV003tfe39WNcdifaOK5uZrd77Ky+78EfDovrLRYJLbTLwtM9uI5nRm8uQk7iSD12nAHbIDfw5P6n/APBub/wVv/ZH/Za+GHxB/wCCef7esUujfD34oax/atp45txI66dfNBDA0V0IwzJGwt4WSUKwR1PmKUcsn5Qz+RAhiMLlyowJDwgIJ6fiDU3h7w9qfiO/+x6bZyzFVLyiJCxVByzYAJwACeh6V78oyqtQSv5HlSqqMed6JH9jX7OOhfsbfEjTv7C/ZP8A28/B3jaO4VZLCw0vxzBqtzGnyllb/SZmXODkCNNoYgAEDHrHh/4I+NPhF4G8YeMfhF8JdA1L4kLaCHw+/iXVmhtNUZIkEby3MaSyqMllLMgkbYASFIcfxkfCbwX4j+JWvf8ACPeC4rjTrPS7dLnXNRsizGFUZUM2QTtO58A5wS3GMgV+6f8Awb1f8FOfiD8YvixrH/BLn9pH4la94t8G+I/DlzbfD/xDrOsvLqlndW8TtLbC7DGQK0KPJExcmJ4EEZ+biaHDNPC0pY2ivdb6t2bW/Km3ouuyv5nLLimTxTwFSb5prV31SbTSk/7z2XvbLY6r9r/9s7/g65+Gvime1/4Ze0jS9LiTzBffCDwQviKKSMYyUMjXcgPX5XiRvbvX5o/H79pr/gs9+1l8XofCX7Yfj/486X4XmvHF1o82l6ho1lKACfKe3t4oYTxnJKZIyB2Nfub4e8Ef8FBPhZPe+A/hH+2t4gvTouqTWL2niuwtNSDeW5VCZbuOSYBhggBhgH0rS8QfHv8A4LK/DNLiC5X4Wa7cQgGO31Tw3cLJIvyj/l2vIwGJIwO5YDuMRhuIsupVoqrTT5ZLmT0v/db1sn/wR18hxtaM1TryTlFqLvflv1SurtX36dz+ez41XGrG+sfgX8IPDRl1rU1WzisUibFuoByCSfljj447leehr0vx7onw8/YT+FGm/CH4E+If7d8Z+MLPb4i1myldY5t4+aFkkQSKFO5pGYkbSoXqRX7Sp/wUJ/4KX3UIuvE37Kfwr1iIxLLDNax3yq6HkkF5ZOo/LvXF+J/28hJfweLvjN/wRf8Ahx4h1CCb9x4gjvrNXhkLn+K70wlCGjJbEhYFR8uSK+7l4jYCpiJ4irStNpKNpK0IdUk47vXW6V7aaO/xdPwwzjA06dClX9xXcrxalObvZuXPZJbctnLfVN6fGX/BFP8Aaj0T/gn78TY9K+M2vWgsdfsbkeIdD8GeArrVte1O4mO62uJktmL2McTIwVEUyOJ+YcSxSjx+9/4Icft5fFWPxF8eNT/ZluWsE0u7vzdeM7GLTTY6dCrSIv2e9dWNw6oHJUtgsQSDkn9S/Af7af8AwUp+Isk3g39in/gnn8OPhpaXEmZy4N95bnOXL24tIFbPeRWAzg5NV/8Agrn+1b+0t+x3/wAErNQ+Dvxs+OmleIPjR8UJJ9O1TUNLht7WPw9ok+8XM8UUSRlo0gQW6u/LXF1neVXj46GMpY/H/wCz01FPRJbL59X3b82fteQ5vjMsh9XnF16lTl5p1ZOTco3XNZWUUoyaitopXWup/NL8bfHt3BqT+HrzSIQ6xiBrOG4ZoUSNyscPl8YA2+Z77lOOBj7n/wCDYf8AYC+BX7d37ZXjeH9q7winiHwJ4C+H8mqX2kz3ckEVzqE88UUJna3dWKpEbo7N3BUA8blPyNa+GvFvxd1RNJ8G2r2XhjQYTPJJqEgeaRJOWuGOCPOcFiu4fLuycGQV9uf8G7X/AAUu/Y7/AOCdHxK+MngX9onRvEa+H/HWiadpVt4m8O2C3CxG3N35omAkV1LLcAho1c5jOcDGOzE4DFQXtFe0tvPvbv6nFnmNqVcS8Q6rals9tOqXdXur6emp+g3wq/4KeePz4Lj+EP8AwRx/4J7eGvhf4GtI5lF/4h8PCO5uZVUYaO3t3jgE2Wz5k8028nLYwxrh/AHwM/am/bsfWdE/bI/aw8T+J7FEtNTttEk1z/iVXMk0Kz+atpCyx+XG0kYUiNQBhlI3Nj6v/YP/AGl/+CRn7Z1s/wAC/wDgnv8AtLNP4j0K0+1p4Y1a2vLG5nhj4LKt1DGbhVJAZojIF4ZgeDXa674ch8E/FGS91qPVm1nVriz0GLT4rffHHL5khi+5ExjDNK2ZSxUjaTnAx+aZ5XzlTlQUXFVFywcXqpXWt9NeVPRx0vfpc6cop5bVpuy5prv69tV+P5nH/s0fs8/s1/8ABOf4deLf2sPi5JY6F8OvAPhG1nuNXuIhuuLqFpxLhAcyMS1usaAZklkRVyRg/gr/AMFFfiJ+23/wVG/ap0b9u74xfCS8Xwx40vJ0+Dfw61KSUzXfhuwZpWEUETLILXG5p70tFG7vcNHJiF/K/TL/AIOV/wBrv4UJ+1N+zh/wSz8eeIJLP4VWninSPFXx5OnrIzPpf2xY1jlWIFgiQrd3DjkkywOAWQVw/wC0F4V1/wDaT+Cf7T/7d/w51NL2H4lfFnRfgn8J7gW5so9C+H8bW3mCzgYK9vBeo0cRXarNG0jAKszE/YZFlNehQp053nN25pPrKy7dF2XT1Pms5zZYupOrKSikultEtNu7tv3Pie4/4Kh/tPftN6T8K739pvwumpeHvCd7rt3a6fd2sVlomtaFPc6M+n6Q9vbhN2nWuo6EHaBAgkSFYi67i6/b/wDwT18U2X/BYL/g4Gi/awfQYrfwj4N8N2XivUdL8pwp1az0+zsoQWJIYRXkgdCMbhb5x94VR+Kf/BNHQfE3xu8Z6Hc+Dzb+G/h7+1T8Mvh1b2TQmL+zvB32V7IsQMfLcm6052Y/fYB/4ia9i/4Itfs++NP2W/2mv2+vgVpmnC1+IPhTR4YfBWYAWuLeYatNazxR8FkcfYHx33KO9fU1KmFwuCmqV+dx1ltdPldkloor8fnY+NhHFY7MqftLezjLSO9muZXberk9fTtpc9o/ZI+IGnfHH9vvxT+1T4vv18jxP47XTvCaSzZzYWrrbWnljooKIsrYIy0jE53Yb8yf+C//AMPvFui/8Fqfip451TT11XVNdttBtvAOmDkJE+iWUUk/J4PmRzIT2CueMrX6af8ABN2ayH7O3hR7SyS01LTpVtNV08xZNtfQuFdQeuM/OrfxRsrLgEtXyh/wcv674C+C3/BS7w78WpLOGfV5/g/prywTwrKrOmqX6JkHJG8IEKgZcLjgBgfmvDGqsRn9eNZcsk23JtNLe0lp0irq91ze90R7PiBTxNPJFZpxdkkk7tWV4t36t2dkvd93zPkfRfFPhX9gb4b63b21hp/iXx74vi+y6rqIsynmjbtENjICpWJg5bcwAYR+Z90gA/Y28c/tPNPqeufAr4V/Dn4seK9YmMtz8OvFt3omoHUB8hMNlZX0yXm0Bsu9mPMIKsTnGeR8Dfso/tbftQ6fqnxa+FvwP8S/Efxbc/NZ6D4Z0hri20ONs/JPc5EUMh4IQ7SUX5cDaB8lftIeB/2k/wBlnx3qXgP9oH4R674L8cXUSSPb6/pUtrPp9q+47bQOBhXJ5mj4PzBT96v2LiLPMPgqf1WmlFWdotXcd/fl/wBPJa8t3eKd3uz8k4W4XxFbEPF1W5SbXNJOylt7i/6dRVuaytJqy2Vv1v8AhJ8SPgp4u8ceJtK/4Jh+FbX4BftaWUbN8Qf2dvF8k174Y+KlvbQOL3RrZL5so+3zAtq6x8AiMAbrhD9j74p/s2/8E5f2rPhh/wAFDv2ZfDqaH8G/il4rfwJ8WvCdzcefL8NtavjE8lk0jDcloHSO8glbDNbwvEQGUg/OnwY+Lfjv9tD9n2y8OfF64N7+1p4C0KTUfg149UmHWvEmnWai4bQLu4X5576KKIzWkzfvSyG23bpBu+Yv2f8A9o3x7Y/EbxV4C/alu2i8D/tG6O0XiiTWLUW9rc3d1dyT2XiRRGFQLZ6mDIzR4xEl1bDblwPgcZOeF5lUVqkk1yvXli9bXerbve7d01Z6tn6RgqccbKPs3elBp8ysuecbK9lokrWslyyTutEj+mDxN8FPC37Ovxs8TeEvC+ntZ6bq902uWCq+QkdyzNKo3ZAxOJAAe23qcYsW4iiuPL85ZI3GVRM469wMk9QO/I/iP3eG/Z7+Pd3+1H/wTS/Z5/ax8Q759djsP+EX8ZTXAXzGvrYy2N08qnIBN3Ys2D08/jgnPcGCKWFHWaMKo+UbT8vyjk59ARwccdcDC1/P/EeC+p5rPlWktV8/+Dofr2V1/b4ON+mn3ALYfPbwswEgP3Tn5SecdeT7Zycn5j8wcYopIXVmJKgbAp4A3EgL1xnHuc5wTjcJHLSRobZkjO3IBP3hyCTxzxgc45xnHC1HdGCUmfawAJLOCCVPG4jOc+hyM84IPCV4M4q39f1/SPQi3cj2wiAlkO9hw6LliMghfl68gcd88Hq9NQeaqyF0RGYBZUYZJPQKRk88H1647vUrjyJpIHk5Y7v3r5GM9WyTxkAHd64OeEEdtHFmSzWZWIbPDAgjdtyVB55wDx6ZyQBUOFnZFqWlyJYo4boLGY1jmIbYxOCMH7uMc4JIH5fKCxY0bXLyRl16Fo4ixOTyQoAxkcccjtjA3MZpI7iY+WBgiTBLqNuCQM9+vryckDBPAuRadpa5vri8jAWJj5Ymy4U4zuB5LAkj885PSadKdWbVtipTUEjI+2n7MEUEi3TaWMajjqAAoAPHBHBA6bR8xspbwzc3BzK6qAqzJhiBnHIG4EAjHGATjaCSbEtnoVtfE/2xs86IkWoiUsQMluckMQ4PKjqTwSQatRtYfbG06J3SV48vKFgV03s3Qg5ySG+bqT/eIyLp4Nqfvzvr0s/1/rsrEyxC5fdj+aKMPhWG+kaa6VSrEAK90VfAX7wwAcgdiFwDgYHBhtLVbOe5TarNJMPLllj5lV8cZUgMMbl9h12jg9OddtRNGspZBuRY5H2HcWbAUEE5JOOn94d84dfWFjMUa7NtuEimEyxjnaN2M55Ixn+mRmvRllmHkv3MldPXb/PTy/4c41jaqf7xaPY4bXtOutLkFzBazdVbZgYzhc88EjtzggAZKj75Wz4jNjhYiibTjyzlvKBDZQhtgySC2ME4PTnLUV4VWnCjWlFW/D/L+tj1Kc5VKabv/XzOqiXfCftS7cevbmowsG7OW5z1GP8APWpY0ZoSbg4xnOfrSeSqMDGpbGeMV9q4NqOnbff5nzCauyN2MrBycbcEZPPSlDMQSo688NThESuDk/nik3GPjHT27VHI1qyrrZCrIVX7w560bR97GefXrSBk+8VIGO/WpFcJhVXPXHHb2rRJSWrIeg0qygsU796SPBOHXn2HP0/Kpd/mKSoIHPOafHECSwJOfWtY0ryvElystRqgSAHaCR69aeVyCpXgjnNKsfGAD6mlIK5C9xzmuuFNrVmTkuhzPgb4Z6F8Pb3VL7R9Q1CVtVuPOuRfXfmKrZP3Rjj7x65PA54rrPFvj74T/sqfBfxB+1x+0Pe+R4c0GzU2VpEGklvp9xVIooejyO5VEHrksQq5qje6Xba7ayaTqVtHPBcqUkhdPlYH1r5G/wCC/wDD8Qvih8VvhP8AsT/DnS5ptOsdA/tgWUMnlxXN7NJJZWYbggshhkCr1InYZGdw9H65CTnj8ZJycbb9dor7ktvQ7OD+F4Y/MqWTYJRo0WpSbWiilectOl31vvJ6K1z43+OP7cH/AAUV/wCCuP7Tlp4C8B/FHxb4N8IXNyWg8HeB9VntIrGxTLPJO0BR76QorFvNOwHJVUHFSfHr4D/8FGPhD8HrLS/DX7Nvxjm1GFAPt/h7w/q0rWlqrHDNNGqhrhyuGyMKjKNzZdx9zePPGU//AASB8A+Cv2FP2IPhd4f8RfG7xVoC61408W6zal47aKSRo/PdY9jyB5opo4YyyoiW+WDE/NF4W+Lv/Bc9tQeU/Gfw5q93dSoNK0Z/B1h5TKdgZpCkUToFd9u0O7lQCASSB9Thcyp4KSVZrmffofRT4lpYWdXC5LhoqnfSTdnK2zV7WTWvvPzb7fjZqP8AwUn/AOCtX7OniT/hWvg39qL4uWPiq+uk+1aXr+t3r2um7fnFrFDebo9wTl32jIyc5KAcz+3R/wAFf/8AgqP+0F8NYv2Z/wBoj9qzVPEdjeSpc3mg2OiafYRl06xXDWkMbXEaMCyiVnUFVf7yKw/af/gvt+27Z/sy/wDBNzTfgr+07Z+BfF37Q/jq1VPDmmaHozKmmuZ13XkCSvO8ZRcRBt6iV9+3hSlfze+M77UfAOoXD+JITf8AjDUJXlv9RlmaQxg4LQYY4GOpOMgHqQQB9XCOGxGE9u4OLvv0S6W6uTd0vv0SPzbNc6hVqpKH7xvRLRJb72vu2235W8sPT5NU+H1xdWdrexrrN8uyeaRQAq5ViNrLk/MAQAOSvQkAL+sn/Bov+wz8OvHvxz8bf8FJfjU9naeFPgtZNa+HrvWpI47aDVJoXknvZZWwg+y2m5izYCm7jYEGMEfj7qI1Oyg+2XglN1fSMf3sO0lhxuXnnGSPbtz09i+BPxK/aum+AepfsoeCvjB4isPhn4p8Qx6jrfg7TLry7bWNR2xxKXVRulG2OL5SShaKM4JUEcMqVbFVFRpRfp2Tt+Pc8erjqWGoOrXnovxZ+nn/AAUH/wCCuPjz/gs7/wAFMvg9+xJ+zBq19ZfAyz+Mmh2s0kYeF/FEqahF5mozqcHyI0WR4YSOAvmuA7KkX6v/ABS+L1z4t/4KO+KPhfoc1pcJ4b8O6XaavbS3JjkgWSCS6EqJsbzcm4hTgqo3HLZG0/k5/wAG2X7FWmax/wAFNPDvjjxXoNx5nw68JalrunwhFa1t5WX+zx5jg/NchrvcFxhRHnrjH6V/sDeHfD37R/7QPi/4teKJlluPEHj298S6Wkd2yXEVlBdbbchkIbYE8mFh91ldkbKuVPLnuDqZZWjh5RvJpaevfT5/5bHZwvm1LG05Ytr3dUtvL7+3T10u/kD/AIO1fi14l0XUfgv+yT4Q1FrTSLDQrjXtQ06yfZvlMgtbV2UcAKIbkKcfxvX4qreXdhe/ZTdSPeXV0EWQZLoWHGWHI56YHr25P2x/wXr/AGo4f2o/+Cj3xD8U6FeiXT/Dl+fDHh6V5gEW101WimkVs48prn7TIG43eYAuTmvvD/ghz+yJ8B/CP/BIy/8A2r9Y/YN0f9oXxv4p8ZXC33h7UtPsLy+tbCOWO3KRfbEcR7UV7kxxjzJPNQHIClfo51f7Ly6lzJ6JO3bm1+8+Jjh553m1blas20r9eWy+7Y/DH4g6vYQXFt8Pvh/fLqusanGpvdSZiIrceWGeMZJ+WNg2W/i27v8AZHXfCnwx4S0W+03ws8rHQ7G5SW6LorLqd18u9mAILLyAq8qQuCflJr9Ff+Dk/wDYF/Y0/Zd8XfCq1/Y3/Z6sPhx4s+Imm6jqvjxI76eRLK1jFuLeBbd5nigZpGuQfICg/ZiOR1/Ofw74Q1LWPI8N3ttLFoumeWLzULVyLiUORmFRjluM7T02jjPT1slrrFVlX5Pi0Se1l9n0fxSk9Hon1v1YvhfM6uHjSw8W4tvVJu7sry/7dTaSWyu97W/Un/ggVB45/at/4Kb+FPH/AIf0uKy8D/C7QNRvbwJdMRqFy1m9jHKFcnIElwrErhQ0YChQMH7+/ZZ1m3+Ifj74m/GO1kD2/iPx/qlxYSnHz2v2l1gOf+uSp/nmvnL/AIJ8+D4P+CZP/BJm3/aN0nTN/wAWf2i0h03wJZ2xGNLsJFla0lBUdEgLXbuPld3t4+wavq39kv4YL8I/ghovhJ4QkkNonmeucCvhvEHNo5jmbam5WtG/TTey6RTbt5avVnu8G5R/ZOWqnyKLbbdvPq31bSV/PRaI9KYfMflJ5zkVxn7fH7Rfw+/Yh/4JnfFn9or4l3ssJ1nw3caDoFvAqGW5vbuOS2twgdl3YklaRhnIjhcgNgA+jeFPD9z4p8QWmiWxIa4m2sQPur1Zj9Bk1+Jn/B1p+2R4z/a6/bL8Ef8ABKL9mDQ9Q1608B3EJvtL0WF55NU8S3KbEhREB8w21u2zI5ElxcK33DXyuT4bmqutLZH0uLnJxVOO7PxvtbWS+u20rw1cGG1Nu8l5JIu77PCBhpJCM8lQCQvTdtGSefrb/gmL+z3+1Fouqal+2/8ABD4kax8O/D3hS1uLEeI9I1eSwvdQR0VJkR4+Sv7xCwzjcyKMcEfpP+xt/wAENv2NP+CWPwR0z9qj/gsE1h4s8T3xWbw78FrSOO9GoXwXKxzwk7b5k3D90SLWLJeVpCyiP7W/Zu1j9jD9u6y0z4AXX/BH/V/DfhXYWS402CystO0eIqB5jPbTW7QghQAIgXO0bVbbx7Vecpe7F2bPZ4dxOQ5ZmdOtmlJ1qcGm4xSak10d2k49+jfdK0v54P2kvin8WP27v2lk8HeLfi94m8WaP4dkZ7vV/EOt3F3M67lDkmWR/n+6i88YOOK9z/ZX+Jfgv4Q/ELw9P4H0/Vdb1HRdSTT/AAT4Z8JFbi81nWiqiCEhN5jgRpYyxPzyOypGJNsuPs//AIKNfspf8Ex/g/8AGC8/YE/4JT/sq3Hir40+J7iS38UXlv4s1fVLLw3ld0kaRS3LpdX+zd8kpaG3UM0oO0x19SfsO/8ABJ3wt/wRZ/ZkX9o/UP2dNQ+MHxsVCug+HfC+nvdQaBNMp3MJMOVIHE13gkKNkKhSd/NVowq/up6xS13/AD7+h+h0ONY5Jl1bH4aj7LEYvmvJxirwulClSinpTjFe9OXxNctpK57j4p/aQ+LP7PX7Bnhjw3+1r4R8OeHfir8QvE0p0HwJ4duprhrOGW/+1ytM8s0pZ4o3ZpHRvKWSWOJeME8d/wAFgv2lfi3+yv8A8Ee9W8WfAtHtvF/xG1GPw1Bq0M4il01bmO482dHbhXENtIikkbWl3D5gBXnf7Nn7N/xg+M3xXu/2w/2w/Ek2s+MtVctbWkhYW+kwZJS0tYiSIYUyQFHJOWYs5Zjvf8HBPwy8YfGD/girf6f4CdxJ4b8caZc6msQA/wBFa4kt2DHIKJ/pkZYjnaCOhzWWXVaOPzuMIq+ll56o/K7pVFUqxsnK7UbL5LovLf5n4h/8E+P+C8X/AAU3/wCCa1mPBPw+8d2fjLwg6brHwL41ik1CwgUMFM1s8ciTWyH5iBFIImZt2xutfWnxH/4PHP2/fEbp4J+EfwE+EOh6tdqsd1r9zb397HbZ48xR9pC/LnI3CQeitkZ/Mv4ueD/CngVLX4VfCe6Os6sUWfVNVjjEotFfarF5AmAhG32Hr0Fee6lDpng4R6F4duhPfPCTd3URGTk8AMCwJYcBQON3XqW+sr5asNNxqPa17Pr/ACp9X37Hk4vEUKVZ04tSfk7+rvs9ev3Hsf7a3/BSj9tX9tXWLiy/ay/aJ1jxykd4XW089YNPtXYDYLWztykEeACrMqBjuwxPBr5vMRsnUo5aRo/3QDYKA55OOh68fjVu71k2d8Y7MIyQrthSTDhD1OD0PzEnPQkA4A4G74c8A3+oaZLq93bzTC4YRRiNN008h6Rxj1J6n0zXMqTxFTlpLb8P8zhxGLhQjz1HZPY5CC3a6uEt4nUFyAGkYKAfcnpXaeFvCOueNLhtC8CRC30+3t1/tjU3f5M4w77iATkMwCKM7SR03Gvq7/gmP/wRJ/ae/wCCjniO8sfhx4bjh0TTJ0XxFr+pube0syRuFukxRsyE8MyByFDbUfFfpz4E/wCCM/8AwR5/4Jxutr+37+2CfHniSzmjupvhZ4PDiMTALiGW3td9y6tgfPI1urclgATXVRoYbAvmxsrLflXxPyv9lPr1f4nHiKuJxlNPBxu3s38K295rrbpp0ufkV8Efhf4t8V2Z+Cf7M/w68Q+JtZ1iLGqDw5p093e3ULYG3ZDHvC5zhQCOhOcV+qP/AARP/wCCGv7cXwc/a/8Ahz+1B8ZvhMvgDwV4Nu5tTvpPEGrRxahdYtJUjiW1VnkT946FvOEQCBsZ6N9M+E/+ChH7UWuaXJ8Of+CaP7C3gn4PeBvNMdjqOq6JGbt4wOJza2xit4ZD3DG468k5yOZ+JX7KH7Vfx/tF1r9uL9tDxlr1gsctxc+FLO7a3sLpVA3A6fZRqkm3I6RkgHnrzyY3i+jKHsYxS05YpLZdoro2/Vtu5lgeEJfWFWqTlKXNzPza6vvZbbJJWPevhb+0PZ/GL47/ABK8W/D7U7fUdO1Hxhcw6TdWt/GVa0t0EH2xFLZaMkRHcmTi4jOADkekeBBr/wAVNatfCejRRuktrYyJcSSszlAgljEi7PkxiRyQ/GyPBbJA8x+C37MHhr9nXxHY6x4OYWen/wBkXEOqI0yFInc2+yJMxq7KzIzZY5BVVACtsHtGlePZvhh+yz8YP2j/AIG6amt+JtO8I3Wr6ZYzq5SV7eycxhYwN5z5I/djBcxgDBbj85wsJY/OVCfLyVNLu65Zau2rs7JXTWyvvZn6RiqmHwOVe0jByaW61Teukk7p3SdktdE13PI/26P+Con/AATv/wCCWFo2i/GnWL7xv48jhjN54X8MhWW0lKhszMzLFb7hg7GLykEER/vPm7v9mP8Abq/Zn/axsPtkn7LHjjw9rEGktqM2k3emJLDLGoQDynt5ikys8qIrbQGLjsc1/Jv+0D8ePG3xp+JGofF74h6xdPd61evd6faXTFmd3cu15Nn7xZ2dlBySzH+EDd9Hf8E2P+Co3/BQX9gu4PxQ8GftK6xB4K89jH4P8RynUtJ1BmkO8/Z5cm2jLL80kBhdjgB+DX6BmPDVLHVIYTL3G0HzSlOCaaX29X7mtnG93qutkfG4DiiOFwlXE5xTcnOygoTacZfypJPnbWkrWScdNLs/oZ/4Kbft2eIP2M/ghc+BvhLpNp4B1I+ELjUlGnabFK2lIhVmKbUNujBfM4wxPlzuuBDGZ/50f2gfiT8V/wBvbV4deu7fxLq+n3PiVJvEPjfWpbqSTWZVUqsQeTKFwrKEjAyN69VUmvUPjT/wVA/bi/4KOeE/Efi74z/H7Wj4f8c+Ix4Un8J6NbR2Wi6To8L2d66oscckxlkkdA0jKzmOBlZpwwVML4l+KvGml+C/DX7JXwqmvbjWo7WRFkkSOW10G2ZN883mQB8O8CxvPP8AeSKIRHCqyDfIIRhiZUMRPmje3urVpbL5vsl6I+gx+b04ZGvZUvZ6XlezlOTv1avGKW6bfXU8o+Nt/PNq0vwJ+Emp2OnwwwsfE9xpN+72xiiUCS4aVyBLLK5boNoJITh8L4X4o1uWdn8B+BdJ+y2lunk3C2Q5usAbpGOSzM2OcnAHHGcV798a/h94O0fwrpHw3+Dt9qDzyxW7eI765cSCe4GA1xu2J5SufOEMJUssaZy25mPsPwD/AOCHf/BQ348+D43/AGav2Utbngvsb/E3iiRdJsXDYPmxyXroZo1wuPJEm9ueQMD67NaNa8pVGoJLV36dIR8/5n1fokfmKzt47FLlTqSbtFLb/G+y6L+mfD3w0+KPxT/Z++MPh/4kfBzxZf6B4o8I6tBqGkanZy/vbS6iYFQAOG5JBj5Uh2U5DNn+x74FfFJP2k9A/Z2/afvdEXTrr4k+B4NS1ewiY7Le7OmreeUPXY5mTPUhF5wMV+Pf7M3/AAajWf7OsUHxe/4KaftofD7wVpyy+beRaZq25nXOWiW4vFgjikI43Ksxz0BzX6A/A39tf4C+N/2jvgx+z5+xd4f1O5+Fnwlhk01/Fd9bSRRX5ltTZIsIkCu8aKzO8rKA7nKrtXcfgc3WX/VIyqTTk5RduyTW72v6eep9Zls8e8VKKptQUWub+Zta2W6Xr9x8E/GH9nfwr+33/wAFyfjN4H8ceGZD4i1ubxTpfhg3c0coN7pOkXEOm3BB2skSPaW7rGBgkM245NfPerfsn6zF/wAEvrf/AIKAfD+91WPW/DvxvudE8XH+0JMwRiztHsbwI3ypIkzyRnPU3aDoor62/aavdP8A+Cdn/ByR4X+KnxA14aZoXjDxpDqlpf3Z2RSWmspJY3Dkk8rFNcXAJ7CM8DIr6as/gb8Gf2cdW/ay/wCCf/7SXj2w0HwD8X/7U8c/D65FjLKunwGES3VwQisC1rKsbqmCdmmSuchW2/o0sZHDqEcP8Ps6ctEm7K6np0aUr99G99T85jg62NlUeIupe0qw1bSu7OD9G4uPazS6nwH+0l4v/wCCtnjr4/fFH4F6L+0NcazffE34U6D45tSmi2VnP420qyhgvbUaeIowYLmCA3Ekj24VnexePLEx56X9lT48f8FMIvFHg7/gsx+z5qj/AB6l0qK78G/tNeD7Wa2bVrZLVwDtisV23EL20Vrc29xAjlWUeYrqJJH5HXP+Ck1voXwA+DWseAY4NE/aC/Zf8WT+G9M1q2vUudO1vw8Ns1vaTbGVrrTp7UeQt3btMI28slFS+jmHzr+1j+1f8OJ/jn45+Iv7LPw4HgHw/wDEXVU1HXfDGjMYreeYnzUk8h932a5hlkkUXEMqRkNKVjgjmkiPj+xqYrmdJJU9nJJWaTSsttGkpaarY+sy+lTpVYU6k3zS1Sbbavrd3bejbXnvqfst8Ov+CvH/AARI0car+1xYfErxX4d1nVYYb7VfhjqXhW7huo7+MMofyBCYxM2FQsLgwEQxcjYK/Gb/AIKL/tj+Lv27f2qvFH7aHxS8Nf2XFcxpZeBPDxut7aLpkLiO3My8+ZI4MjkDbmWRiMDivN7GDxLdTT/E7xRpoklVhcWg1CNmjIyDHJMMfcG9AAwyxYE5LKB5Z8S9c1STUFvdW1oxSTyF1W4nRVhYIT5787RKwDbEwdg554DdGAy3L+HqksRCHvS11+SUmvkuVfO9j9Fznh6h/Z0PrblJyjeK0Vk72k011T0j2d72sc941+KvjKPWJPEer+ItQtZIyU02CG4kVdNDZJMYyAZzlSXx+7UjHzFNn1f8BP2x/HPxo/Z0sf2Zv+CiXiO78Q6F58tz8DviP4x3XF74E1QR7Ujmv5Pmk06ffDDNC5YQB4p1C+Uqn5q8L+EbSx0xfH/jOzb7PEwPhzQ7gktI5wfPk3cnPJAPOCSfmNb3wZ8Z+IvibY+KPCfxCRf+FbXN1YQePri1Yvc+H/tM32a112OHG4pbTvHG+MCRbgQEoblWrmxFSlR/2urK9Ru8V1ve/NLzb2Xbtol8Ti8gxmEo08N8Mai1XXk2UbdLrpvrfq2/PfC3irx1J+1Vo+qRfEuX4f6tovjK2ktvEdwJEPh+7iuo1F2wUkq0TqrsRz+74BOFr9Efg58Cr7/gqD48+PX/AATT+OnwfXwJ8WPCGsXnjH4U2lu8SpY+I41U+IfD1sxO1bLUWR7u3iUmK38sOpZcmT83PFXwR8baR8UNb+EV/pNvFrHha7nsvEMkN0jwxyW8rRzTGUna67jw4x8ozz94/up8Gf2fV/afH7Ef/BZf4f8AxDbTl8N2EWifFq6tZ4raXVtX0QNp8d3cPJgFbmCzlimLdINgXBfI+Zr1pVqjnN3b1bPqcm4frVPZUqcNJJqmtEpSitruysra2vd2ju9O2/4ILS/ErWP+CGnxS8HfEPwdcaH/AMIf8TLq98MaZcQtFNZ2EP2CfayH50YTw3e4n5iWY98n7C8PyNeaNaajAdouLZTG+VO3IG3gZ3c4PHfpnlq774sWGj+Efhr+0toXhfw4trod58MT4k02+h2m3u57601PzXjCjA/eW4Y98uD0IJ8v+Frzan8NNIV4wjfYFEnm54G0fQDjbn2wD2WvzXjOkvbUqjWtmvx/4J9BhfZU8TUhRbcWoPW17uEW9tFZ306bdDXkie3iaMuEBUHg5zxgDrxjpkY9F6lqdDA0kcsMsnmBWDblzkkZIGB04GAykcYA4Bc25LcGMTIqBUQ7vMOSOn69Ack+mDwA2W2PzT+YpfYULMeMkjgA5I+bHBzyB95hgfEezcZ3PR5042K7o0oDiXa/B5IwTjocDHQdse2FyxWGaNrZSu5QJF3E4XOFxuBP3eMegx/dByZVjjiumQRMozjp90YGAPrjoM5OfvHgMhgPkGzYM4yBuYZwM/d5yD0HGSc8/MekKLjK9v60KvdWNHR/D9tf2/2h7qZUZiFDqMsOcEHjHDEAcYxwMdb0HhixVY4biaRxEcxqrlAvrwDjuegAxxjArCg1K8sV8yC2jYpJyoTO7PPTryT0yfxPS6njG4ECIbE787TJDPvUnpxuBLd+OTle+Dj1sJisqhTtVjrbW6bv+nc4a9HGyleD0+SsXk8J6TtMfkzLkkBjKDt4A4Gf0/DGOKtS6LpsMbf6KhUksd5LY4xwevr/AJArAj1/VLF3lEf2lGy2HlJIODhQR24bgbuRxn5iLEnjmZWMSWSO20FDC24Nle2CRnPbP0zgmt6eOyeELyhyt+V/yRlPD4+UrKV/mbhsooizWkcSyPnazR/ePqcY9KyNUl0XUiNPe9MbBA6RpHgYAA5JU4AJ5BHQjdwcGKLxhNNI0U0CuhA2LBKA+c4GBuy2fYg4zjOM02bx3Z/aBbQTsm5gEleEOCScKFAPXJPfoGwDglXWx2AqwtFpLs1v+KXzv2vawqeGxMJaq79f+A/62Mnxb4anMn2qeYSiPAURNnavAO7dnIxyRnB2gNkYWip7jW7kZddTMm59yGSzUuMrgAbGGOBtyOSF4OAWor5rF0cJWquUJNLza8uzPZw868IJSSfy/wCAdehzCftB4z19RQgRfubgMd6VNwiP2nkdgRk01TDnAiI4z0r7vS0X+e58t3/pCuAD/qzxgUMhY5kXjOee1Ei+e2wkAeimmF3UhWHsDmoeju1oUtgMaOhCnAxzhRSSIMBlXI9uc9qemwoCCcEdA3/16k2ExDywCPY/SiNLnTaBz5WNiABZtuCe2KeZFOTnOTxTVGzPv1GaYHVWYjPua1U+RJEWu7k29SBhuuaQyde2Qc5FN3bhheD3xSMxSMgehzV+0e4uVC7njIeJ8MDkFQOtfF//AAcbfGj9sr9k3RfhJ/wVB/Y5+IktrptoyeHfHOhX9hFf6ar+a9zYzvbzKyxkTfaoWmTY+TAof7tfZhkG7DKeD2OAf1qLxL8Gvh3+118DfHn7DfxotzL4a+IWhTw20uAXs7kAOJYgf+WkbrHcJ2DwEnrXp5NiqKxPsqiTUu/dbf13OfFwqKnzwbTXbsfP37AX/BRj9hf/AIK+eGfD/wAbL74g6B4G+Pvh3wsmneLvC+sXKwh0ST/WQCVh59r58zMjIxaP7RskG4qT3X7fv/BTD9kr/gk98D28eXWu6Z48+ImopMnhTw7pVwsqC4A2tLKyFvIiUyDcc+Y4bagALFf5efiN4D+M/wCw1+1N4m+D2uaoujeKvBHiS70TVZWhEttL5UpjcvG6ss9vIoDbWVldGGVIOK+wvgDF+zf8MvFXirVf2l7e78R+J9Otov8AhWKwXKDw+jFvM/tCVNrG6jKMk8KA+XIpXcTuXH11PCUJ4yNScU/Vv8tvnueJWxMqeFaTaev4+f6HC/tF+OPiX8e9S8RfteftZfEt9a+LfinUEeHSnTzbbTLWRFW3t4Ej3eVOFZgISEEEcTZO9iB4d8PPgJrWv6pp13dafe694q1q4gt9F0Syga4knuJJAscaRgEvI0rJGiAkl3yeoz6T8WPir4n+Inj268b6dAkOn6zq89rb6nOY0lkjYhrp5QDlJJA6EkAKFdkHykqP1d/4Jj/swfDL/gmN+zDd/wDBXD9tHwZGPF2pWItfgv4FuyEuFEsbCOYK2Ss867m34JhtQ787tq/oWKrZdh8GqtvhVop/ak1fm+WlvK1uy/M8N/aWaZl9XpOyk/ea6RTtbrrLr3fpcofD/wD4Nff2I9S+Afh39nr9pz47Lo/7V3ivRpvEWlw2viAvbWMMeP8AiW/ZQdlzboSRJKMSyOszxsY4yo4VP2N9D/4JqeCdevvGPw40uK88N2f2fWNU8U2ksVzJcNt2jS5PLe3LCRPNg5JljUmQYYonvP7JHw7+L/7RHxhu/wBsD426bdav4g8Vv/adn4y0++CR6U8X+otraM5aKOEqsSrnI25OTkn6O/bo/Y70P/grD8Av+EW1mK20f40eAYJLnw7LJcGC21iMjmN8ZxDIQuSBmGQgg7HIf5vhfivCYLPZYLFpJzSlzNPTW2rW2u8W+Zbpaa/UcbcIY6WXU54d2nCPMoJp3i+jWvLPTZ2l0lo0fnj/AMEVP+CiOl/Cv/gohp+o/GTxRFb6B470yXwtBc3ZRVsri4uI54ZnZFRBuuI1jZtoH7/ceELH9NPj34z+GP8AwSO/Y18bWngrxzpc/jGTTriLwHos1yizxiWUw2juhOSkbSRl5DtVmULkbga/lO/a61b4v23x9134L+K/COq+G9U0LWZNNvfDV5am3uIbqNwrLIgxj5lBGMDGCOtfZXhrwt8S9W/ZAttK8V/E6Xwxd6teXt34m8aeNXvLy81u5lhQGSD5XkeRIlljZy6ptdFLKSS309fC4LiXP5YmMXKnRWtvttbJLzX4LpufM4TEY/hnIIYWrJKrWd0n/wAu00rtvyf4vrsfOHxC+JvhuDxZd+GrW2TV/EcepCG4hi23UdxfecAqEncrRh3wW5DuT16V+yv/AAUN/YS+LH/BB/4K+F/2zf8AgnF+0X4q8J3N8bDQfizolzqov9L1O++zkx6mljdI8O5pI5UKbTsEqeUsYD5/E/wp8H/+EC1eO38FS3V1fsjfbNbuvKiU7WEoMIJPklQqnIdnJI+7uCV9V/tB/wDBRf8Aby/bw8EaP8Fv2nPj9feI/BPh7UYbi5kk0W3hNtdCFvKknNvBGbiZo/O2LIznlmOOTWVXD5rmVaNWtGMYp/D30frdpbvZb3u2fQ5Dh8IqywmDUpSnaz2Wm78l3f36I5H9of8Aa7/aE/4KF/FJfjR8e/G11rN/DpsUD6qII7ZLSFN+2OKKJFSNf3hKqq9ZGdssxz5T8Q9Y1vVZI9F8P2q6dawstpDBYHJlLAII1JBzM+WZ5OiBmGeDn2K2m8M+ANBGrX2uvYaObKebQdNskLXkEjucNJIqKBKxC7pFyVG1V/eKFTwe8svEPifxn/ZHgdZIBbbGkvZCCmnRO2/b6eaMoe/Az0Ub9MdWjhKSpw+JrZabbJJbLS+/r0t++VcpxEsqpYbC3lVn8SjpJv7KSS0ikubV62bktFy/0tftXfC/w9pn7SfwF/Zo06zU6V8LfhlusoFjPlqkjQ2cXPQ4XTiAOoBPrXrkMaxQrGqhQowAB0H/AOqvzP8Agd/wda2GgeJ/Dvwv/bo/ZzsvF0E9sIX8Y+EYUTUUAX/XGykykruR0ikhyeVTlQf04+G/jr4BftS/BHTv2of2P/iXZeMPBOqozC4sHYvbMv343RgJInQ8PFIokTqRzX5JnGX4n28ql00ux8bicDiMoxEsNiElJO10003ps16r7zX8BfEPw38MddbxV4pEq2K27pPPFC0jQg4O/auWbGMEAE4JwK+ENI+Mf7Cn7DPxW8W6r/wTF/Za1b4n/HLx3rV9eeJfi14+tLkiC4u53lmBmnSOZlMj8wWyQxuAC0hI5+1rHTLPWrmHTLmVFjupljZnHygMwGTXEftrftT/AAE/4Ja6WuqeHf2ar/VPEeqW5Oj6/c2ka2c0/dPP3b965y0aKuRj5hnNLKZYmpTlCCSS1uaZdkWYcQ5rTwOApupWnoo3SvbfVtLTd+R5R+zp/wAE1fHHjXxhfftvf8FLviebzVPs/wBr1LUvEl1HbRWFqmXEcaNiOzt0ycKAqjJOCSTXBftK/wDBYT4I+NdKuvhH8F/2k9I+C3wjh860uPEPhOIap418RGNwkgsbWANFo9uyZxeX0kc7Bo2WNBy3zn8T77/gqn/wVzgtvEd54Z8S+INLk1Bm0fwlo2mNY+HrB4yhSSWWbbbucltryySSfKRkA1i+Pf8Agh/8DP2Bvg63x9/4Ke/tcp4LstQvJFsvB/wz06LUPEWvTsGb7LbzzR7FkwedsUkaA7nmHDD0Kas3Za92fouL4Cy3g9U5Z1ioSxDf8Glac422XK95SfWSUY2fVo4ix/aU/YQ+MXxv8GfAP9hLwrL8GW+HrTala/EnxD4gdtV8QXNw8bSve6hBuWymTyRIgdzGPMmw0WNj/uL+z3pv7QPh34LQ/EO7+L0Pj6+fwvFLbRJqqXkWp3xBlkPmrsjjRdwgUR9QnmMWJ2H+fy4/YvfQdNh+N37M37H3jLwB4A8ayDR/D0uuazPqF3qTpHJI0ryykiSWRQxcwKsAEexdxRnf9L/2JL7xf/wTx/4JIeMfjr8NPE2m6x4w8d+Mo7Twcq2kz6fHdF47LKxuV3iMx3chcfLIIVwWGM/PudCrnsoe0kpct7J6JL7TSVtbq3M3forXR9LxpkWIyzw7w2NxMoKaqOPsmlUknKTfs3UvzKUUm5La6cVZwVvr/wDaA+I2meH9d+HekeJ/Dlro3ivxdos95rGjWswkFtKi25kUuAN22SZkD4G7afTFP0zQPA/xg8EeKv2YfixAsnhv4haJcabKGOMSSxNGwU/wuVIKnqHjXHJFfK/7LfwA+OmqePpP2lP2pvivqPjDxjqloiG6vtqrbQ/MywwxRhY4IwSxCRqq5ZjjJJr6K1exh1myNjIXjJOUljYq0bg5DAjBBBwQRzxnpzWUsdGhmSr0ZbNfPZPb7/U/C/YurQcZK1+nby110P5cP+ChP7IfxT/4J0fHzXP2VfHovZvGAvPPutae2ZIdbtZWbybm35O6CReAQchg6EBg6r4FrPgjVPD8KafIj3Oq6lIkVtYRW/mTM5wf4QTnoMLnk7emSf6s/wBsS+/Yg+NXhTQ7b/gpP+zPq/jTUvBzSNoHibw3bSfaLmN1IaMvbTQyxlxjchPllgHBQ42s/wCCaPxY/Z78U/Hy08A/sVf8EqtN+GnhazsJp9d+IuvWtpbaokCoVjiCxJLJM8kjIvz3RwpdsNtIr7z+2cHi8PGSfvvRLZLz3u5Prf72fJRyzG0MW1dezvdveTfbayiumr+R/N58A/8Agmt+1F428b2HhDxF8BPE+l6lqFrDfWGneIdHl09p4JJPLjuXNyqKkBkyiuTtZuM54r6C8Y/sq6X+zrpq2mu+NNJl1ew8qDVbG2lS4ngLRyefZiJhmAqRhnJVxnHGTX6n/wDBTj9rD4ReM/i94m+J3xFuDqPhfw5jR9B8OpbBLzVjGZRI8M8EsbfZZSQ6yl22pLIUXLso/Hz49fGrVrjUpfiN8WNTdluUZbCO+vXneKI5VU+bLFgu05PzNgOc5FfrOS5Vhcqy+FevGz5U5N3suu/lovXS+5+OZ3neIzbNJ0cPJySk4xStr00j56v0s7bH7hWX7OP7RHwh/wCCPfwa/Z+/ZXsdV0y/+JEtvrvxK8W+DYPs0tlaXkP2t4y9vtZCRJbW3mr1itmDH58mb9nv/gmh8Afg1p0VzL4Zjv784ea5uVDs7nksSc5Oc/j69a/ML/gjh/wWT/bg+GvjW90PwN8QrvUfhR4T0+KTUvDnjKf7RagMdiW1oznNm5Y5REkSI4O4AV+nH7J3/Bwr/wAEvP24PG8vwg+KniJvhH8QIJzB5utyAaPqMo4Zob/ase3ccf6SsDHgKWr8f4lyLMcSvr1OopQnJpdLu/RPX8GvPY/Y+Hs5wcUsFUg4VKcU2nrZWXVaffZ+W59E6L4e0jw/apZ6LpsVtEvCpEgAH+f8+tW8EnCqe+BjHT3/AM/1rsNf+C/iqzto9X8Ozw6zp0sYltr3TWDmWNlyrbQTkEYOV3AjBz2rkrhJ4pmiuYWV0Yh1ZCpz6EHp+P8A9avzavh6+HfLUi16/ofbU6kKivB3Keq6Tpes2n9n6vplveW+5HEVzAJEDKwZTggjIYAg9QRkY612HwY8S23h/wCIFvDqLKLPVYjY3Cyj5SXOY8g8HLAL/wADPbmuW42glsA8kc/Q/h/k+lRXtnFc2r28wO1125DHI9x6c45/+sKihiKmHrxqJ6Rd7F1IqrTcH1P5qP8Agqj/AME1vG37Fn/BQH4gfCbxt4de18Fw63LqngO9xzrGl3MhktVVgCSsYY28hAADwsoGFGPmD4leIfFfjPV7f4Z+GNMOoymWJLa30SEy+cThY4okjGSPmChccnHHSv6nP2zrX9kb9pn4WWnwe/4KW/s5654ysNIuC/hzxl4WilF/bbhtYF7eSOeNiMKwXekuBvTKivIfi1+yb/wRw/4N/vgJL+358Jf2dL+f4r6vpMkPwp0jxrqV3fapJqc0QKBbWZytqI96tPNsEkSEoG3yLG/6rSzzD4rL1ChdOXxu+r9dNP8Ah9Xd3+L/ALDl/aUZyXNb4I22fdf1+SS/DOw/Y7/aK/Y0/aC0D9m34xeJ08F+JvHHhCPV9U8FLerdTRhoZ5LKy1KNDstLiV442RH+aEXEbv5ZJx+qP/BI/wDYI+HPxx/Z31TxT8RPA918NPDvhm6vz8Y/i94jvgL3X4wvmHTrZrgFLW3jBD3EmACBGrCRmbZ8AfsLf8E/v2gf+CtH/BQG4+HniH4g6nqWra9c/wDCS/Hn4lXGC+k2Urh54EbkC4lc+TGgwB0wI0kx/Rj8WfFP/BPX4Xfs3Wf7Olr4WPjvwb8KrCxtB4E8PSPqFpH9njEVpb37b/JmIKg+VOzjcvmshMW9MsMsROuvq8bzeit36HrZ/gaOT0pRx0uX2V/aXa5Y9bX7qzvZ910d/mb9mnxb+xz4Q1KTQ/8AgkP/AMExdX+KWuxXzSf8LW8bW5tNKjuflQ3Iv7/fKp2rnZFHBuCgL149L/aI0z41aVpn9rf8FLP+Cv2g/B+xu4vMTwJ8HpI9Gk8snGY7ydn1Cfup2rt46c4rwX/gpp/wUM/bY8F/sa2/i74T61ov7P2k6lqTWPhXw/pFlv1LUrCMASPDctEq2yqWB+SKFl2su45FflB+yV+xn+0z/wAFCPjhd3+i6lq2r3zzLN4y8Za7dSTpYQu3N1czyPuY7QxAJ3NsIHTj34cM5hXqqWNqb3vaW3fXbR76tbroz85lxvlNLDtZbT2ta8Wr3V1aNru620WjT2Z+wfws/YI/4I2/H7xkl/8ADf8AbrtvGniOUIqp4z8UQ3eoXBI3KAs/kysSCTgA9fwr6Vm/Y90/9nHQJIfDvhyzj0kxhf7SsVyiLzgMOqZGPmxt6cnha+CPgV/wTg/Z08HW/iLw58Mvi1feKNG8NaO1/rXjFNOitrv7RIvlSrbtKHFvbNEz5fB81YpChkETldP/AIJB/wDBT/4oeOf2+Z/2O9M8F3eo/BLWfDP2O008qrNoF3GQq3SKoDLBK8oikQD5TJHJ8gjkzxcT+HWWzy+VfC1p88bXi09Lq6ve3Tdcq9U9C+F/EnH4jNY4XF0IqEr2nGSafK7Pa6s3ompP0aXMfQn/AAUj/wCCd3wo/wCC0n7PelfCXxhq8Gh/Gj4cO1/4K8QXQKLqFuSvnW0jDLNDMqRCQrl4ZVSQAglH+M/2iv2Wf24f+Cjf7QfhT9k7xt8cJvhH8SPClna6y3h681GMFr2DELapbXwd5LeaWELK6Wfneey+ZIqfNIP0f+Kvw+uvCvju88D6drtzY6no9wtzoeq2kxinhiYZjkDDHOCykYwdrDGMmuP+K/i/9nb9oPR9M+H3/BSPwCINY0K4L+Efi94ctGhn06UrhZ/MiUvZzAkPna0G5RLtj2KR8rwzxRh6FKpl2YRSm/d5ut1p5XXdaX38n9znmQYjEVqeNwknaOvL0af32fZ69rdV8bftkf8ABux+xF+xx+wbLcWvx8uLP4i6Tq6X7+ItVkm/syb92Q+ni0jaSREfeJAUE9wWDMq+VuVPys8H+AbjTr6LU/H+ipNbXdmr+GVCtFDdxSExpdM2M/Z0ZSy4zuwCOtftb+1//wAE4v8Agoh41e2+KnwA/aC8OfHzwY8YisbW6uEttSa0Mm/B1CCZJXhTahkS3n33jNIZlfcVb8tf2gvhx8Yf2bfGc+t+PtC1nwndqfsAsPEGmz2l9eCS1ZW8qGSONI1U/LwSY42yDIA0g/T8nqUKeEleqpJO+n+VrpK2l1/wfQ4WyehicxWJqQalGyto2k7Xk273srtbq6XN0T88+KnijwjoXhq58Kanr763qN5qBcanJIkFusYUgMcYO9cjbtcqgOFO5mK+SeCfA03jbVIvFfi3Ti+hm4aa0spyry6lKxG2U5AOCrAgYC8BjtUKFbqkHjT4i6/JPa+G4J7F7nzRbyxOLaTbuyF3MWS1TB2qcPKRvbcDhrnxQ8YRaRY3Xhaz1hpdSnYLq17Mu2C0gb5tkO0nGAckAZO3Oc4B8THZiqtZyl02Xe1tX3X5n7bh8Lhq1P6/j6fu07ciatzyS927d3NK3d6aydrc/DfG34gR+JbjVrSzvhC9lNG0So+wTjJQ7VJ3NztXKAE5BPAO33L/AIJgfBq313TPHHiHU55F2aTJoPxJ0y8RPIk8Pa9ay2FvdqSuVmstRayuRHnDs8DqUNu2/wAB+Efw68WfGDWY5tB1eGLTtL1HzbWG8jMiR7yoll2jH91QBkMxwRjaSv1d8Ffg/wDGvxi93+zR+yd4W16ay1e40/Tviv40tNNkntfDtlc3kcoub+fb5ccjvalo97DJhKrg4A8mXtMRerVe/wB7fl/X628zA8JvOsLPiHNL08PzWjb4q0nP4Kavdt6q7skldvVuNH4Lfs567+3B+0ZpHwm+Hds+naDJq3hnwv8AEXxTlWeacwx2sVkH+80862srlh1dXyTt5/XP9nj9n7/hDP8AgiJ8eP2OrNrP+1/hH4hnvIYtOcsLNoRb3Ei7iAfMfybrecnmZhkfdH0t+wL+wJ+xx/wTT+BPws+BHxZ1nw7YeMdQ1+GTSG1treO88Q+ILa7v/Ku0IAeeby9SVFXLeWgiUHjJ73wn+yH8Mfgj4Z/ahvvjR8TNK0Lwj8W9dvbzV9TvL9LSHSrK8tWjkeSaUqiN5lzKQSQMleSeBxtQVNx69S6HGORUFOUYKFShOjODjqv3deLcKb6RUHJydl7SXvO2kTyD9uD40/HfwX+yj8B/2UPhd4esZJ/ih8PYrTxjrF8ztd2FpaWunB40QY5m+0SoztnaFfaNzbk6b4faVdeG/DOnaY5VzBbLHkL0IXhge5wOnbtjkt5b4x/aB8Lftk/tzT+N/gvex33gH4f+HYtD0HVIV2W19MHaW4nhLD5oslIgwBBFvuAYFc+x2yXE0W9ZgZ+rZY7ScgkDPvxnnnqGb5R+U8UY6VfNPZp3jC1v1PisFGNSM8Ra3PJu3a7ukPkhuYsi3O9FTCgkjacfXB4xgZGMdgSS7bePakwosTbch2bcF65PJUHjPcf8BHWs955jm5tdjs4AaTPByOB0+7ll9eV5DNwJZZFEpaWIMcZxsCsPmPHUkc59ckHknp8zJ2l+n9XO610O893QyKMtu5dGx0/+t83bjrtXgu3tKyyS5ZVUHKL0A5OT1PGOOPfC8GK4RxIwDhhwwz0LZBwOeeRweTkjqR8sAe9nhVHIZgQQVXndk9h79CM5J43H5gnUknr+RSgmtB7QeXM043EtnIcn7vTJDYHTHPB7EhcAxxxyAgtbjaytuAct0yM5HDe+cE8Z6BaS5uSttHeZZ3WX5GVgN7EnHQE8t025OTxnlg0zxrOjSRL5T5JAUnn8/lIySCODggZJLVyyab/r+v69DZJ2I2SVIhHKrEgNucSAlQFG7qTzxg/hnAwlNntmMYuArZZSJS69BxuyOhDADJ98Hsgk/do4ImSO3MYD7d5XI46DlRwcEH1xyS1Q+bcBHXP7w5kiBzhmwFByvQ8Y+XHB46M9ZTaauaQTJZjCZJYZAUDKTKSAc9ASeeuVGSfQA5PyirsnNpLYR3LFE6kyAsFyFO48knBAJHzccksdtXJUud4uopLVNm3aTDnJ2nbIMDIIHPOOOBtGWqpfylQZ4GhdChDIVxtGBg4yMYU9BgYPGBlypSsrp7gld2G3f2pYN9ywSNcFwzDdGD97Ocg5zjkHj+8fkBUMRVrlkjtHKEbhJ5ZTJxnJIxjAJAwAMZI2jlis4Smun9fd/XpY0ai9/wCvxPTJZERd79D1980xJIRhxH3/AAoACIxlbI5GCPemqFEoTZ0PPzZr9BcnzI+RSViY5GT0A7YzimqcE+Zt9flFJLLIHwgBzxgnFNUkPjaefSm5rnBR0FAjIwFx7bj/ACpxZyg2gMAOV6VGoQAZXr/tdKVl8xQwI9x2qVKyG1qLucNkLhfTP5UiiOU/cHXgjgUgVQfu4Y+9IxGfuA46k8cVLlbcaV9iRsKo2YAx/DTAkm0uoPTnn60schKgphv6U7YSCV/u84FUkp6oXw6DWKcYHHIye1Lp93caRrFn4htHPnaddxzx4I+YKclfxGR+Jphj8z5Tk+56mnxoCpjfqTyc96IczqJ7W29f6/qwO3K13Pw6/wCDvf8AZstvhb/wUe0P9oHQNKEWmfFbwLa3dxeImEn1KyY2kwGOCRbCwJ/3818R/skfFr40+LbvQv2bvCfwHm+KcaatNc6DoFpHcPf2rzLGJFgdN6JCWjjkZJYnjBDEgB5N39JX/BSL9gL4A/8ABWv9lvw98DvjP8YLL4f+Ivh/4jhvtI8VTxxSSLYbQlyipLIgKSwYBO75ZbeJyCo2t8//ALLHxY/4JA/8EloNU+H/APwTq+C3jL40+PWU21/40YI8V1MDtKNqEiJGkf8AtWkDoQercmv03D4nDVKKqydla+nft5fj6HyeLoYh3p04ptuzve1u9lv5LT1R5Z/wT9/4IwfCb9m/wrdft+f8FVtWtLPwfoN2NT0TwtrECE6lc/KYlaJRumTcpWOErvuyQzRohCN9O/Bz4JfG3/grf8bP+G0vj/Yp4X+HOiSyWHw08J6mN4trYsoaRkHyvPKQhkfOMhY1LCMY4az+EP7UP/BQ/wCLll8d/wBuHUorXS9LkL+FvAemb103SUPVlRiTJMw+/M+WboNqhVX6/wD2qtD+Ovg39nL4eeHv2YdO0fSrCximk1vxLq+oR21l4chNqyfbZQzoHVBNM+3++qnIIBqo4unxFmEcNzKEErb2SS7vf57t7dEef9VXC2VzxEISqTbTdldybaWiWyXRLRLfqzpvEPwRv/hHpNvZ6Vp8B0iJNkEmnw7Y4h2BUD5P5H17VyOt6XqLX1r4m8L6i+n6zpkwm06/iHMb9CrA/eRhlWU8MCQc9K+S7X/gtjN+yd4Tt7Pw9p9/8TtDnuhapd6lftLda9qLuwke0I/1SSZjlWNVkQKSAd7Pj7t8B/He5h/ZTu/2oP2uP2X9O+Gz2+kTao3haLUV1HUVtUjLgTK1tb+VOwGfJ+YruAdkbcq5ZtwTjMuxadGompPTVXu/K/N+GnVkZDxzl2e4WUnFqUVeV07Lv71uV+WuvRWPCPi1+wv+xz/wUm8WzfHX4zfsvWtt8cfh9aQPDremyNGdZiTcY0AE0aXKnYUXz/mgZkAk2fe/LD4reFf2n/2s/iLrHwz+LmmeJfh5pvhmGCDS/C6+B7qNoYoZ/Ij0+xQKxYwxMZCzEgFXVN2d1fsz8Iv24P2UfH/iq/1+H4X6r4Zn0JUms9U1BoraW6tjE7y3IgEwuIbdSI0P2mOIv9ohOwq4Nei+Jf28/g54A8P2nir4raB4l8Iadf3/ANlsrrxJp0Vusu5S0cuPNJRZAPlDhX5wVBVgv12RY7OclwroVqPNd30dn520e6SvZX00aPJzTLMn4gxkMTRrW5VZrdOz0vqtm3a7trqj8J9F/wCCJ37W3x61JNI/Zr/Zj1zwz4cS4jl/tT4h2FzpDzL5aPJm3uJQjxLLuSILukdQXkcbsV9bfCT/AIN+v2Xfhc/hf4V/tm/tc2HhnVddvI4/C3w78IeIIEuL/UWjVXuXuLqESXs0jIQSltEq4RAxOCftPxb+0J+yR+2Tp/iK20b9rj4jaPZeG9Pju/EFt4L8Sf2Q+nwPvGHa3UTE5jfcpZmUYbARlJ+WPBi/8G8nwz+Jmq63Y/tH6+PFWg6uP7R8Q6mdUuJ7W+QowY3bWjL5qsQAdxIZHHVGxOYZ1nlWo+SlyWVrJO6VvPa++iX3H1uR5ViMBRcMLGTb0bSbb3066a3ttfU/Hb/gqN8Dvip+yf8AtheLv2Z/E+jW/wBt0q6LwXtnp4S1vrGcM9pfCILtDPGNkdsjEK0cpdjggfev7Bn/AASc/Zd/Y+/Y0tv20v8Agrv4L1iwh1W5iTwb8HrK7lj1C+eRtyPcojxTT3cmPM8jfGkUcZaXOSsf6kT+Lf8Agkd+2j8WfBfxC1r4mfDLxt448O2lu/hi41LV7ZNQZHZJ4gYHKM58wLIIymUZmG1Q7K3hHxo/Ys/aY+M/7ZN38df217/SrvR9Plkg+HmhaDfyXGmadZbshU81EY3DAK00jIrOwGPkVFXwMzzLEUqbqzvzNa6W+7sn+J91i89zSjSjSjz0q0177a5Xa+ig/iSdryta+2qtb5w+KP8AwSn/AOCVf/BVX9mf4l337FP7OHjT4OfFHQfDwvtIuvEwcx6gY9zxQskl3dQrG5i8tpI2ilTzAcsu5G+Ff+CTv/BQLxP/AMEavGMPxG8a6zeXvhjxRJaWPjDwHp0pkinhXCiW1iJAa6iDFvMzyMxltpzX7P8A/BTf9pP4b/8ABMP/AIJ3eJNaM9ppni/4g2L6LoFsgCSqJIyskg7kwxSOw/6aSRqeua/Dz9kn9krSPjN8QR+0j+0z8T7TwzpOmaFLqnh7T9d01nisIFiJido1cF5nlYCFBlmJ8xl2gBryujVxNHmqKzl31tHW7/L56en2vAmTYbGZJi6+Kpe3q137Om5XkoRs1UrOKvKTTajSS1lNO3w3X9F/xF0/wvby6T418E3iXHhvxfYi90aeNCqqHRX2gHBAZWDAEAgbhgbar/CbXv2odU8YHwbqD+FvEHgS2xNf6h4qgf7RpsanICMp2zngkCQAjBPmAACvnj9jL9pKz+Jf/BJNvidcaA9hp/hX4ixaT4OE9y8kk9v9ttYfNLuSZGb7VdZPTIO0AAAfRlt8L4/2nP2aviX+zfcaxfaNB4/8D3ukt4gsodzWP2u1lty4yQGZRKGC5G4KwyOtfMToRwec8lKXuyu/U/NM1wf9nYythZSu6U3FS8k9Hp1t2duze55l41/4LCeE/wBoHxH4j+BP/BLNdD+IviLwzEV8X/E3WWkg8E+C137BJcXQ2tqUpAcx29mWWTYS0sagmvyj0nwt+2B+2V+0sfH3x7+Otz8RvE1tr7HwhpOsrENK89ZMhhZlY4YLBIsyHzEO4MsWGefn6q1D4Y+Bf2HfhF4c/wCCWv7FXiKG/wBT1qxjufEzadoK3M/ifW1ljM0qSFgZVYp5YyI4447ZdzlFkYfd37DH7BHwr/Ye+FN38RPHNn4fsvGl/YLc+JNfvnR7bTNhd1QTybWYIXJkmZgZHBIKLsRO/Fwr1n7Om7d3/X9eh+scNrJvDTh55zmNNVcZXs8PBp3UVe85J2XK35PWKs1KzXgX/BTWLxja/wDBOfwz4o/aj8f22kL4a1KT+3NSvLePS0vYVh8tA0Uap5KyS4VYol3tGyx/xOa8M/4JGft9/Bj9tT4J+E/2B/2s9GTwlqfiO+v/ABb8A/EEtwEi1+GLVb+B4mUYSO9juIrsfZ8lXgkUJhlBPhP/AAdRf8FLv2Uf2i/2c/h9+yb8DP2ldG+JXivRfHD6x4u1TwipOmwxx2s8KJ5sbNDIWe4+VUklKiE72BILfmB8V/23tG+If7EXwI/Ze0P4XXGieK/gjrGv3Vn8QrTWyJryHUb4XqRLEsatC0UuCr+Y2CMqFLGvPwfD9LD5lUx1So5ynCMNbWSSV3p1k0rvyS6H5nm/GuYZpkdPKVCNOjCrKraKS96TdraaKKk0ktNeySX9V2seBvEPgdv7I1zSXhEJEaTqhMMoHAKNjBB49xnBAPFZwwW255x3r8pv+CDH/Bd3/gqr+0j+0L4a/ZB+JPhHS/jP4buHSHWde1hFs9W0qyAO6drpB5dzsRXbbNG0kuwjzV5av1z8fafpUHx3v/hP4MtWnuUsYL4WUOXMKy7hg46DKk89Aw7deDNMkq4SEasNYy2779O6vdX7/M8LBZnRxNSdJP3oWv5Nq9n2dmnbs0+qvzep6NpWrx/Z9T0+K4X+7IoOf8/5zXnP/BTv9o/Sv+Cfn7CE/g3wHClr8R/i9K+h+F7OyZYZ4VkQLPcZHKiGJ8Bhyss8f1r3PVvi9+x38GfjOfgL49+Ikb+PtM8If8JXJo0pINxZiYwqIwcJJKZFO2EEyEANjbXy3+1rL4P+NvxU8TeLovh/p/xK8YWcLWKaxaalsj8C2KSqgsrBZRslvWLTTNMNr5LHBWNIz9jwPwvXeZRxOKj7kbPy3W7eltr3fkrtpP4rjrinD4PKp0MPNe1kmlrqnZ9FeV9Hay03bSTa/L25+A91qnwtWPxrJrJ1y2llv9an1e5aCz8O2ysyPLLFsZmnfypPmkYuQgwpdto9y/4I8fsf/soW37NHjz/grp/wUr+FOmeKfAV1cSeHfhP4Q13Rk1NLu2M/2e4v4ba5z5888+6KLOGjSCdxgNuHeftefB2//aX+PvgP/gm9+yzf2djD4z060X4i6zplkhe1tVhjkuZZ2ZN0skcSSSbncn/SII8K0h3e8ftG6V4B+NX7R/gn9gL4FaMln8Jf2dtPgsp7O2YG3n1WOBYljPZzbQ5jLHnzZrgNyOf0HxD4hf1KlRguWMlztdX0je/TS9tttXY+B8LOHZQxWIxVZqTjJwi1blXWdretr776K58+ftH/APBEb4Hfs+fBrxX+1l+wf4hk8T/BDxJpjavdeA3nuS1mMiUh5lIna0ieJMo37+MqFkYBGlT8rfFngB/Hd1qus/D/AOGa+GfDk7LcyxeHtImNlJFG7RRu0mHkkxIXTzZSw8wsu7JZq/pj+FPg/wCKHwd8QrrfwE8Nz6ppd0QuveE87LW9G0LvVmG2GUAD5+hACtkYx8sf8Fp/+CZ/wY8OeCLH9orwze6B4X8IaTbXN3r/AMLVjtLG5upXRWkk06RJY0aYbUVo2Mixp5jw7SdreFw1xHhszw1PC4qnrG6i7b6aRv5+TW+r01+4zThqeHx8sRh56Tacova9931t5Wdui1Py9/Yb/b2/bp/Y6Fzc/s9/HzWfD/gXSYWddH8Qp/aOn3s+I5EsorWTKLK6OHklRYyqA4bcNtfpV8FP+DlL4e6npel2v/BQH9nex0201RU8vxf4InE8MCu7Ro0lrLIZ4cspxskd2GSqEYJ/MqLwi6+DrjRoZ4bfRbV5547S8uQDoVh5kBkeLKmOKAmVlkZJBLK0Zkb5F+b5/wBe0HW/ij4ps/APwzaXTrLUdY+y6Rc3148TzSTs/lKJJCsIuSCUD/L5Mb4273K162eYPASpONWnGU32su34Jd/+G/WuG+F6Sy6NN025NaXlaV9Nd7KNk7fZ136x/qb8Jp8I/jp8Mbb44fsrfEvTfGnhS6LhLnSLgStC6HDxsAAyyIcq8TBZEOQy5zWIGGzJOMD16e35f5A6/wA9P7DX7cH7RH/BIj4lv4u+EusXF01zJAniHwDqck8WlXtrvZtjoeY3CbmS5ALhixO4Fg39BH7Of7TX7PH/AAUb+AUf7Vv7J3iCG6jVjD4x8MGRTd6PfKoaWGVFziQZ3ZGVlUh0znn8czXJKdO9TDLRbr/I3znKMXkFeNOu01Lre7T/AJZW0vpe66WvZ3R3Xw4svCOkQ6z8UfGlqJtP8JaRJqUqmIMU8tHkLAHuFRiPfHTHP83v/BRv9tP47ftxftTTeKbi5k1nxz4vuRp/gnwxHITb+HtOLN5UcOSAqIAXaQhTJIzytxhV/pR+Adnp/ii41vwVqkCy6brOgyR3cRI/eIx8sjjjBWRv/r81/PR+z1+z14W/ZJ8CeJvi3+0dp99qHiDWbq6tdYvYrlYJ7t42YDSbYlSY4gBH9olj5wwjDL8of1+HMPCvlraVurb2W/56WPsPDvDUsTi8TCFK9b3Equn7um783Im0nVn9lv4Um7pJp/XH/BOr/giZ+0l8FPhx4Z8Z+FL2+srXx1pukandalousma11G4dWnF5fQANmKFJWMSEMdzArguxT9Af2j/AHh79i39gC+8I6Z4c1LxDqMto8Fk9vpMktzJfu5lmv5EjDnzHcDqSFURx5KhieG8WfHz9sF/+Ccn7NvxD+Bfjv/hAfEPiSS0tdXtZNCs7lJLU2Vw8cDRzROiDEKHKYPocVnWfx0/4LLaSottO8deB9fdwDG174M+cjrn/AEeSMHP0/qa9P/WHD5fVjSaSUWpddbfDd/8ADX6n5b4hUc14vxtahWmqcKSnRpQjFKFKN1GTS0cpy5U3KbbT1io6p/nJ4d/Yv/4KFf8ABXf4m3fi/wCJt8PB/hHwxYG0/t7xj51npOk21tECYYFIOTt/eOVAHzM7MMjP0X4V+DHwq/YL+Ges6V4M/a08C6r8KbXVLWRJ/Bfii1bWfHOoCPYLSbyGke3hMjTFmV18uPIDtya/QP8AZB+KH/BUL4hfEiOx/al+GPw60rwTHaTNf6jpmjX1reTPsIijjWe7kU5cgsxTbtBHBIqT4x/sFeDvj9puv+Hte+D2haKLvx1Fq+izw+UscAt47Zf7QVYUBiupPLClsliIkyQCwr16HGOJhVjU5LxlporWSd9O2qSVtr3tpdfldbw3w8sBOMa15wV/efxN+7a3VWbbWt7WbSbv+Z/jr4+ftBftQfF5/wBhz9nn4Fw23i7xXpy2l6WEunyaDoqFHWC9RslIRCYlkR2MoWFAGfzP3n3j+xh+yN8Fv+CYfhPw7+zf4M1Z/F3xG+KvjFIfGniyBEEkMkVpLdS8RlZIYEhinEUbMzB7h3O4FlruP2eP2Wv2Qv8AgnrHeeGfgV4Xf/hI7qDOu+KtYtVlmtodpZri7vTEBFCv3iHZVO5iAzZrjviB8V/CP7FX7PHjj9ui2sB4o8c+K7yHw/4Hm1Qkrdzs5RILZCd9vZ+cLi4ePIklW2aSRt5VY7zHiv6/F0lZU43dl1dkrt9baO3c6sg4JWT0/bTfNWlZcz1tG7bSVt3qr/5GL4t+KOofFH9vL4nQaZN5uk+GnstEtmXkPLDAjT/983Esif8AAO/QdNrOiaLrtqbPVbBLiGUgSq6hg2ePfP4ZyfU5A8o/Yu+F/ijwb8NZvEfxE1Z7vxJ4lvpdU1y/nX57i6ncySyP0yWZ2bt1xwOD7GNsCGOdsKud5JztGOh/A+2PQDg/gOaVlWzCpVi92fs+Dg4YaMGeX+Hv2WPEfhn4iQaj+zF8V9a8Aaxq14iSvpF1/o0zMcB54GzDOo54dW6YGT09b/aP/aQ8Gav4pb9g/U/g5ofxx8U6P4Rk1fx4vju1tLLSfs0UMRlaQyQPAsrC4hcoq4jjmB+Y/LUem6xeeGry38QWLD7RZ3CzwouQQV5APB47HjoTnAG053xZ+Gvwk+Mv7Q+rfHv9nz9rHwJ4Y8ceKfh3L4U8QeDvF+nxXY1GF2BLTWzXMUiOFCR5VGBCDO9cqftODcVSqKpTxE9VblTbt/W/4X88p0MB9bUsR7seV2dnbmurX5Vfa9vO19Ln49/tSfC2X9ojwf4j8d/sj/sdWfw68E6Toeq+KNWt4/G0F1Z3dpFN9nutQ0oalFa3PlI9qUMVtlQxRRFEXw/wb4g+Aeq/Ff4m23hTwHr91/wjC2Nrqut3WoaZPZsfNiS4KhHUeYSjB1deGidHHBAr96PiT8Lf+CYXwR/Ztj/Yi/b+/b51D4mJpjqIPDHhKwVZvD91MG88wf2ZFJcRRHzNxhuJWT5Vco0m01tftkfCb9ib9u3/AIJ1eIv2i/gr4I8Q/D9fgvox0PwD4hv/AA59nbXLa0tYUt9PjgMgknt5HkjtYi+x0mzgY3q/3H1nAVseoy+Dsnd28+uuz7dD7vD8VcPY7NaGBxUZLB81m4qcpNXvFSk5c8uZv37JaXUb6SPxI1izt/AFzpXwT+EGjy6h4i1y5W307TtLgHmyFn8tZxkA42AFQwBwBwFXj9sP+DaD9g+8/Y8+D3jv4jeJvEN3e3XxEFjda/d6nbA29+sAuDHdQXGdrRq011C8TDeGXexCugr4l/4JZ/sf/s/WMth4r+LnjZb34m/EHUv7CmNw7QM97OSY9CtiFdkjZAgurxVKqsoiQMvm+Z+mH/BTjX4vgz+yBoX7Fnw9+ItlY+L/AIjatDZ6xZWMMUN/c6Iwk+2TvFExCeYscdvLKBtlaWXAy5xvm+Jhh8PKdSPL2j/LFfq7W/pnpeKHE0syo08DKkoNWjThytKnC6eienO7LnkttIw0u34Z8O5/iX+13+2Zc/tqfGPxJZa3ZeDfEpHw00qwLrp9laWtzuhlhR3fDziFJXkGSxPZVQL6H/wUN/bD1L9q7wn/AMMd/DL4EeI9PsvEesWdx418Q6wIUha2t5I5hFCI5GaTe8MOXbZhEI2kNkdH8E/hjo/wj+HGneE9GJeG2gWM45G7A7dDzjjoTjJLAAdTBpelPei+a0jLOx3TKnDNz0xnB6fU+rDj8SfEmPjVq8rup/h6fqfmyyvDuEH1j+JzPwm+FHgn4T+F7TR/CGjRWirCokWNBhSQOeg6jP1H90Hceq89Lcnz9o+X5RvwOgAx3z+p5+6PvTlbeb906HuxVlJ3c8kfiffJ9TyI3t5ZYBEoYMCNoR+cg4GSc9SMd+fUjcPnqjqznzbs9KHIo22Iw9tkwCH5SPl4wAfXBwM4I54GP7oHLLhZfmjmXsThHI284x2ycdc4HbhTg2bcwIBHBswFACouD7EAZ7jAHXIwMnLCS6aOWVECYDDcYyMkAHOeDz1/njnLCXTTje6GptSsVSlrJGZBKodSPMCyYwOMjBPBPAIPYgcDC057eOJo5JoipziXdzzx/gBk9sDjhS5TaJcLaeWgMmMfNz35469TwOmTju1CFbSOSGWTAjI2sFOAMcEbR9Tjg45H96rUFOP9fMV2mRShY38oRKVlciTdkk8HufbqO3TuENTyAzsY7ZEVQUUM3Uf3f9kn5cg598nCVckaRLVJ4/vA7VAUBioGQQOucAHtwcjHLVDI0aGN7VxGSG2Bs5IwSCOnbntgZOQMmuWrBWszaErPQpZuLi1j+37RNHGGPmfKCeDtOffGVb1GcnChl7NvCz3DOpXOVJwxX+782N3zLjng8Ahj8osusC3EcyszEQbYio3BVPIPGM8Hr1x3VT81CK8/cyRRbWCqGifduUJ2OBjOVB6kcZzsXk8tZRTs+/8AX9fkdFO7V0WFgFo8sLoGSVgoYqvc9AD15GccnnJ3McBtnbrtk3RqxACuIjkoDglQGPPXJ75672AAJ/ssyLc21xH8ihSCpZkHY9Qfuj/Z6g5VRgzLc2exbh5gjyofnChkVT/vbc8Y5449FIBzUabldajblYpyF3VJLu0ZyDiUyEn+MYXBLZwSeG7r0ZgACllSPe8Dzb0DExtIOo6e2flz1IJxzsUYYrKblCVotfezWKUldo9BSR0XaxGOgAPSlEwY/MvzAc/MKIgbfc5bPHQf/qpqyI/JIxkjA7fnX6BzOKSb+R8jZO+gpEjNgNxnPIpUikQkkA8dBSsuBhzgcY46UiRoSGzu47DHf/61Uo+8JvQN42gbMAdhQwfglcccZPT9KfG6mMlm7cDFG8M4JBHpxTsmtxa32GkgAiM8552mjcm4gtkjoMc08hHkyjjIPOBTJNgOflHOMsBVSTQk7itGWYEZ4HU8ipEKkELtHHpTAdy4YBM8BuMGlCqoLeYPX8KuFk72E9UKX28FS2R1P+f8808LkEgAZ9KjDGJQGTIxgrjOP8/406OUEHaO/cVtCUb2kRJO2hzHxX+DHgf4yaE3hvxxpEV1bn+GRQf6Vl/DL9mr4P8AwmslsPCXg2zhCnh/IGfzxXesEZwQ5GOwAwf0/lQCGXhgPrW/tGk4pkcq3CCCGFQIkVVA4wMf56V0mpfDj4WftY/Cxfgj8R4IJrnSDPJHYSiNWvYJIJoQBJt86NMyje1u8cmY0BfY7K/Nbscsfl9TXPfEPwBYeP8ATFtpr+6sbuBjJZajYXDwz20g4DpIhDIw9QRXXgMc8FiFNf15nPisLDFUXTmrp99vQwv2Y/8AgiJ8BPhH4p0P4u/E/wC3+KdX8MwRjwt4Y1C5Emm6CUVPltlyA7Myb2kkBLuxdhuwR2n7Xf7Mn7SPx/8AHGk6vpKWMWmxzzL9knWC5gtIRCNstxBK+27kDkmO2w1v5qCSUnCgeCeLPgh+3beOdP8ADP7e/wAQLbTxwi/2vmVQD3lK+YT7ls+tY9l+zB+25psguY/+ChnxUeZTnE3jC5kXJH912Kn8q+jln1HSUpvTueRRyalQpSpU6aSe9j3qT4XzeGvhVDovxC+L8kXjG90tpY/+E40lNQuldncm5e23hSkTlI4Vd1haVWkfzXZMfHfxU+DP7a/7RngO30T9nD4U6t4gnl1e+mh+Ml1bi2tW0+KdJ11K1lS9Vry7leFNpW2dHJYRbIyS/wBR/HT4O/GD9vX9h7xN+ydrXxTl0L4w2GhN/YXjC0dbUa/EhBMM7IuUjmwsU4QYBZZArLmKu0/YZ1f4i/sq/s/fs9fs+fEnwt4c0RNS8GNY+I9Nk1IWl1pOsQwCaWC2gd5Gu0WRpY5GViAsZnLBD830mFzypOip0ne/pp3S0PPpZF/tDSWkVtrd9fTo9dz82/2v/wBlH9o/wtZ+H/2ff2b/ANn/AMXr4p1+0Mni7x/L4VudOgW4Cy3dzdXk8ESW0qIZWWJY1zG0bCNJHWBpfK739mjSvAHwh1P4ifG74xQ6TrtzPM3iO9tvCBGntFE0cNtbBUtYfLkLOxSCMMhjWOVgFVJB+tv7RZ/4Ka+DNUT4n/sv/tF+GfGngXU1F5Y2+seE7SWS0hcblHm2nl/aICCCsq4OPvZ+83l8P7dX/BWLRg8Xib4J/CfXrcnmO107ULVmXP3ctdyL0yPu9x1xzFXimnQqclZWl5/8M7n3mSZ1PK6qqwoc3KrJX0S66OMtW9W2j8YfjL8Q/G37Jc2s6VZfB3wb4w0rxTDd2Hg3VL2yN5CrfJE11aS28qCQxPIgWR96eaWG3c0gH6Vf8Ej/APgq1o37PP7MN58Df+Covju/F/4TgGveEtT1W1mubk2roJV04kbpJHRi3kNJgNFIsZICLu+v/gD4I8Ift3Wtz4g/bF/4JoeB9Cj8KrjQfEAeK+luZGfzJYrdRaxzRplQzAOyuxAwxzj8kfG3w/8AB3iH9or4k/FDxJ8K/in4U1X4e+OdQv4bjxAgvbazgS5hbTRfRSwPIW3GTzpml2rG0LL5hBEnXh6uFziE5TTlOVuXt6+fnp6eX6Fl+Y5Xx1DEUMwpz9tdclmlyttWd0tdFaXutWsopNppNd8Yan/wWf8A219U/as/a016DQvBXhQB/h38OL66cwW+nQBpXvbsghVtYsbppDtNxLIIU2oGeHqPgT+yx48/4K2/tRz/AAn+DN5qMXwW8Iamv/Ca+NLpGtxqOGDFYwMqJpdvlxxquIoVjO0KgUcF8N/hh8Rv+CjHxVi/Z4+BXg9P+ETtPEZHjTx54Y0eZFFizKlva28cxBitYooj5MbgOcs8mSgx+unxp+Nf7On/AARb/Ze0D4C/AD4c2F9451q28rwl4KsJGze3IUI+oXjffECt9+Q4eVvlHJZkWKr0MBRdOm7prVvq128l/XUWecQ4fhfDfU8vd6jjy7Ky6N6JPbSN7O2+jaO5+NP7LXg/XPDPwx/Yl+GI0/wz4T8O3g8R+Jk02FIlt9NtAyxwJGoCo091OGVm422sx+YqQfm39ur/AIKN6RdeBLr9nT9inVjb6EFltNY8d2E+7znSBZHjhfvGEkjaWUNvIyirjJPX/wDBPHTPjBq7/EXxf+278TmvvEXxk0W30251CZUgh0+KKO5SG0gQYSCMLdylVGMvySzuWPA+Bv8Agln8Lv2NJovi5+3t+1v4WtfCmj3ElxbW0Ze0e/mRkWE7ncMzeXHEfJijdzJjaxEcePFy+rl+JcsRJ3a0/r+up8/wNX4Wy3EVsyz2fNUpNSp02nJTk7u9rWk00klJqKbu79OS/Zc/aCtPhH4p0z4X/s4fBmK18Ratp9xe6x8RNfs7aS/ieaVC0cFlEFitA5WOHywZHBe33eaI0V/Of23v+CZn/BXv/gq/8Qn8Fat8ULzwD8GrBQ97r/xF1ySKbVzlZJHTSrcDYiuisqypbr8q8/Lk+56r/wAFZvA9hqd54a/4JhfsXya1qV8zpL8Q/GFg1jaysckOkI/0m4jBIwjtbhQAqqFAA4rWv2U/22v203Gs/tv/ALS2t6lpcx3nwhpkv2HSo16hTawBY5MdA0gd/VjXFi8dgqc73vbWwcScaRztVFgsN7J1FadST5qkk78yTd3GL25YtRUbpRV2fml/wW3/AOCH/wAC/wDgk3+zb8LfH/gb9oLXfiD4i8d65cwXmpzW1ta6Y9rFbJKsltDH5jjc0ikMZ3BXoOc19Hf8Ev8A/gmh/wAEe9c/4I2eD/23/wBvv4GeINb1fXvGOpadPrXh/W9VW44vpraCIW9rcJHsC25O7ZnLHJPbX/4O+NA0n4X/ALM/7Ifwc0AbLDR9I1m1s4s9IrSy0eCP8lbFey/8EudL0/Uf+DdX4F2mo2yyxT/FS+LRvyGxrWpj+ldVSq44d1F2ufmUYJ1OU7v9nH9qL/gj7/wTz0C/1T9gb9jbxtc+K7zTks7aH+wZoZbsqoCie7u3JRWIBeQCR+SQrZxX0B/wTl0b9oTxx8OPiv8AtBfEDV7WD4u+P7gy2jXG77Lo8HlFLaOKMq5McOAAhB3+SgY5ZmrS0r4aeAbOCC5tfC1griNSGEAznH+f89eo8NeI5vh/4k0/xlpsLmOxcrd20QIEtsww64GMkD5gP7yr9K8H+3KlfEQ9rsvnZf8AAOuOVUKFGcaK5ea7dtG292/N9/Q+Sv2u/gJ+yB+x94s0LTv2n0+KGv8AxF+MM1tNrXx5GtaTbvBc20od4la/uIYbGJQkRdFCqkIRVY4Za+a/j78c/iF4S1TU/wBn/wCB3wd8SeFLbSdWOn+Bvh6bWeXVvEF2EgZtSuEWEBvMFyjtIcl/lWJ3VXB+wfi9/wAEKNH/AGjf+CuVj/wUi+KX7TfiPVPB+kXGg694I8JyxLqUaXVvK0k1gWuhIsNi0ghmRI1J/wBIuAph8tHP3hoPwY+GHgDU9T+JOtaVpr39yrXWsa3qcUX7gKoLsrso8qPCAnkL8u485NfeYPiXH4OSjB8yX4X62/pWv3Z+fZnwLlmY6/Dd6vq0uje71beurdr7I/Ov4R/DzxT/AMElf2QdT/aq+N/iiXxT+038YbSPSPD9tqsau+nzy/P5IXLGRIvluLiT5RI0MKEKxUt9Z/sY/sUeBv2V/gjol7YeFbnxz4v15Yb/AMTa5f3kY8+5uB5085MrYKhmbHDOzMM4DEr8h+H/ABFrX/BR/wDbE1P9qzxNG6+B/DDSaT8NNOmUhRYpIS12VPAluGHmMcZCiJDnyxXrHx0+HX7TXjHT00D4R/tR+LvB+nBNpttG1Rodq5/gcfPH/wABI/pXyeYZ/DE5k54r3/XXbRfctD7XL8mp5fl0aGF9xLtvrq36t6s+o/Hei/tYeN/hLqEXgzVNJ8F69dWdzFpunWvlytZ7vliL3DLIm8LknZHtVyPvhSH+HviJ/wAEfP2lv2jPjbpvjf4+3zxxz3RbV/FOifEdpNXs4UhX7PBbyXFg2FSSKFsqELEMXEjMJV523/4Jr+LdcmXUviN+1D8RNcuz1utS8Z3075JyTueUnknP1rRj/wCCahtm32H7QPjuF1YMjx+Lr1SCOh4kznj9K7MNxdHCXVGKV/LVX/H0vc6IZbUhZyd/X8/J+ljx79pP/gh3+2/421iH4bfDD4XaVJ4PNzLc6jrmp+L7MX1/cs48t5I1VEEcaIuFCkK+3ajJbxq3zp8Xv+CO/wC1x4R0PTdKH/BOnWdE1i1u2V9Q8N662r6fPEwULMY4pJvLuTKzBpC6R7SCY8+ZKPvmD9iX49aFGqeE/wBuP4uafHHL5git/iNqapuHcr521voQR9a7b4caj/wUR/Z2vF1HTP2g5viLpEYzc+H/ABzGtyZkzzsulAnR8ZAJdlzyUbpW8eLqdWd6sU/VP/Pp/Wx9nlXFGZ5TV9o6MKlr2vzfLaSTt0TTV9Xd2Z/Pb8bdJ8Q+BfiLqX7NOreArC+8Uajb/Y7xRLcxT+GbiKdkfJVghKeXhwyuMMygLIBs/WH/AINU/hP4X+B3xV+Ifhvwy9y1nL4GS58QXFxdM4NwLxFQOAqqSEEpBA4U44JbPt/xJ/ZM/wCCVH7SvjPUviHaC3/Zq+LWr21zDqtxeWFtFp95JcRmOV8ShbaXeC3MUkErklnUk8874S0z9l7/AIJV/s5ePPgR8B/2kNO+L3xr+M5/s43vhUReXo1p5TwpI6wzTC1SJZppBukLzTSLhQikp2LGZcsBOqmpTl5aRXl5/wDDWPqcx4r4bx3DeKlVjKeOrWhFNfw48ycrPltZ2u2nzNtK0Upc/wBX/wDBO/4mXfirQPDPiTVJTnUrJoGck87k3L19SqD8RXyjo3/BI/4p/HT/AIKJePfi/wDtM6JZaR8IvAXiu4m8KeErdN0Ov27yNPCViR8RIxZWfdgtIzjG0kr9E/s9+Eb74b/B/Q9Ds5fs93Y2kLxyY5idcFT9QQD/AJzXa/t8eH/jN+1B+yXaX/wd+IkPhfToGupfiHDBYGe+ntUtZUltLc7wsYdiEd258mQuDxsf5jh7FqTnh093fyf9fqfLZBmuY5TjvZ4aqqSrpQlNq7ir3urddWl566PU+cda/wCC6a+Kf2oJP2Zvgf8AspaH8RfBfh62b+1PEd7rQ0+2tHgJV5oiYJ4vIT7inPzBSwfaRVv4u/8ABb34n6ZaSaP8AvhT4MF+17bi0gur57iKeFpHSRUaNo3EoMch/eQoiohck7kVvhb4c6PpHg23n+DvgvTXtbtZXM99YO0t3qkjz2qQ28qoqF4hFKSkR3hmMZIJ2hvoTS/+CX/7Tl9Nod6fhVrGlst6l/cXsNlsuLGDzi5jICHdcGRfMOzIBCrwgidPpquClCneTXO/60P3elwX4dZHVjVzKEU3blU5NKVkm5NczT5tHol8TWl4xXb+Cv2i/wBsf/gof4y0T9mD4peObnRdLvdXb/hMYtAsJLBry1V5WlsspnMPkFWYSEEojBjvKrL+i/jP4r+AvCrSeDtF8XWemXaabJeSRCePzksYsRmSK35kkAZo41ES/edRxkV+Dv8AwUg8V/8ABbfwz8XNI0r9iH9mH43+D/Dfh/S0aW78A+AdUEcs0gYvbOyWwWeJFKKVC+TkAAMI1Y+hf8Gw/wAPvih4j/aV+LvxH/bE8HeID8WtMjsJob7x9fXC6/d2czXDyW32O8IfyBcxwTCUqF81F+bKKtfH5thsXSoSqwlvZdebVpKzurJXbk17zjorPU/HuNM7yfM86hgcBShTw9HmsoW5HN6zeiSb0jBPWKtdOUT9bfBfwDk8ZWv/AAnPxrF3FpYTZZ+FdT2hrlx8o1LUljAE96wRTHGPktww2qZR5g8G/wCClvhuXxp+0j8Fv2fbOEx+HPDGi3WtyWoT5ZJ8pa25OB1jSOcAD/nsevFfWTQa1qsksdzFJcusexbCBpJYzMqtvMzORkqFRU5j3FtxPzZX54/bIayl/bp8KbbmM3S/D0ebalhviU3k+0nGcA/OPT5Dz68MZulk9XkjZJJXe7d9W+3TT9LHxc48+OhzPdt2Wy7evr+o+3tGsbOO2iULHHsUDOAOQOOuD06Z5PBJ5DgEJ88Rffx8+eVz0POcfyGOMnLVMVdQQrZRsDBHBwOnYYA6/rx8tIsCMrRlCCf4/wC9wPy9OfQZx92vh3Fvb+v6/roe6pJEEcUM0iSKQCcbG6Hv09OSQB9SMnLVzmp/8E/Ph/8AtWi7n8ReGbDyLU4k1K8T5cnnCkDJOOT2GeuSCenktjcgLJzIGOQf4vXg+nPU/wAIz0C1p/tTfGLSv2dv+Cfd347maApqWqxWlzqV5JdR2enyzXHlx3F1JaxyTRQK6xhmVGY7goGWFevw/l0cwzJU6jaild2duy/BsxxFSXLGEN5tLa+/l1OP+G//AARd+Efw7uFuNDtNCk+fPm+W+UBPOMLyR25/I/NXkv8AwWB/aw8B/Af4Z6D+xT8GtTvtJs1uHtb+70a2t7lZbzymaKxEZcOkxmlin84hUjYKykvHtXlv2OPgb8RviNoviL9vXwf4o0L4kW1lqWowN4U+GMHiC0OpTXkZF/a2Fzq13uSP97DIVNsI3kWRfl2B6f8ACb/giV8avi/+0Hpfx+/ab8Lad4R0a01mPWtM0WLx/earqGmwJFGLfT55HAHmQuhkkmWWTe2xVKorbv1HKsBl2U4qVeneUunM7/PVv7lvZHsZVDLcrxjxWOqp+yvyxcUv3ltLx5m3y3T+Fq+l73PVPjbqCf8ABLv9n74deJP2Uf2ZvBvjf4ieNbaLSX8dSoq2Vh5VorAoIwJpIn+crHG8Ycq8kj7j83jP7Of7L3xI1v4m6r+0/wDtP+KJ/EXjvxHP9p1DUplAEIH3IokAAijUDCou0KoGMDLn9MPiHF8R77VdB0W3+Dfh3xj4bmvJDrF3qWrqk2n26qvkzQxyQuLqVsNkZjwWXDnk14n+0VpXgnwN8ZrbwJ4du0imuNHj1I6duLtCjTPHnudpMRweuQ2M8Y+R41Wa1qDrKpeH2l110+7017Hz2CxLxWN9vipc9Sd2m2nt0aveL7JpK1raWOTghmSIqsvmgMqrtbLIAOOB97jHpkHHyryQxSGzFxMSpiPzYOcDb0GMZ4PsccfKvWytvEsgkYEh5N2FOQMY+Y9fQY9+m48hmI/MEMoEYLNtUjJ69eMnliOR3Hc/MPzB03ynu865gWBykZu3UBRl2BwRhR34wMEknj6qOC6VFhOCqrGUxJzk4wBk8dgOpxgYBGMKZYGIRZHjGCg2FiMgevU++Menc5anBHkRLiKRUYD5UDn5fqQOvX19RySw1SXJZGd3zEHlRxxyRsjiN1IIbtx7ngdPoMZwMLTb1ZBzIiLjIYjJwe4z2PPX8+y1I8KOchmB2/eZvmUY4wQDz/Tkf3qklQQz4WQooADFQMgdR9MnOMfXj7xHT5oW7jUrSuRRxq/7+VSP3377zBk5zn36evrgkE4WnSx7Jg6lly+WK9GJxzz15HXpzlsnAD1QWofErBiVIJxgdOF9DjP5kjAySzY3l/JF8uVBG7BHHReOoHTnB6jauSRxaja+or6kDskamCdWf5sncCcDcePzC5PJz1ycKKchNwhiOXKNwA/BO7jOORzt6jqBncwAF24jD28bySOSrYyoCkr0x0OCflHGM5PRTk0bjT54JEZZVSEHYrADkdAM8DP3ew9to5PLX5rXtfp/Xl/XmdFJxv2I2hzb/aZ3M67CGWSTh2z0G3cT8x685PJ3HgMmSOJln+zhmI4jJ6luDyvoRjocnjluk6ss6eV/C0JzGQUGzGNoB2g8EZBwMf3V6smtzJaEuwV0jz5ajOAVHAwAMbeCBgY7qOvNKMei/r+v6ZsmytHbAzyR3UzMXUeWgABJzw2F4znjkNk4GC2SHCytdjvayqzCRSvBD794wWUH5hu3cjqQerZYLfRWWzz5Jt7DKSELkFjgYPpkDDZx8oAO0fKXeW1nMyvBmNxh1CL83QdWIGeRndgEHB28I2XL72qL5tNGRSNHayJFNMJlDBXREGN3HLdSp57Z+YcbjkgpLm3lMEkfmLHG0hDJOu0KemM5A5XAxwOQDtHyUUTVTmtEI8jXvM9GU+XGWCs3X3qL7XFG37xY1JzgZ5NXI0VIyQMg9gKiIkUkhQQeoxX6NVozio2dvlc+PhOLvdEchiR+Xzu47+lOXG7GefakJjdwzMozjtn8KULtbzGYsw4HNZpPmv0KdrBGSoATGe+4cUpZnAJIH1pA+7kMCcdcUrSCRdzMoyMdM+lUn7u4ragUy/3x17ikDNyN2DnGcU9UX77MGIJxgYpWkYMf0x3rRx6vQXNcZgkBn4I6c/8A1qA+B85AwOAc04lnjwzDOOCfWmlJADk8Y6kf/XpNO90Ca6kfnlc+Z3HcDilWTfk7gMdzkZpDC5GSpyOmO/NC5A5OMcYIxiudOonqae7bQd5j8OXwPfrXzR+1/wD8FDvCfwKum8HeCtRtLnV0uDDe3Uq+bHavtzsVQfnfoO4B7Eg49s+NOo+I7D4f3h8NXqW1xIoQ3DnBjU9SuOScZ6YPodxFfnz8d/2NfGPje/ufG2obYxZtvguoJQ0MKZ+bzFLcNu6sDtHTIwXHTCcINc71e36/195+weFfB+QZxivrudTXslpGDduZ933Wui6vfTR73hr/AIKI/tP+JPiF4c1PULvSJ9Fkvxp91oBP2E3JnnjjEstwpzE0ZYY2/KqlmIkK4r9EbOKaG0ihurgSTJEqyTFNu9gBlsDpk84r8j/2a/gr4w+OHxit/h14ftfM06O6kW/vkBAtolxG9ydwHGxj5YGAWYAjoE/XKBRDbrCpyEUAMWyce5/rXTiJQsopLT+v6/4Ynxk4a4c4dzujHK1ySqRbnTW0VdKLt05tdNtL2V3dzOhxlz1wATSEkENzjjOBz/n/AD704KjEl88HGDQFXflDkg1y2bPx26RUvYtQtb608TeHrj7NqmmTiewnHUOOqtjqjLlWXuCR3qL40fsnW/7d3xt+Cv7Vum+O7zTx8LdR1B9W8EHUWhtG1GaKKMXEnloWnKRq8flMVEsNwMPHtIfSi3AlTj8BV34feNpvhT45TxOj50vUClvr0Q4AjyQlwB6xkkn1UsOuMe3lGNeGqqMn7r/B9zkxEJNc8N0eFf8ABTT/AIKrfFf9hL9qj4a/CXwN/wAI3c6DrSXepeJ7vxLZ3aWOn6PCrGXzLi0jkaJwREsbCJz+/i+RwG836G8O/Fj9m3xj+zJY/trfFXw7rfwx8N3Wjpq2paf4tjFnNbROFZfMiQucvuTaiYdi6rtDkoPFP2gf2BPhFc/tO6/+2P8AtiX3hiH4OeC7qDxNolpb3Mrtr199nSOM6rEUKyRWbiQW0URZZBcJ8gZZPP8AzV/4KG/8FSrT9u/46aP8P9U8Gy6V8L/Dd4t+PB2n6l5Gpavpcc0cfnzscrGzKcRqqFIjKxxKVZq+mxdTAzjy10m1r/wT1cmyapnVWCoKSjdRclZXb2iruzk29PVfP339oj9tf9uH/grv47tPhh/wTJ1KPwX4H8H35vFtf+Ejg0/WL0WhikXU7r5v9FtY5GhWKPdl3ck+ZscQeSfGi+8W/wDBSf456f8ACHwD4e+Kt6+o6A+o+INX1K5sZbRNVmuYbWe7g+xWqwy2CyxSRBoQpuJVUb0ALL418LfCniP/AIKH/tFnw1+xr8LdV8O2XiXU/s3i6z8LXyPbaBpwM9tb2kqpsWKInTpsGXe2xlmkDHCN+kWg+Kvhr/wQ8+CK/AL4aXkPxQ/aP8dWtq+oWInaS204RRlLZrg5EsVlAjFYoyRJNglRGpJj1oZnC8oUtFHfp8r/AKdrPqj7nEYvKuE8sUsO4yqv4Iq/Nd3U25Xei06L3tNWnyd/qfiH9mb/AIIT/suab8N/hT4JGt/FLxhbgaP4YF4ZbjUrsDDXV06/6u3jYje4A3t8kYAACeT/ALK37MfxE8e/EPUP2t/2tNefxD488QyLNPPcpiO0j/5Z28CdIoUB2qg4AHckkv8A2W/2OfGOteOL/wDak/an8RXHif4geIpxc3+oX/Pl/wB2ONekUSDCpGoCqoAAAFfU0dtHbx+VCAAgwq4wAP6V8rm+bVcRU5Kex+axjUxFWWIxDvOWpBrWhaNr2jyaDqVkklvLGUeIrwBXz7qX/BMn9nnXfHy+Otd0dr2VABGl1IXWJAeFXcThfYcDNfRwAAGGG7pn3p3GPk7HHtXlU61WHwu3oaShB7owfBXwv8B+ALGPT/C/hu2tY40AXZEAf0rotsSgYAzjt6VFFcTFwGt2UAcOxU5I+hqYlAuAO3pWkJxqJv8ANWJlFx0Pyi/4PSLxA/7MOkR/dg0TxNIBns39kKP/AECvcv8AgllF5v8Awbw/s+mOPdt+Keol8dv+J1q4/qPzrov+Dij/AIJU/tO/8FV/hb8FviH+xxpmka9q/gQanp+u6Hf6zDZSvHdiz/eJJOVjPlPavuVmDESqVDcitX9lr9nb4q/8E+/+CM3wm/ZT/apsLLRPHx+KFw9poNtqsN2wV9Surrh4XZHHkneSpIXzFBwxxX21ZqWAbT+z+h4cE1iFfufVNg4+xQ84Hlrhfw/z/nkSvho9igYPHH0/z/nkM007rKEuesak578f5/zxUxXJBHQjoP518Nyyse9dXOV8fftD/tc/A/wiuh/s/eFPC3iC3R2a0g8SQ3DNbBmzsDQypuTJOAeRnGcAY+cvila/8FOv26Lf/hBf2jfiXpPhfwPcyA6r4W8Dae9nBfoD/q55ZJJJ5UPeMyeW3UqcDH1rhs8Y65GR1pf90njoQMHrXbDMsXCl7Pm0Rg8NRc+axyvwj+Fvh/4Q+CLTwV4btUht7SFU+UYzge1dSQCTufge/wDnt/nuVOCOTwR1P+f8+9I8QJU/Nx7/AOf8+prhfNJt7m6stBCxDYU4wR1/z/n2pRzzkA5+n+eP846mFU8dR7f5/wA+tO3K8eDnntjP8qaXRg9BmTuyTnBPfj/OP8+riWwfMGM989f8/wCfSlDkAZyeT05//X/n60hbkEnHsOT9Pf8Az9adrLcV2zmvHvwk+H/xIsDY+L/DdvdqwI/eRAn/AD/n2rivAH7GvwG+GutnxH4V8EWkF0WysgiUYOf8/wCeK9ayD8xbpjoM/wCe/wCH4mm8JlSpOR0A/oP8/wA6Tc7WTsmNKN721IdvkhY0YbcY29uuP8/16Uui/EDxF8GvEL+KtI019U0i7QR+INEGCZ4+hkjDEDzVBI54YEqexVyliPnOeOi8/wCf8/WmEpIGUuRgfdPT/P8AT061nQrzw9RVIOz6FzgqkeWR5r4f/Yl/Y48QftFWn7UvwK+M3gDT9KgvYtR1jwhr+lRedZXsZOyYM8yPaGIM7LEYwGZiXZhsKcn+0X+1x+178e/2t/EOg/sG/tiW+m+AfD+m2to8ml6BpOo2lzqIDPcPFcT20rSKNyIdrld0bAV0Pxh/Y4+BXxuuReeM/BtvLMefMMIyf8/5wK3/AIPfAb4ffAzQ/wCwPAWhx2sGfm2qBn8u39PTv7uO4lr4nDJLSa6/1+vQ6MfjMzzidL+0KrqKnHlje1+Xom+ttru7tZXskear45/4LHWMkYj/AGttLuxHjcLnwNpQ83Hrst1xn2x7V12mft/ft5fCTS4j8YP2XfCPxGvoYniTV9F1V9HnaMkHDKYbhTkgZCBAcDjjNeksm4EszHDdSe/6e39cd4pkHlD90HKf89SB0xz6f57DivEWf5hBXbv+Jz/2dhpdD5z+K/7dH/BS/wDaRSH4efs+fCPTPgRpMkjPqurWd1HquoXGeCI5JLaOOAHnLLG0hOCHXBzsfszfsseK/hb4g1D4nfFD4nav4r8V6vtbUtc12+kurifHCgu7EgADCgHCjAA4yPckjiQb4FXhDuYp1+v+fr1AJPGjSg5ycjh+me/8v5A9lrhxmbYvF0uW9o9lovwOihhKNKd+vdjSxdUdZwOF3YHbqB0/LH1Hdqchk3Dy5GG5R82Py6Yyee3pxgc0TySCNux/hyMcnrk49cf19Kru0hQxzpvUc5K4BPHPA+mT0JHOfujx3NQlqztUXJCy/NKIlX5mOdxbhRg4xjH4d/oPmNmL45S/B/RtSsPF/ga68WeEtTjJ1HSbEobmBwP9ZCHZFYnaONy42qyldpLVnYORIVyNpJBbjJ7n0/i9ckc5OBUNxHPcBXuIwMkl48YxzyTzx9DkZx949NcLjK2AxCrU3qv6t8xVaMa9PkkeAfFr/goL8YPEPh3wn+yl/wAErvh3rvww0LQLP7NqniLxZodvNNbwIgWK3tUnkuA2BuLTS5YkLjjLnhNR/YN+NnxzvJ/Ef7U37UfjPxZPfweXe22o69MLVos58tYEdYUjyxOxVVevAzk/Vlvoul6bevLYafFHcyDAKoAM55JIGQc8d/xbpLE80RkiDbMoWUA8jOemOQcntnnONx6dmN4mx+KekuVdkZUcsoQfNP3pPW76nzp4J/YVvfgh5Nx+z78bvF3g6S1+ZY9C1+e2jzg/eiDCNxgnIYY+nAPYfAv9njxb4G8eaz8Tvib8V9Y8X+ItWK/adW1rUHmmkRQAqbmztVVwABhVU9FHB9XZ0l2zNOpMY+RlXJXk8c9+Txyc5xubkSPJJCftTKqksCA4LbvmJAyMYJOODkZ6Zb5h47zPHVaTpVKjcTtWEw8J80Y2Y8IVt2gaeRTG3GAOuPu/N0PTk/jgfLSXEZ8hFmIYoxyxPz/dIyc8DAIznjA56hSguZIZtkKsN5BG0ZwPbHqcevcjnLB8cjG8MCbVb8D1BxjH549yRnlhzcycbI05WmSxSIrK0bjZKGG4g/KcdOnHTvj36habnyJD50g5JwGI4OMngn6/XjI6LSKjyeXsQrKpwhKn7voMjuO3Xrj+9UbStNHG1xBkgL8wywXv8uACe+MfgRyxd7Qt1/ASV2EDOryRxSt8hJZpH5Y4xgbs9wM5J6jOeFE8zboWmmZdisfvDPfHfP5HOT1ycAVwrrK0qxklgA7lR26HI+8OD07EYwMsZJ2eKUgjfGyYfDjG3nA+mAeeO2MDJL5rR12/r8gtqOnbKqYyCXcDMrcH5gDzz+ucn1IwIxJClwVYsyFsgsc7vXnkH6c8j+I9FM0rIIxC+OC2GwcHrg4GcA47H6LyWSZKGaOXcyPyEYZXjkHHpn2wOBtAOZk1uvIaXRjfLV5FgJbcz7lYvx3GTnjr2OeemWyVrXtv5jpDZXZlOGbG4Bh83UEA/dYjt1Axkjcs8K3AkW5uHlV3JDKADnqOc8+/bA9AcGBlh86aF5FBdcgH5yCDgdwcY+mB1wMA8s3ZdjaO5C8qSbVjlcPtO35Sozt+8Bz68dTlTty2WpZZphIIY1UGSMlP3u3JPPAHOOSAQOCPlyTuDbyKKGzxNGR8rBmVlI3YAx0Ge3OOgGcABTQ1aVwIo3GzYS2XQkE4OVb0GCeTjA68bVPHKsqe71OmNNzLEUC/c848kKqjjGT13DjglsAZx2/v0RzCVgbOUtnCIFBG3njJx3x9eTt5zIKjWrRM98qxB2bbPIr5JwBuUk8EY5PcYBbjCUsTW8SSxS3DE53MrIBgkjjkewySO+W6qpxjOEV72n9I0cJS2JBEIryIxSlSCNgQkDBPHAByM4xwcHJXnc9FRs6SW5hns3DK26R5csHK9i3AbkLy3sW5wlFTOtCDs3+f6DVOUv6R6pGFRCIjnrkk0wSTE4I7+lMjMawlofmJHWlSV87ck46/LX6p7VWitvQ+I5dWPZI92XAH0FIY4y2QTx709wucZIpEQDJ9vWr5E5Wsib6ESlxg5Oe+aYXz8rJgnkMBmpjnGCD+NIw3DDEd8YrmlCTW5qpIbErFiWbHXqMCnldwPznFHbBPfp6U4IOSp+vatIR6IhvqNESKBkDI6H0pCxB559ATRtZWBB460pIcHI9/TNCV9NhjG+6Axzx1J96aULDMrrgdse1O2xomP0AoeNZl2quRkc+tZuN0UnZnmH7VU/xP0rwNp/iD4c+En12HT9Xin1/SrFSbyeyVW3G2XOHlDbDtIJYArxkmvOv+Fb/Efxhpl3ZW3h/VIoNRiE39l6pC0P2lnxjz5D8iBc/NGpbcF53HKt9KiNkI4OMdBSBfm+fP4isKmCw9XE08Q4+/C6Tu+vzsfU5FxfmGRUJUqcYzje65ls/lbTy3T1TR51+zr+z14c/Z+8JS6fZul3rGpyfaNd1UR7ftM3OFVR9yNckKvYcnkmvQtrj5fMC4HQE8VKYUcjqAeMU1omySFIyPzreUJNuTPEzDM8Zm+Oni8XNyqTd23/WiS0SWiSSWgiuW+XPGccZ/z/k08oikFT6dKCu4bfLHPb0pqrwGxznIx3rRJx0ep597i/MwPYnkZNMlgWdDDINysMEYqQlQdrqA2eMClUDO4n6ADmqUU2K9jG+K3wdi/a9/Zg8S/sWaz41Hh7XZ7B7j4ceKXto5jYXUat5R8uQFZPLJKlMZaF3C7Su4flv+yp/wSw/b++Nvxv06P4sfsa6p4C+LnwqEen3Hxp8RaxGvhbxNaRXlpB5MtlHbbtVhfTzepiKVQQI4y6KyiD9VvEfh8eINPFsl3Nb3ELiW0vLaQxywSqcq6MDlWB5BFeCfHz4Sf8FAvj0Jfh94j/bO8Qw+DrgeXc6dpNta6fNcQngxy3FrFHNIpHBVnIYEgg5Ne3Sjl9dKVeHvpW5lo3H+VtauPk7rrvZmP1vMKNP2VKo+S/Ny30Uv5ktlLzVn0vbQyfi7+098HP2NLzX/ANiT/gkt8LtBPxE1rUHPjzxxomjQxaboV2zHzNqIvlz3SlmxHzHCT85dgyVd/ZB/YT0X4RvcfEv4l6ndeIvGesTG61jXdXuGuLm5nblpHkcksxPcmu5/Zk/Y8+FX7MXhqHRfB+iQCZUAkn8sbifrXrW0NyvTHQdqVfFJwVKmrRWiX9f8P3MI025uc3dvqNEaooRVAC9Avb2pjKeMDnuDmplwB689BSOrbtijg9hXnTp8yujojKzsQtHkg5HXp+dIFYjKkjnqO/5U9wwAwOc85HHT/wCtSH5QAW4znmuZwUWap3CNWLhi27P6e1KF2kZ9PXimhWI4bJz0FKo4wuenc0R06AzgPi98JPFvjFJL/wCG/wAYfE/g7UZY9sl54a1uezaQYxhvKYBvbPTGevNeXeA/2IfEf/C2bX4w/HH41eJ/HesafB5Gm3fibWZrx7WLOdkXmMfLBPJC4BPPJ5r6RxnnZjHvmkA+Y78deOfpXT9YxCp8iloZ+zp83M1qJCB5KxqAAoAGOOP8/wCe9AOCCrHt3/z/AJ/OgHacgE7iSePf/P8Animh9zBeR9R1/wA/55rmcrWvuapX2HFkzgn8P8/5/qqyKvyr6f5/z/KjapJGMnvz/n/PvS8nGemOv41a5iXYRZM5+UY9T0/z/ninFg3ReMdT/n/PtSMASSp6AdKUlQdp4IHr/n/P51SulqJ2bEAUtn6Hgf5/z+VBwG/H1z/n/P0oVuNrHvxj/P8An9aQTKTtQZ56Dp/n/PvTvG2oWY6Tq2045OMdf8/5PpTdiltr7eM8Y/X+X+eKcX43Yzz2P+f8/nQpQjJHGeAB1oaUpCV0gBUoCBgemOv+f8+lMKuo5wRt59v8/wCc04NsBQY+g70pAVew79f8/wCfSk7MadhjEDjgccsDznP+f/1imHZko7YPb1H+T/knpI+Mde3Xp/n/AD0prMqqM8gdvX8+n+e1ZzVyosjPPyt6/p+uP89T0jlG2NWAPXuf0/P/ACTzUwGZAVQ7eec47c5/w/8A1UwvFntjPAJ9uf8AJ/wFctSN1v8A1obRZBM7LIhiX5icH5un0/z2PU8hGj6ADI/hOc46Yxj/AD9etSOUA2upzztLZ/Hr/X+XFMDRuq5JY8jk9PXr+H4/lXLKKu0bRbsiJN6r5Zj4ZeSP5fkf88mnK0bKwXkjAIA4PUgDGP8APoOadMUYbQD0OD078nP5cfn6U1WZVIcjJHzbk9znOfU/5J4GCXLLl6Gl7q5DeKvDPECAR8wUHB6DH+emcY6lsiSQyE+Zkl1AAYAZxjj8Mnt7Y+8ZWkBH2cMWyM7Tx8v/ANY8d+nc01GiCBEdhtIABB456+/b159T0xkk5t/1/wAE1i3y2IfLkDBUkYIxJ2KcE8HjPHAH5ew5I0hm/cFACpOMd+OR1HuCPT0HV9xe29qnntnOOSozgd+Bk+/+J6NluMvHuHDggDP+ffHX2yeayko2av6lq71sVbvckAMmwMFy5TAywxkZbGBjP4f3eAWyNmRTk7WGC+e/fk+g7HGPYYUzPKkRKTROqlfc4/uj8wTx3I6nkJEy+U0AjbdGq4yM/QADOeRxj3xzlq5pRTkbJ2RXlWdWZ4YV2sMlV4JI6kZx0BAwe2M4HykllUvJkrkY2gjlhkdQewBGc/8AAscKXpdQYDqcBgAcnPGTjHqOcce+OMtUFxPdQ6ssUcKi32g+Y0hUo4PyjaByOW5BByMgYy9c7air/wDB/r5/8E1V29iVJHeFtr5w4G0jndxkkEjdz/8AX7JTkVo3DKrbWfgAk7uDzg9e3vnqTgLWt8Nvh/rPjvV5bLT8RwIBJd38wPkwJngkgDJx90A84AGB89e5/DvwP4O8LzfZdAsBLJAN1xq15GGlI6YQdE7AYHrXsZVk+IzKMZ35Yvq+vovz2XmcWMxtPCNx3fb/ADZ5B4a+D/xI8VSCWy8KTxW7Dme9xEj56t82Ce3r0P8AujtPD37Kl26rJ4t8YQRk8vDZx+YWJAB3M+M/kenOelepahr64w8mFHQZrLuPFdrCSTJ+Ga+tpcP5Phre1bm13dl9yt+Z4s8xxtX4Eo+iv+ZiWP7MPw4tIBC2qahcYXA8y9UfjwnXOfxOTk1T1P8AZa8HusklhqerRbuQS0cyDnOdoCtkHnI578nmt5/GtoG4l68YBqaDxhEhBScr/wACxXZ9SyKUeX2UbeX9X/Ew9vmCd+dnlPiT9m3xfp0r3vhu9ttTjQgtFEvlzKARk7G5J+hJ9icEefXdje2N4+m6lZyRyRzcq6HMZB4B7g5z+I7tkj6qt/Flhd4j1JA2D8kqnDL+NUfiJ8KtD+I+jmZHVL9F3WmoRqAzYHCvjGR2/wDrZB8rG8L4avTc8C9V9m+n+d/m16HZh83q05KOIWnc+XAZgiGIqMSZJQ/Ioz9T1G7pk5zjJywIfLCssKcOhYgL83U4JK9RnHTOT0yeav69osuja1LY6gXhlSRkeNiCS65znIOMYPPTHJPRayZbq2lb7PkKEO+RHGNuCP733QeRz178YSvgKilSm76Nd+/9bn0kHzxVupRuWkMcdvFGFdIy0IVDllx1bbkn5uhGTn7u5huGbdxXBQttVyCNkijDZORu5yR/ERjJyTjJy41/tEcsDtLmQiJluUJyGYDDZ3cDvkkAEH5hnCVArIkOIg2HYkM5JDDGCM446d+ucHn5D5dWHNL5/wBd/wBf8+6nKyIShhthJBFEJPkY7CPlTJYdWwCfmxjpuJHGXqa3aSbbPY2nIC8MwAxySVwBg/K2AMA54IB31G5lW4cySGF2XIMhXK8kswzuAxycnjON24jZSE3xjeKWUh0ySzQj5jkFh8wOACOjcZxnJwoLqDs9f6X9f5BbmWg8O9qGtLaKCPDj94DjB/h+7gg+hHueMbyUNKPLWQoj75Cm9CFwxPPXjGR0wRnqCcAFS5RW7a9L/oNJvt+H6noERCxM1ucnHOeMmoll1Fdo8nccncxBAA7fWljuoYwUjPJyFP8A9ao5rq4jYAO7bmA4SvvJ1YKKak1btt+J8pGErtW+8uO8XXdyD0BojmRDtB+bAAB61UBDtv8AvMBySDT4i5lDKcHocrW8cS3NNIh0lbUsOWdcibHoc01A2NxB6dz1pA7ZAB+hxinqw27j1IzkitrqTuRqkOXOdxJzTiu5eCRmmNIxTcoOCfSlTB+/nP06VpGRDTFhQrxnt1PFDqTnao6UqsWAHQY45oPTcW568mtYpctkS73GIG3Zc9u596CBk5QnOOvNOUgKWcjjofYU0sFzxgfSosuVFX1F+bPC9ueaASAN578kigSsuN2Meu6nCVVbLLgZqk4X3Fr2HKhJwDj6Cgrn5jnHNIr8bgpAI6V+WnxQ+M3xW/ai/aA1Xxf8Vv2rPEvwn+Gei+NGsNPh0/T9RtrFtLttRtrK4uGuoNqyXDCdiqr5zBkkD+SgVmqpWjSSSV2/O3zbZ9hwbwXiuMMTWUaqpU6STlLllNty0jGMIJylKTT7Kyeu1/1M2A8sfwprkDIA78gV8veHf20LXR/2/bL9mGTxbq2sL49s9Q1qTSdWNo58JvIJL2wtIpbVQpik09UcxM0rRF4h5uS6Lxfwg8QL4M8X/tX/ALQcfhGbxJ4o8F/F66t/DSta3N5PFbjw9o7/AGSFIVdkRmmmPChFaRmYqu5htFQqc0YvWLt89P8AP/M8bPcgzHh2vShilpVgqkGtnBtpNXSe8Wk9mleLcWm/tQhW+VvXg00jBwgz0xXyP+yn+3f8SPjR8WdG+Fnj7VdKtJbzR7S9s4rL4c6uj61E9o0zzieeVI7Ffmgk2vHICJdiu4xIXax+3X8RvDH7Slz8HRqOhXsep/EK80KKxl8O6k03hqK30OHUYkmeCIpeSToUuMRtmJL1EbDROKn6vUdTltra/wDX9f5Hjc6Ubn11HMSMFaeh2NgL+FfKf7Xv7dvi/wCBXxysfgV4I8G6lquqr8Mr7xDq72OmJLBFJK0kFjLuLl1jjmtbgzfIQqSRMTtEjR7Hw8/bW8c+Lv2C/Gn7Sd74Ls9N8TeDvDd+1va6jdeZa6lqFvpsc8b/ACeXiOWd1Ty1bIOVDZrpp0a0YKTe9rGUpRbaPpUrvzk4wPrTSGQEnPTtXx9J8cfCn7UWk/FPwb8TPip8PtX/AOEJimsNG8O6VDEst1f/APCPWepm/t5RezNIIvt0tv8AIoAa3kPUcanwW+OXiP4bf8Enfgr4zhvNRvfEmufCPw1BZXiotzctcPo0dxPdETMBK0cMVxOdxO4xnIboaq01CHM9/wDM6svwlfMcbTwtFe9NpLt6vslu30R9WLuPBGR3pdoZuQcZ6dq+DL79nLWvh18d5IIf2x/iJJ4t1bW/EUul6vdajG/2Wz0a+1mCTzYnmVblJf7Pg3jyykQcjYVbcm/P+3b4g/aI+G3w/wDCHhPTtbGt+L/B2q6lr+keDbxbfVLqe1juYhDaSOw8iMSW9xdSPuDeTbCNW3yqDy80ovlqKze2t+3+a+/ufe4jw8xUp03gq6q038cuWUFDSbb97eP7uaTutY68qab+036lWJ5PGKYYyCRvzivzM8NeI/ix+wAPA3xuuviH8Tdf0Lxd4f8A7Y8Q6BrWmq1pbo19PaGCYvcPsmPkiRZVAI8xQQwyGn/b8/ao8afGn49XnwY8FftA2HhDwloOpQ2E9kL29t7jV5iqNLK7W8L5jBcxqjMBmMsRkg1zVK3KvfjZ9r99UerS8KcxxGbQw+GxEZ0JRm3VUJWXs5KM4uGr5lJqyvZp3vZO36VgDaNpOPTFMCn7xY9O4r4u+AXxW1X9m79vrxd+x/L8coPEHgx/Et5pnhrRNX1K9u9T0mWLc0a+bLCFKkKUZBIVyVZeh3eX6L8UvEn/AAUA/bD8NWni/wAe/ETTPhrd+LhYJp+g6TJaaZBaLKV82S+juABIygO0rIShYqBgCk23NU0veva1/OxyUfDbHyxdT2lZRw8aUa3tOSTbjJNxShvzPlkrc3L7r956X/SJwquWfj0479v8/wD66RXXcFDZbPAr49/4Jx/Hn4iXtvrXwV+L2u+NtQm03TJNQ8P634z8LPZOtvEypLC07zSmcqZI2XILAbskgKo7g/HTxlpu7whq/wAevDsmp2sUcslzJ4XuVaVmlcgBkXaQBGUYCMcYOQW+Uj7SeqVv68j5HiDI63DuaTwVaSk42akrpST2avZ+vZpo+iA+QFQ8+n+f8/hzQGLHJIH+1/n/AD9K+fv+Gg/GcTadHrfxN8NWFw1zNdwvHo11JBqenlzCgVMNIsqvHKWOQEYoxVwdpXT/AI4/EvxFfwN4B+K3hTW3uLXYlq3h+8tlmkJeRXUucRZiV+HkIYxgKc5zLp1Ov6/5Hj3XQ+gCRkA9Aep7f5FBljHJbjtn/P8An9K+fIv2mtS1BdH8VR+PdLtNNSx26lp1xot1JPcS+YqGUOAka7cFygJ+ViBklWEWq/HzxFNfDxBa/G7w3baLe21zp9uyaPc4ivIjCSRuj3CQeYxCkFSAB1Qljkr32/MLwPoh5VRTuOMjjnr/AJ/z6UGRD8pIPHft/n/PYV4Np3x3+IWoaj4g0mXxr4WttQ0QXks2kPo12ZY7e3aRSwYOVkY+VIVVeSo3YHNTeEfjv4m/4RqbXtb+KHhm+X7QbZzY6LfF4bmTLoqoqlmTEc6LwR9353KsHm1Zav8AUfuHuu7oGOAeuD+ef8/4UoKoxwepycjH5/5/wrwSz/aQk1i3sbO1+MfhlNRW6jgnMeh3ginuMzKyBWBIjYS2mw7vvK3JBwYx8a/HDeItL06T4t+Fmu7/AOyi30y00C8AnW6eNYm/eEFDgMwJbhGYlGwDT5prp+f+QuWLPfyOcbcdeRz/AJ//AFdelKpYEEnjJyc9K+dPhb+0N4v8Uz2PgS1+Jug3+ty3d1I99c6TMsFxEZ3EcKYZCjgRS43DlBGMhjz6Fpej/tFRRbL3xvoU0kd80sLfYJB5sbeZ+7k6YADJtxyNgySM7k68ac+WWj/ryH7JtXR6QzRkZJI9jx/n/PXsKq8EE5xjJ57/AOP+TXn/AIS0r4+aZZWFt4p8X6JfPHaQrqEi2jq0k32h2mZDgAL5JREBHBUkkjrB4Y0n9o+C1soPFXjnwzcSWqE3MtpYSqbpvKZfmB4ALsG4wRtAO4ZDXGtTlJ3a0/H0JcJJHo7EY2snb0/L/P8AOkKgAhVJA4wR/nP+frXm02mftIfZLW2t/Hnhl3RbVrm4l0ybe8gMZuAozgI+JQq9VDrljtwblzB+0PKLOK18SeFZHN9J/aDf2ZMFW38pCu0GbIbesiknIHmISCFKs3UozfuzTBRnHdM7p+W+Tglux6/TH4/r7mopJEeQEkMwbqO5x0H69Pw7msbwDZ/Eiz054/idrGkXt6WDCXR7KS3jAx8w2yOxAzjGWJx1Patt224LdA34+/8An/8AVWFXd6mkCNxzkx47bVP5Dj6dv8TUOZYmBKMSVGUQA7ugHT2x6e396pBcxudgfBGc5/h9f8//AKqRLiNyEWUhtvI4yOenfHP9ByeK4pyhJ6PX5HRFSS2IZwjxeQqnb1RR0Hp36c9sYxxjrSNG7RZlmVgoBQRgKDj3x6d/TsByZZI4wrKsIG4HcAAM8/j3I/8ArngEcKqu1I9meD8uDjJ4HXuf/wBZzjB02569v6/pmnMraEN6Aq+coznb8gUfN79fTvwAPQc0kbZOMFP9k9+PftjHPHvgdXzxK0fl8lsqRngA5yBweOfrn3OTSNGGRVmAxvXJUnr1AwM55/M88nkZSi3VbLi0o2KksNs5xPhTktucYBGMk9scc59OTgcFJHCqoERZGLfeUANx1Yc4HXnjjrgYBsPDHHJ5sgDITt3Z59lA7cgdO/vzUAjjhnCmUbXbIXnG7oAATx7Y68kdzXPKKg3fT8/+GNlK6Irw7GEkUm4gA5bBIJAyTn29sc8kDClCkIRi/cAqJiF2k5BYggYz056jAOPu0IY3DRxr5m05IAOSeCAPTvjt1x3akkV3VZVkwUQZw2VZsdOD+nfnBHLVy6Nuy/r+v6ZsrqyGI1uHlAOMgsTIOO2SfTqOvtnstQyI8qSGOIh1VR5bNghSwySDyOp6jB2gHP3anlVCUKoGRQq4LDnrjGPTPQd+mBlqHjQSyLI0jBiNu/GADzwRjopYduBxgfMcVFWLu7nu+m2Fp4J8EaX4a08bfMtku75sANJLIMlm+mQMfzNWvCHie1S8uNEnmCSXkY+zk8AupztOehOSBnuAOpArA8FeJLL4g+FbaxjuEOqaXbLBc26MAZYlHyyKBjOBwQOnXocnN1vQLxl80IxwxZSDgrxj6fyx7d/v1inTp06mHV4WSS8rWa9V+Z846KlKUar96+vr3On1/U79S6RBhjtjkeuf8/meK46+n1W4AJ8xSGBYZyVz+eD19efU9N2z8Ya/bxRxa7oq6gq4CzO+yUgDqXxhsdeRnHcd9FPEXh1irHw5dK7fwBl/rjt7cd8d4qKnin8dvJpr+vkyouVH7N/uOVsLbVpQVbeihcBNnHXjH5eh5Pc1rXKXOi6ZLqd/JshjhPJ9c8KOMkk4AH5ZPNbR11f9Tpvhra7DKtPIWyf90AH9frjjPnfxZ8Uy6hOumNfJKLZWLqhHlq/TAGQCR6nv1PY4Yh0cDh3JScn06a/M0pKeIqpWsjV0zx5LGBuucgnjB5I6DGOpJ/8ArZ6jvvhn8QkOqx6XNcZjuWCjJ+656Y/z+eM14Il86BbtZDtDdS/GMjnt7Z6fT+GvSvgZ4b1DXtfj8SXCyRadYyiR5pCVDuB8oHqc4zjsME9BWWT5jip4yEIau6+7q/SxWNw1FUZORY/aK8KQR+JJtUWEf6TEj4A6kccY78HjuT25NeKaiiwSCSKFspw7Rj8QFK43dzgHPJxnlq+l/j7HDKtt5oUkQMfmGcDI5/z+vSvANbs4DOyTu+PmcLnOOepyemQc/r2A4OKsHCnmE3Dq7/f/AMOdWT13LDRT6foc5K0SXJlVd67cs2BuwQQoHdhwxHQ9xxlqjuU6W7xEy+WduPmO30wNofjHGR0O3aDuq1NHBlJXjY+UGG8nO3GASfyGT+HzHIEV5uW7WSPgmNiwkfKjnBz15LADOTzxh2wB8aoybZ710ROkFxDv8qPKOqlIU6DHCrgZ4G7GNp642jLGKVBaFUU5gbCl4XwFPHGFH+90Ixk42rk1OUlPmw3Mwl8zLIpYnGDjOQWP3ivTn/efpDPbCdFk2y53KVLSjCAt35bnIPAHUj754pe5bXpuNXuMhgVXkgjAAEio3yZC/KMAbSM8Adl4OBtX5iVI8SwbXMBZySQsij5gSOSeQRnGeuTkDecEFYuFKWtRX+Vy1KovgZ3zQZBB9Mc+uaQQyhiFiJGeGNWzcW6fM0ij6kVC2pWiE/6TGfffX6BVeApv3qqXzX6nyMXWltEiNuRu+UgHkilVXUjefbHrQdVsed13Hjtlx/jTP7S00MAl1GRnuw/WuP6/lMJaV4f+BR/zNfZYhrWD+5lkEEBAc/QZxSv5agKQMjOAarpe27KBHdRg44JkFOW4iaTmYFgOobg8V1QxuEqL3akX80zN0qkd0yYncoBI256GlQpngcZ4oiMcpw5/EH6UGAo5IYHv7/yrtV2uaOpj1sx69uPoaepQHJI49aiD+WoGCc+1Hnc7SuD6VtGcYPUhxbHBPlIOMdKQyKoJ2kcfdBHSoTKWXap4H59aYyKWCAZGOmKxnXSXuo0ULvUkaZvMJVQBkDdTftR3HzASMgfL9KQgbADwMdce2KaQGBVSTzgnPWueVSonozRRj1RKt0jZCFRzyPT1r88v2vf2Kv2ovDtl45+D37P/AML7Xxb8KfiT4pt/E2uQLqcbapoupLcK8ktnHPLFHG3lmWIYEm9Jm8w/LH5f6EqoY7iwOckAivnL4pft0+I/h/8AFRPhzY/DjRLlbbU5rfVLl/Es0TRgMqJEyPaK0cp8+1nY4eNYbiJ9xjkM0dxp18Qml+mz3Pp+FuL8fwbjnicLGM0+W8ZpuLcZKUZe64vmjJXi76PvsHwl/Yu8IP8AH3wd+0pH4U8Q6D/wiGg3FlYWnjKHS212+nlto7UPez6aTDMscSy7GZmlJuCG2CNQ/lfhHw4PHl5+1h+z5Dc2kXiTxb8bRf6PoV9HB9o1Sxi0bQ3ke3jutscgb7NNGsjHYjKWzmPB+wbn4gzJ8Vbf4Z6bohuh/wAI9capqV5FcgNaYniitoihXBM+boq24Y+yNwc5HlfwN/a7+IvxT+KD/DLVvg/BZNEDc3V/u1ZVtrd7q/iSFidNNsZ4xZFHYXPkSS7hDK4wK9HCzacppb6/lr+B5Gf53mGf4mFXFyvyR5IrpGN3LlV23vKT1bevyPLP2I/2DfjP+zl8T/BviXxnb6bPbaVpmpaddSaWIIY7S3FrZpa5RCDIzSC5XeoLMkUckmySVkXr/HP7DXjLT/2m/B3xZ+GnxX8YrBf+PdU8Q+OtSaTRibO4k8OHS4Z4o5bPndHBZ25RVcBVLkBi0le7W3xTur7xH4u0jS/CN5f2/hRrS2drGVGnu72WFbiSBI3KKAkE1o+8vhjMwwuzLcz+zd+0hefHmPWorv4d6vpcuieKNX0m8uJ0gEET2l68UcL7Z3fzmg8qQ/LsO5iDjbnrdWo5OflZ/M8GytY4r9rP9mXxd8afFfhDTdN8PWes2Q8H6/oWv6/rMdozWsl4llHFeyQlUEzp5U8qrGgXzFVf3YbK7Hwj+CnxC+EXwM8Z/A/wP8OfC2htZT3dl8P9W0qRYo7+1liAtLq9REV0ng3rHK2XeU2xlU5kCL0epftEX1h4Ck+IFj8Nb/ULX/hKL/SLaPT5TLLJHbXE1t9pKqmdryQOVC7hsZG3fNgRfs+/tEaz8TvhXJ8Qfib8PLzwedM0a2utZOqRPCsUpt/NuQI5FDosWOSc8HGcqaanV9mk9l/mDUbnzba/CT4u/so6J4z1nXPHVppXgzWdTvtIntvG2qpJqGvWUfgXQtMtL+N4ZJA16b7Q5R5cjbmhu5XYBwq13/7O3wr8Saz/AMEy/wBnbWrLRdQ/4Sb4beAPCHibSdAX9xNf6hY6TEBp77yPLEu94nzyFZhgnivT/G/x8+KnhH4VeGvidb/BqxlfW7XTPt+h3Gu3n26xubt4laBIbbT7h7gQiRncqA22JyE4q/B8d9W/4Ubc/Fq68I2L3kl59h0fSLLUbnbdXj3S2UFvI91Z28sDNdMIm3QnZ1+bpVVJznBK3X8VsdOAxdTL8ZDE094u+vVdU/JrR26M+M/ht+0PpXxe/bu0LwXqvw78QXGgWfiO41PUtG8YabpsstlHf3Ump6jZNay6e13cBbu5uY1/fszYV8BTtGn41/Zi+MH7Dvwa+HXxs+GPwo0nxr4o8J+FNS0fxXb3P2uY2UeoJd+fJEltNH5qKt9cRMx3bdsbgABzXrf7Zf8AwUW179k/4zaT8MI/gvZ61DqEMNyNQXxEY3kgeG7Jj8vyD5UgktupZ1KMD1YhPatP+Mt7c+G/AGq3Pha2+3+PLyGOOztNW86G0jazmvXk84RgyhYYCAQoDO6LkBg1cs8NXcVOUtb3T7bflY/R6/ibP6zS+qYVQoxSVSm5uSq2VSMm5JRa5lVle27s3e2v58z+DNI/bOsfgR8KvhV8GdF1FNK+HjWHizUYbzUjF4UJ1e/keN2FwF8wRusqpJuZjIB04Ef7cH7MDfsy/tUXH7Ues+DrjXfBcuoQappGmWsEjRzaggVvst5IoxBB5q72JIaRG2R875Ivr3XP27b3wr4n8Y6Jq/wG8RGHw9rUkNjPFc6eqXNnFpl1dzTl1u3y3madfoF2qfkRThw6r7DfePTF8UbT4a2eiG783w7d6pqF4k4/0UJNBFBEUI5M5ecqSwH+iv17c1fCT51e19Oitov63/4B6FDxcx9DMY1aVFrDqNSLpupJtqrPnl79vdd0kmo3ST6vmPij9g34MwftgfFfSP29fH1zrOkeL9E1SaTxXBe6QVsPFNw8ciwX1lMCBG6AoJotpUmMOrAuVXzT4vfs32X7JXwQ8feBfFL+E9M1W9+K2mXHgvxB4m8MDURe6J9i1DzEiYWlwUIka2Ei4GGUZOCpb6g+HH/BQvxf45/aNT4FXXwHgtYptVuNLSaHxXDLPDc2rP8Aacp5YWTaiSZQEFTaT/M+Y8+2az8ZItOufHBj8OPdWPgqythNcxCaVri/kha4e28qGKSRVjhks3Mihzi4b5f3eWUsPUjL3kuaz1730u9d/T1MaXipj45vPEey/wBnfIo0lJe5GnJzhGMnBqybktYv3XypJKNvFf2G/gVo3hj4Q+B/2h9V0zRP7WtPA2tafqqaB4Y/s1tR87VnuEleJre3LYt4YUQsgDByQcYY7U17qsVlptp4e8K/E2K60uSF1nW0geSSK4CQtJIfNkZh+5kmztyCSBsDAUv7JX7bOs/tIeJ4vDevfD5NIa48IWesQz20GpbWkd3jmj3XFnFHtSVHTO8/OhUbjnbpfFj9rXVfAfgCz8b6N4MspU1P4jXfhbTvt+oyIshg+1xCc7ImK77m0ZFXkbHWQt/CHJVaVXkcddPy/Wx8Lnec18/zGpjartzOVl/KnJy5dEtFfTReSSG3Fx47uvDWqWf9lfEWae6tdPvLWe+toIZbZhcorKrR+YPNTc87RFGTaApG35Kg17WvE2o30EEOk/FWzubi7t4bW5hsrTKGO2eN5NrTYIdWZnLAnMakDIQHb/Z7/amT40ReLdQ1zwTd+H7Lwo9qLy8vZ7doomfT7a8kRninfJQXGc4UBcA4cMF5b9oD9tHxd8GfhF4M+ITfCq1S/wDGumB7ew1LWWjGn3zW6zpbS4i3PwXyV2nMTAdQTk1VdRQUde39eSPKXLy3ua+sN4z8Oa/fW1kPibd2b+RLbXWj20EiT5Rd8hWURtE5csHQggCNWAUsdyeHbPxc+kX1vZH4h2N3dTm6Rb6whiwyFlZS8e7JcP5jZ3E+Vt5Yoja3gz9pm58Y/szj9oW08DwpJfkx+HdGTVd41CaS4+y2kfnCIbBNcMiKwVgFcNzzWT+0n+1b4g+A/jCz8Mp4GslsrzTZLuDxBrev2dlaP5dvdtKhM08ZjEUqWAeT5hsuzhSU5m9Tm5VHX/IaUd7lTU9Q+I+j6FZQXlv8U7q9s5p55nsbC1m+0FgyBS7FBsHk7lGxTi4UMuSVFvUk8T2mo6XpHh4/FAR3S2dp5htYVtbONMRPLI5HmjKq0p+98zgfLnC93f8AxVvLLTfBsh8JSx6h4v1aKyi064vE/wBFH2aa5mkaSLejBIbeUrtOHbYuV3ZHjvi/9unxX4P+MmufDC9+FccdlZao1rZ69c2+rrFCq200wkkVNOYTg/Z5SpgcqRkEqF81oh7So3ywRT5YrVnTaZL42v7KbwNqSfFAJ4hWO3fWLvTbQNpu4n95vWQhFGSG+RsnaeRkGjpH/Cd6ndWnhLVdO+J1hFdNJa3MyWkEluRLc3LtdSSbgUBVlyACUGwKvGT6u/xGY/EjSfh/Y6E0ov8Aw/dateXbsYzaJFJbxwo8ZXIaUzSldxXAt5OODXlPwe/a2+JnxI+K9z8MNS+DsNm1reM1zeFtVAtIDeX0AikYaa9qbiMWLo7LdfZ5JMrDM45pLmnFtR8wdk7XJvFs/wAR7m3uY9Kb4rwTHzJbQw6TaSRRsS3lLgybmCHacMSWwucncB0nwmj8T+MPEen+IPFsXirT7nQtP8j7NrGnRwQXjt5iNIoSWU7iPLLBmPIXaWw2JPir+0NL8P8AQviHrtl4UlvoPA2k2pE8DF/tOpzo7/ZDHhSoSN7KRn3Y23XRdh3YvwW/bG8LfFr42ah8G30yOxu4NPe5sxJqlk8peNIDNBLFFcO6SgzkhduNsMmT8vNONWUbxjp3+79GL3Vuz2cnOCzcdiD/AJ/z69agjjZn3yEFcDAQ8dfb/P8AOvNfFX7RkuifD6+8fWfhqyMSeN38PaYNU1hrWKZYrz7JcXM0qwSGBUeO6YLtYMsKnK+ZhbfwA+PmkfGz4Yj4l3V9oNvDLp8GoPb6brJuhY20sCyqLh2jQLIPn3AAqNvU4rlqYao1zNaI1jUitE9z0V1jJ3IR2xlcf5/z9ajGxCwX72QdwGMnt/X+nrXi3xI/a31j4c/CHwz8Ub34bWazeJfDzahFo2pa7LbSxyi2Fy1tv+yPGXSASyyBmRhHbzsqyCNgLHgH9pnWfFH7Nd58bNV8FWUer2jSWcOh2OpkpfahvWCG3V3jzEZrh40GQ6gSIytKpVmU6FXlUklvb5/11HGcb2bPX3MocN9oDbTjaDj/AD/nHrSCOQkMckFsAKTjGM/nj/I614z+0T+0141+B3j3T9A0f4aJq2n3FtarK8gv2klmur+3tIzF9is7vYkXmEyCVUaQyRiLzCrLXaX/AMUdY0vQvB8l74ViXV/FusW1lHpqXUyJb7oJLqZi08EcuUtoJn2PEjF1CEKx4wlQqRSclo/P+v6+ZopxeiOyYLGcLlScchf14/H8PQc1GixfKAqEEYwBzkY5/wA8Y9B18R8b/tZ+NvDfxZHw+tvgHr15YJDfxz6hFbytG9xHPapbATBDGqyJLMxByRtHPytj0bUviDc6b8QdJ8A2vh9p57/w7faneyx3ChrZYJLaNIgpyGaV5227mVf3LnLEYqKlKpBq60tcuMotaM6iSe4MYRcEKOOOmPTP+foKWKSVo2EkqKBxk+g65zjHGf06Dg/NXwx/bt1L4jeO/CXgew8A2LReIzdCa/tPEWnzKiWt/c2VxJGqXTeYDMtsyhd+VNxtaYojP6xe/Ga00jW/GFpfaJPJpvhDTbKS8v7ENcSPdTCWR7UQquR5cP2aUuWxi63HaI2cxUhXo1Vz66d/O356FR5Jx0O+l2KWBIwVxliOePf2/wAgcGOMtzGGXaOQzJnnGD1/Ln8eAFrw79nL9sey+Pfi/U/Bt14ejhuIn821bT5UnSGHarC3uCjsRMgYFpYw1uWkVElZ+Tt+N/2jb/wp8L/EPxb0zwjaXGm6J4iu9MtvtWpyx/bBas1u7ZitpPLY3scsCK3ykBX8xd/FTpVlX5GtdOvfYUZQ5L3/AKR6hN5sludiBmDHAdSS3bJBPYYz+Gf7pZJ5DtHl9pZWDbmzx8ueuQTyAfy9FryL9m79pLVvjY+uSeI/DulaSukw212tzZawZ45IbgTSIrZjUAxQrCHdWI3SOMRsrqvOfF/9srV/hx8KvBnxOu/AlvbDxhbPcrDqOtQQxW6HTbi7jjkeR0kDKI49/lxPtUSBQSFZuedCu6jhy+96rtf8v677QlBRvfT+ke9ypEr75xnfGcFwRuBAznOc9s5yegOfu01hcZbdtcbTgg5yO+c5HJAzn6HPCjyfw9+0RceIf2f9a+M50jTr2ewubu20vTdL1gTx6lcI/lWsQkjB8p55GjVRgsvnDgfNnnv2m/2s/FX7PnxB0bwTpvwz03ULa6sjf6leXniBrU2lrDFLJPM6i3YJEirCBMW2qZ0BCBgWxp4PF16zpwjrd9V0t/n/AFY0lWo04c0me6KEkj8m2lBGz5Rs+U5JHOc46c9SCedzYAUwuzvIykHzBsAYEgEg9O5zx3P1YgDs/gn/AMIX408DaL4ri8Htc3uq2MVxNY/aJLpYJSAGUYjj3BT8u5kA6ngdfVdH0jU9NjJh0nTtHTIxuaOFj9Qg3f8A6j07+jRyCrW+OdvRN29dl+JyzzGMPhjf8P8AM8J0rTPG1rqKaloun6itzD86TWlrKWU5JwNu7rhucHn++enoGieP/iuieT4v+F91qHT99b6fNFIRjuVUqc4J6E+5NejLd2iqFvvGaMR1MULtn8Tj/P5VLDqHhwDDeIbtiO6xqP5k/wCfyr28LlMcLpTxLXzjb5q7OOrialZe9Rv8nf77I42Pxjc3CA/8Kf8AEkZIyVW3LYGP9znp2z14yc4ZceIvGjwgaT8EtVLEcNdMwAGeMgID+vX15Nd9BeeHnACa7edAPmCn8eKnjtbe4GLLxLGT6TRFf1Br1Vg6lRaVr+ih/l+RxOo4PWn9/MeRaxoX7QPiyM20Hh19Pt5F2yRQukA78bmfdj8f57qr6f8As3eL7hlbVtZ0yxThnWSfzXXB4ChB/XnHYjcfYb3R9XiiLywSSJj/AFtnLv8A0Iz+n+FZWqeCfGWpwmbRr5QccLeqYsD6jOT+H19K5amQ0HPnqKdSXZv8rJP7maRzGoo8sXGK9P8Ags5fS/g38MvDEou9a1C41aVSGMGBDCWHQkL8x7Y5xwOOtdb4Xu7jxRfRR2drHZ6PpjDdHDGEhGBkIAOvbn0+vNGL4Y22mL/aXj/WHuVJBFpaA+WfZnOM9uOP5VS8Y/EGG0sP7D0i3jtbSNcLBHwMcct75PfjPqTiumlCll0XKUFTj/KtZS7Xert6v5GUnPFOyk5Pv0Xp/XzKPxe8ZRX+pNPb24njTCIjcfKM8jP1J6fkMtXl9xqmhTyFbm3RCo+YgEjpx29O+Omecc1N4o1u6vmOGULu+7uztGefXB656/iSAOSu3aTy7mMKsitgYONi55DHJx3znPJ/iOAPjczzerUxLnZNX6pP/gnuYXAwjSUbtfM3b/QtKuA5ULA8aqI22NhThSDgY4AAHHZmAxzVfR9G0aTdHLdx3EqAFWiUr0Xnbzzx3A6HptIFZM9/qiwq8rMpRWC5TnHuw5BJAwPfnc3A7v4ffBu81yzi8V+Idbl021nQm1SM77iUdA3zZABPqWzjOGzkc1CcMfi4qjQT6vpp59NL9TSpCeGoP2lVrt6/nr5GJqPhPSpgCqJb9B8sIIAxjgcYG3K/TAx1zNa6Da28H2dAGUKQwEYXOeASAODgYP8AhxXod/4Z+FNjPHa3U9+smNy7r9QzAEZONnI+YA9vmwOcYq3XgL4dasc6R4pv7a4O0p9saO5jByMfKApHpkZ79Tmvdnl1CFVuMYuXVXt+dl+Cv3POjiasoJOTt6f0zx7WtFuoJna10ydQ0qkpGu9cnIA3ADHcZBHHGQD8xWv8SfBHiPwDqkEWvtFLDP8AvLDUrV2aKYDAO1myVbcTlCDjIwGJyCvisRhIxxEozUotPbT/AOR+62h9FSrydKLi018/8zkJPHHgmEY+33b/AO7bH+tVJvid4KhO3ytRf6RKP5muGvpbo9JSPoKyLxLk5f7Sw+jYr5iOR+F8fhy+/rKX/wAkz9So8OVZfHWf3/8A2qPR5Pi74Rj/AOYXqR98IP60z/hcvgwH5tK1MH6R/wCNeUXEN25P+lye3zmqclncE5aZz9WNbRyTw26ZdH73/mejDhajJa1Zfez2aP4yeAm4kg1JPXMaH+RqcfFv4ZtgG+v04yd9sTj8q8Oa2jgXdPOEGerPj+dJHf6PH9/UIz9CT/Kto8L+HldaZfFejY3wjSesa0/l/wAMz3i3+KHw3kJC+I5o+eN1rIP/AGWr1t4/8GT8weOI09N7lf54rwS21XQh1vB/37b/AArSs9R0B/8Al8UfVT/UVtT4E4F3p4eUPSc1+UkcVfhJpfxZ/OMX/wC2nvVp4qsbgAWfja2f2+1Kf6mtCPVtcdcxapDKPYKc/pXgtr/YsxHl3kBJ9XFadnYW+Q0EgBz1Q/4V3U+DMmpr/Z8XXp+lep+smeNiOFO84v8AxU4/pY9pGp6wFxJHE4x2JU4z9anj1+8XibS2wP7jZ/8A115PYXer2YAt9bulA/hF02PyzWzp/izxLb4B1XzQD0mjB/UAGuiHDGOw7vhc1qr/ABezn/6VTb/8mPGxHDFTpGm//Ao/loehL4hs9w+0RTx46ho6fDqOnFCLTUFyT8qSNwD+OOOnHSuY03x3LkLqOmRyDPJglKH9Q1b9hrfgbU8Lem9tSefngSZR+IKn9K1WA4qo6rE0qq/vQcX/AOBRqW/8kPExGRVaO9KX/bsk19zVzVSUmNS5RjjkoMDOOo64rzPxv+yb8MvGdhqypea3pmoa/JIda1bTNamjnv1dmykwLGOZQjeUgkRhHEqooCqAPTrPwb4W1Q79G8ZWQY9BL5kBz+Oavt8LfGcS79PvEuExwVnRwR+ODXbRx/EFB2q4W/8A16qKX3qap/mzw62BpQdnJp/3otflc5TTfh9pkHirxD4u1SU3U/iG2trKeKVMLDaQJIEtx/eXzJ7mQk85nI6AVzHhf9k74EeEPiJP8QtA8AaZazyWVhDa2tvYokdrLa3F1OJ02jO92ujuP/TNT3OfSpvDPj3TMyXnhiWRBnLxIf8A64/XtVP+0PIfbfWk0BB+ZZEP64zXdSz/AA9Nctbmpd+eMor/AMCtyP5SZxzwc5O8bS9Gm/u3/AwbP4Wx2HhHW/DGm+M9UsrrXtWvL+61ywMSXimecuFRnR1Hlw7LdW2lgka4IYAiHw58DfB/gfxBb+Ivh9dXmhtDoi6ZNp1pOGs7yOMAQSTxuGLzRDIWUMsjBtrs4Cheqt7qGcZt5kccdGBwetSNGJSEdc8DvXr0cXGvT56UlJPs9H80csqXJK0tDgfEX7OHgrxR8DNH+AWr312dJ0aLTFiuDbWszzmxkikjMiXMUsT72hBcMhzuboeRU8O/sveCPC3wz8UfCrQ9WuY9N8X6gbjWVTT7O3Vo3gt7aeCOK0ghijWSC32EhdwaV2yTjHpaqVTBPGcAUqrg56nPWulVK21/MjliYXi7wHB4x1Kw1hvEOo2c2lxXTaa1m0WLe6mhaEXYWSNw8scbyqgcNH++fdG52lc1Pg7o8Og+GPC0Wq3b2XhvVk1B452V21KZUmKvOQAC32iRbnKgfvIlIAFdgUBHXB7mgIUyGAOe+aLzErHjPx3/AGFP2f8A9oL4jaR8UPH3heWbUtNm33S215LAuoqIJYY1m8tgfkEpIZdrnYiliq7a7Hwn8FvCfg3WvDk/hOyg0rTPCugXWlaLolnAqW8EU8lszMAP4gLZVB64kkyTuzXalWbknJ9x/n/P5VHLt6Yx7VjU9pdScnZdL6GkHG1rI8b8SfsMfCPXtT1bXp/EXiS2v9fvri6125sNQihW9863ubYq0Ih8lAILy5TfHGsjGZpHd5D5lelaT4MttO8a6349a+llvdatLOzzsULbW1sJWjjXj5v3lxcSbjz+8xjCitgFWOT1zxnvThJkYKfjTeJnN6sSppLY8T8D/sReEvA/xKh+JFj4yu5bq11AX8Nw+l2n2yS5cymd5Z/LIYzC4uhIUSN3E/L/ACRle9/4Ux4XuvBfiHwdrrf2iniXUby+1K4u7WKR2klkzEdsishMEawRxllIAt4yRxiutb7wH9f8/wCfzpQw5A9OMfy4/wA8/jSlWlN+89RqKS0PL/hH+yR8Nvg9qkHiXRpr2+1e3gvI4tQ1WbzjGLi4aYlQfulQxjBBBKltxLO7NLr37MngLxN8J/DHwe8T3l9daX4Wa2khljlSKe5mt4GjSZ5QvmRSb280yRNG5cYLFGeN/SnuR1LdB/n/AD/+uqpuHaY7SMDkDPf/AD/nvXNiMSotNSdzWnTbWq0PNNB/Zg8D+E/hf4l+EPh7VL2HSfE58vUFaOHesLQRwTouxFy0qI7PI2XMk7vnoon+P37LPwv/AGkW0pvH0VxHLpcxeKeyjhWWQc4R3kjZtqsdwAIw4B6jFejRyHO7ysc8E9/8/wCfWlyhUMhwD6d/8/4/jzwr1ebn5tfuNHCNrWPO/BP7M3gP4d+A/D3w18LTTx6TofiEatJDJDEGv5FMjQrMY0QN5Uht2Q4yPskIJOKp/F39k/wR8bPFQ8UeMPE+uxlEjEVtZ3EQWMxhwgXfExRMySmSIHy7gOY7hZ4sRD1EIoO8A89/X8KFODliOnp2/wA/5Aq1Wq8/PfUnljy2sczZfDmSPxPoHivX/Fd5ql7oWj3ljHNdwQo1y9w9uWuHWJEQSgQbRsRRiWQY+bA831v9gz4Rat8T9V+LEV/fw6xqwvXlnVIjtkuUKMchQXCh5gA+7HmAA/KBXtqurgneAAPTPH+f8gU4AMMFj0z+FOnXqRd4sJQT3RiWHgHS4PGmt+OLuY3Nxren2enyQugCR2tuZ2SMY6kvczsT1O4DnaK5Hw3+yX8C/CvxCuvH+h/DvS7eWa1sY7ezgskRLaa2uLq4FwhHPmO90SxOcmMHkljXpkY+bI54x7/5/wA9BRIu7gnnvx2rTmqcmjsRZc2px1x8IdNufAni7wfNq07zeMZtRk1PUvKHmZuUMMeB0PlQCGJfVYF781W8FfAiw8F+LZPiJp/i/WbjWb8yf8JFdzGHZrWV2wCaNYwqrbrhYvK2ELkMXLMx7o+Wcq2eM5/z/n+lKszxuWBwcEdv6/59fSqU3ezegnHTQ4mx+CGlxfCrQfhhHrl6YdBS0ZLoABry5twGSacY+fM4WdlyA7qAxKswbM0T9l3wl4c+EGpfCHRtX1FbPWfDdro+ryPMCZ0itRayTiMYSOaWABGZABlVIXIyfSknkK7XcLxyMDr17/5/lSF32hjMwB5JB/z61SnZbvz23Czucp49+D3gP4m3VjeeMtLmu/7MRjpsaX0sK2srFf8ASIzEylJgoKLKpDqjyKCqyPuwtB/Z08P+H9Li0YeK9Yv7c+L4fEF9/atyLiS6mghRLeNnYbtkTwWsqkktut1y2CTXpMhA6Kcng/Nn/P8AnrUTbTk4JJxwffp/n+ZrGXPBWTLjZ62PO/iv+zR8Jvi5dx6x4o8IWD6j/aGn3Emp/ZEed47S6huRAWIzsbyVQ4x8rHpwa1NO+FfhfRfFGgaz4esks7Tw7p99b6fpUUKiFXumhZpx6Oqxui4/huJAcA89e0YYcHDZ5yPy/X/JPSNk5DFsc9OhJ/8A1kf56c8nWiklJ2RrHkfQ8j8WfsdfDLxh8TLv4sanfXY1K98VaVr0jf2VpblJ7AWYhRJ5LRrhIyLKLcFmB+eTBQMK7y18CWlv421fx7dTG5n1bSrPT3gkjGyG3t2uHUAEfMS1zKSTjIKg4AAO5KpDLJHg9Pzzx7+v/wBfqGtKAAY0UgHLsWwMZ9fT3/LJyRlUrTkrSfS35f5Fxglqjyjwr+yB8IfC/iXRvGI0W2e60axvYlZbUQq5muLeaOQhWAHlLbJGB0KkZwAFrs9D+H0WgWOuw2muXC3uv6tcX97qoji81HdVij2q6Mh8qCOCIblIIiUsDkrXQRSSOpCsAy9GJHJyewHqD098dzTXnZXOF3OMDgdeuPxz6evHc1zyrylG8nf/AIf+v6sbRp2dkedfCj9mzw38FfEV7r/hjxlr9yt5bxwXFtqkltJEscY2oF2wKyBR2VlBAUNuCootxfATwbf/AAs0n4QeMi+taVpQhF5Fe5VNTkRSWluVBxMWlJmYHgyYJyQFruFnRXJaMkrgHHQnHYDp/nHckScu4DQjbuG1QSDnHYfQdscHjA5OU60qju5a/wCX+RcY8q0R5hcfsveHBp3i60tvFviBovFejrpUsep6tLd/2fbbJElFvJOzyqz+axJZ3CsE2jIKm78Tv2a7D45anZxxm6tbmz02+tbabTtKglljFxA0BJaSN2CqsrnYGEZcKXDlQB6tomk2MwWXWJNqbv3cKDaWIB7kDaMZ6dicYHJ6mx1S9i02R9H09bewtgWnljTy4Y8D7zMcAcc8nJ9hjPTCi6jVSpNpLXu9tflZEc9vcjG7f9fmeU/Bb/gn/B8PvAujfDS58eXZ0LSPEUesRWWoPDLMXjk+0rFmCNFCC7AuevysuwfuwqR85+15/wAE8v2Zf2mfEq+J/FfijUJdaGg3ukXOoWcY2tBcCABQxcnERhYoqny908rEMzk13njP40zayz6NodyyWIOJJujXRHc+iei/QnnAGAviWYqMSGvmMw45w2Dq+zy5bXvN6t33stvm1r07n0mD4TxFaCqYx7/ZWlvXr8v+GPWfDvirw94C8L2/grwBoljoWjWalLPSdHtlt7eBCxbaqJgBck4HQdBgVUvPiJM7EiY/nXmqa5cOP9aevXNTR6iz/ebNfL4rjTMsQ9Zs9ilw/hcOrKJ2snjq7c5WQ/nTD411P/lnMw/Gm6J8PL99Lj8R+MNYs/DulPyl7rEwjMo/6Zofmc/ofWi++IH7NXhlfIsLjXfE9wOC8Ci1gJ+rAN+QNduFpcSYimq1WapQeqdSXLdd1HWbXmo2MeXCSnyUKbqNfyq6XrLSKfk3ccvxC1uBvlkY/U1paV8Vr6NwJmYY6muZHxh+GWoyeWPg/dQRn+OHxAxcf99RkVo2en+EPFibvBGpXH2rGTpWooqzt/1zZTtl+nDegNd1PH5thX+6rxqtdIuV/kpRi36RuwrYOio/7RQcF3fK183Fyt87I9Q8IfFYu67bojOM85H416BaaxH4kssW0yxXW35CT8rH0NfM1jPNYThkcqQeR0r0v4beK5XdInlOOg56V9vwxxnLFS9jVZ8nnWQUowdWkdTJ8Rjp97LpWrwmOSJzHKknIJ9Pcf09uaoa34P8F+OrczWFw1hcvys1vyhOO6Ejj6Efryvxa8Dw+JJNP8W22oi1d18i9YRbvMI5U4yOeD+noMVfDXgmGzRRJ4qnc4GdsAA/Vj3/AJ9zzX0+IzBfXJYWulKOjV+zV1b5dup83ToWoqrBtP8AyPMfHHwk8e+FJm1GWwN5YZ+a8sWLqo55boVwM8MABnggZ3cTEZxmCeVQQhIVIu/XknAZQOo44/ugjP1jpukSQBWtPEcisO/kjn/x7/P61V8Q/CXwd4uAfXvD+n3MowRc2+62lJ68lOG555zg89a8vEcMQxD58NUtfpLX8Vr+DO2lnDpWjVj81/k/8z5Pby7WJZY1fzAhIMXJJC88HGePUjAHJUEA+4eB/EXh7xz4RsdGHiy306/tLNITbXEgQPsXAZd2N3yqCRwRzkAHBt6v+yn4U2udP8QanYoyni5hWdB6fMhHIJJyecnPXmsCb9lDUJFW20v4g6W6HALSLIjbeegBODnoc9ST1Ga5MHlOeZXXlL2SnGWjSktV5ap39UdFfG5fjKaXPytbaP8AysdDJ8J0vpjG/i+OcqCwghmEjsB1O0HJ6gfj6HFcxqPwt+Leo6nNcabo8NvaGXFvHd30YkZOm5hv6kHkE5/D5T69pfw+tPCWjR6HoWqWtnBGi+ZLtLSSt3ZjxuJJJ9u1Uby48IeHJTc6jqk+ozD7kSoUj/qT69+nsa+ixGTUJwj7a8OrtNfddptpeSXoeVSx1SMnye920/ysl95x/iP4ZeP9R+C6aNq+iteakmsi4tYYJ0lKRbCGIOcEHJ4z0x67aKTxh8arvd9pc+WoI8oRrwq9cAd+A2MZJxx0yCvBzKhkVetHmqT91JdNUur0PTwlTMadN2jHV3/rU/Py9/aC8BcmO/mk9Nts/wDUCsm8/aG8HchY7o/SAf1NeIeHLHxV4w1RNE8K6VdX93IPlgtYi7Y9TgcD3PFew+Dv2H/ilrqx3PjDXrPRomGWiDG4mX2wuF/8er8azGpwvkq/2uvy+Tlr9yV/wP6cxFOGXr9/UjHy6/duMn/aD8K84tb36mFR/wCzVl6j+0FokwMOn292pI+aQxL+nzV7J4X/AGGPhPYbF1u41XWZ+6vP5SE+yxgH/wAeNej+H/2Zfhr4WiWay+GWk2ir0n1GFGYe+6Ylq8LDcT5VjarhlWCr4mS/ki7fPdr5o8mtxPl2Derv62S/F3/A+S9P8cx6/cbbDTtSupCekdsXY/lmum0fw5471bH2LwDrhB/ik02RB+bACvrO803wj4P04XeueJrDTrQDIaGFiv4cAfrXJa5+0d+zd4Z3C58Y3V869rdAgP55r1+bjqs/dwEKC/6e1op/+Aq0vwM6fGWMxmmEw7n/AIYyf42S/E8e034OfFS7AY+FmhU957mNcfhuzWxZfAf4lMAZDp0PPIkumP8A6CprU139vP4MacSujeEp7jHRp7hufyNYOk/txeLPiJr6+E/hR8J49Qv5ELrBb2+8og6u7HhEHdmIA7kVvQy7jSvUUZ47DxvsoRqzf4qKb+ZvPGcYVqbqfVOSK1blyxSXdtydjfs/gL40GPP8Qaeh77Fdv6Ct3Tv2bfH90oe01OaTPQwaVI/65rjb346eJLWYw+Pvjd4W0eUH57HRoG1GWM+jMhSI/wDAZGqGD47aReSCHRP2lLyOb+EtoCopP/AbjI/Wvcp8L501++zqz7RpUk//ACaq396PGrYrieeqgrd1Gcl96p2a9Gz1Gw/Zf+LDEbbvU8f9gh1H/jzVt2H7MHxWQfvLq5Pr5sUSf+hPXg3jr45ftKfDrS4vEr/ESfUtGmnEMOq6dfvJEshBIR1kAaNiASAwwcHaTg1y1l+2b+0R4y1aPwx4f8UvNPMGZ5J9qpFGqlnkd+NqKoLEnoAah8P1qdb2dTMMRKT7KjG/p+7lv0sxUct4lxtH20alPkV7uzaVt77Wt1T1R9S33wJ8VaMu7VvEcFtjr5l5AP0Dmmad8KvEF38+la9PdLnra2ryj80U14N4H/bF0/wHqImm8PweJL9G/e65qbM25u/kwuCkS+jFTIeuVztHq2lf8FS9QmTyl8OSFolG9nAZUHb5s8ew/Ku2nk2UUnatjcU35SpS/FUo/grdmzgxOX8RxdqVNT837n4PmdvVp90j0LRPhd4rF0ts3ieC2lbhUv0eIn/vpBXfaF8Hfi1ZBZLPxJpWDg5W5kGfyWvO/hb/AMFHtM8T6tFpHie2t0hnYKVkX5Dn1DCvbPiNeQH4bTfFX4b3/wBnWyiE17Yo2YniyAWQfwkZzgcEZ717OEyzJ6mFqV8Niq83TV5Rc4qVlq2lyWdt+nlc+PzX+3MJioUMVTjDndk9JRbeyurW/HzJtH8IfGixAWTVtFlA/v3cgP6R1uxeG/iDeIItV0Xw/dDoRJeuf5wmvC9H/am1hlCyXatj3rodO/agvDgPKPessFxNw9T0WIr/ADlB/nA87F8OZ5f3qcPua/U9Mvfg4mq/Pe/DrQ1c/wDLWz1iWJh9MQisq6/Z01D/AFmlTSWp/uS3i3Cj/wAcRv1rG0z9pRJ/lkmFbP8Aw0Bt0m51cSZjtyibQeXkfOxfYfKxJ9F9TXtYXMOE8XWuqs1J3baVOL0V23KMIvZa6nj1cqz2l7rgrf8AbzXlo20ZWo/An4g2CM8KW10B0Ec+1vybA/U1hal4L8WaVu/tDw7dxqvWTyGKjj1GR+td94c+Md5eRC4v70Mzf8s41AA/rXV6b4wsdS06a8OYfKiLmToBgV9BhcTkmJXLQxDk/O3TzsvxPMxGFx+Hl+8gvlc8FwwGwjB7jFNJOckj04r2KfxL4W1gE6rpVncZ4LTQKx/Miqc3hz4XX+d2hIhPXy53X9N2KhYzA1Pgqr5idDER+KDPJ2kC5BI55ximM+4ZB47Zr1Cb4c/DWclke7jz2W5GP1BqrJ8MPh8Mkarf89hMn/xNZzqQl/y8jb1KjGS+yzzUqerdhggCh41Y5d+/3s16P/wrn4fQ9b6+bB7zr/8AE1EfB3w4gyGhnl4x+8uT/TFcVSthYL3px+83jTrSekWefYVMDsPemsZOmByO38v8/wD1q9GS1+H1qwMOh27EDjzWLDj2JIq5B4p0XTgFsLG1hx0EUKr/ACrkqZrl0HZ1DWOExT+weWtp17cRlvscpUDqsZI/z/n2qCSBkumaaJgw6bup9v8AP69K9hj+IaE588e/NSSeMrC/Tyr22gnQjlZUDDH41l9fyqq7+019P+CX9XxkN4Hj4Csd64/Ln9aD13gZ9RXqF7onw91gFptFSBz/AB2reWQfoOP0rntV+GNsG8zQ9aVh2juVwf8AvodfyFdXt8NL4JpmPJVTs4s413kPROp9evP6ilXdj1z7+/X/AD/+rSu/CviC2crJpcpIP34vnH5j/P8AKiDw3rkxwmlTDP8AfTb/ADx/n0oUqd78y/AGpWtYzQm7k5IA4J6/5/zzTmjQDrn5Rxj/AD/n863rP4f6k+Te3kEAPUbtzD8uP1/wrUtvBXhe0UNfX09wehAIRT/X9axnjcFSXvTRao15PRM4+NlAxvJOQeP8/hSq5YbSMH1x/h/n9TXewWfgm15TRoWx3lJf+ZNX7fUfCqJtGh2GP+vVD/Ss451l6aXtCng8Ra/KeZ7sDg5IOcKf8/5/OhHK4IOPp/P/AD/9evTpJfBd0MXHhuwPutsoP6VTu/Dfw+vF+TTXgPXdBOw/Qkj9K3jmmBk7xqozeGr21ieeSEHBA7cg/T/P/wBalji2Jg/LgcY4/wAn/wCv0FdTfeANMGX0vWmGOi3C5/UH+lZdx4R1O2BWOSCbnqkv+OK0jjsFKd3NfeDw9dR0izKUMi7UO3jhuwP0+n+RQzEZYDGPw4/z/kDrbk0fUIjh7fnb/eHr9TUMtjdFSGtyPdiB/X/Pb1rR4vCqP8SP3olUKzfwv7mQMUUksMc/ebsMc9frj/AVGyAnDEHk/ljn8cf5xxVtba6OAyqBnqZAMf5//V60iaagALXUK4P97/Af5/WuWrmGXrerH70b08Hi3tB/cUnBOBtHykhifT/H6/oODFNkR+cj/Mqkc4AA4JHt0H5/QVrxaTo+4G41c8H7qLx/OrC2fglFCT3dzJgc4mC/yH/6q4p5lgHdKojrhl+MunyM5wRxK+3YG3Kd+8k+xHP05z+PXbTbpF52B8jjHKjvx6Htnr17nC11Cv8AD2IDMMjEdzOc59eMVZ0bQ/DPim9/s7w/4durqbHCW7sdo9T2Ue54HtWcMTg6zVOEk29kt/kjWWCxlNc8o2S6s4wxmaMxEbcFfkBII9h6dsg5565PAfaxyXd9FaRwu87PsigClmkOe3Un+eR3PA6/xrZfAz4ZsU+KPxPtNJugATpNlci5u+nQxoCUz6nj3xmue0j9rD9n3wbeNP8AD3wNqepXOwp9v1e6WLIIwWCrnGemcA4OOnFdVVYLCO2Lrxp23Td5f+AxvJP1SNMPlmbY2HNhsPKa6NK0f/AnZP5NnceG/AOmaK63vjKQ3N5nK6bDJhI/aVgef9wd+pz088/aU+JHi7xNfL8OfCmj3TafZhTcRafZN5e8jO0BRjjIrZt/20dQlGdH8OaPp69vJtssPxJ5/KtC2/ay8V33MmtIntHAg/pXn5pj8lzDBSwtPGShGW/LC912bc4t/d8kerluVZvlmLWJq4VTktuaez72UWtPX5nhcHhjxvGgaTwlqigDq2nyD+lSFry0fy7uCSJh1WRCCPzr6BtP2jvEc3J19/bhf8KvH446tqkPk6jJZ3iEcx3dnG6n8MV8j/qjkFZWpY6SfnTT/Koe/PiDN1L95hI28pv9YHz3b3Y2jDde1dAPGGlfC7Q7fxDPpsN9rmoIz6Pa3KhobSIEr9pkX+MlgwRTx8pY9s+kazdfCXXm3eJ/hTaxlvvXegSm2dffYPkY/WvPfiD+zrefEDVJfEvwa8cRa00Vsif8I9qSi2voY40CgR5OyXgZOMcnuTVYPhPGZdXeIoyjXa+FRvzJ9+SSV2lso82uvQ3o5ngcbNQxidKHVv4X5c0W+VPq5ct0rdTzvxB4p8SeONWfW/FmuXOoXb9ZrmUsQPQDoo9hgU6ygVSKxnbUdI1CXSdXsJrW6t3KT21zGUeNh1BU8g1q6ZMZGGT+leRjM0lUk3Jvm633v5n10qMaVJRgko20ttbyt0Ok0uNCRuH1roNPiMLLLExVlIKspwQR3Fc9pRwB81blnK3AA+leFLFVKk9GeHiU7nRahrT6rcfbZ1xNIo84/wB98YLfU9T7k11vw4843MZ6DcK47Q9Ne9lUFTg+1epeAvD5jkijihJckAADqa+84Uw1etjPay3b/E+QzerRoYZwR0vxF1X+zvhtCzPh5NRUR8+iEk1xWneM5YsAvUfxq8a22p6vB4W02dXttJVlkkQ5Dzn75HqBjH4GuRhvDkYfp70cV8QSnn8lhpXjTUYX7uK1+53XyPOyrK/+E9OotZNy+T2/DU9Q03x8RtDSfrW/p3jpJMAyD868bg1GRcAP+taNnrkqEfvD+dTgOMsdQaTkZ4nI6E1oj26y8Vq+Csv61BrOj6P4jiZ4ZjY3ZB8u7gXgH1Zeh/Q15rpXimVGAMh4rqdF8TLNgGT9a+/yzjGGMShUd/J/1+R85icmlQfNENb+I8Xgp10f4r2E9udv7jV7SMyW9yo/i45VuORj8sgVHY+Kvhn4kiN5ppurqMPgyvaNEgP+/LtUn2BJ9u1dK9voPi3SH8OeJrOO5s5yPlcZ8th0YHsQe9eeeMfDN94R1QaRdHMKp/obquFMfYADhcdCBXdn2fY/K8HHE0oKrTel2tYvopNPVPo7a7PXfHBYPD4mo6cm4z8tmvL9VfQx/H3hSHxxq0V2fFVnp1tbg/Z7S1s5JiCw+ZmYhMsenHHA6jIJUgwRkn9aK/LcTxHicXWdWrTg2/8AF/8AJH0lPCqjBQhJpL0/yPn/AOGHws8G/DHQoPC/hDTYrWMAeddS48yZgOXkfGSf/wBQHaqHj39o34QfDB3gu3l1S7j+8gbZFn8OT+f4U34DeIdZ8WfCDQfEHiG+a5vLqxVrid1ALnJGTgAZ4rQ8S/Cv4deMGaTxL4NsLt2+9I8ADn/gQwa/AcoznKsmx9aWaYVYitzP35PmSto/claMrvrK/ayP06dLD/2nOOYynJJtS5XZtp2er1/FHh/jn/gpL4liSSz8FaPbafFjC+RGAfzxUHwB/af8eeLfCHxF+KUssmveKvDVnaTaPpE2ZPs1o7yC4vUi/jMZEILAfIrk8ZyPSdR/ZW/Z/kcl/hvbc+l1OP5PVnwV+zX8FfBPie08aeEPBraZqtjKJLTULLVLqOWJvYrL3HBHQgkHiv0zA+L+Ew04ucanIk0lFQSjdWTiuZK8d15rofSVa/AdPLZ0sNhJRm+V3ai78slJxb5r2mlyya1s3o9n84aZ/wAFEf2k7zX0utd+KU8di0mbm3+xpIjpnldhGGyOMHA968y+NPxS0j4l/ErVPGfhvwtb6DY30ytDplooVI8Iqltq4VS5BchQFBYgcV95+KPgN8F/GWuS+JPEXwt0Ka9nO6eaPTY4vMbuzLGFDE9yRk1Xh/Zx+AsBzH8IfD/H97TY2/mK8vFeK9DEJwnGpON7rmav/wClO3nZ/kj3cv4t4Qy2ssRhsA6c+Xlahypbp9Lc2q0bV10td3/OO51hlUnfmvZrnUL7wl+w54d1/wCHDukfiPxTqNt8QNRtGxIJoREbKzlYcrEYmklVDwzFjyV4+woPgf8ABi2GIfhN4bH/AHBID/NK1NO8DeCdG0q80PR/B2lWllqGz7fZ22nxJFc7DlfMRVAfBJIyDis8N4rYPDRqJYaT5otX5kmtU+3W1n5NmmZ+IOXY10OXDO1Oam02rSSTVnp0bU47+9GJ+cvwxuPBuseMIdN+IWvnTrC4hmjGoNG7pbzGNhE8gQFjGJNu7aCcdj0rv7D9lf4kajL52h+NfBd7anmO+tvGliY2HrzKCv0IBHcV9nSfCr4XMcN8NtAI99Gg/wDiKq3XwR+DV4Ctz8KPDjZ/6gsA/ktTS8UsttarhJeqmk/xiyMX4hUq1Xnw9NwukmmlNaX1SvBp666tOy0XX5p+IHinwd8GvgBqXwiuPiNpPifxLrr26TQaLci6ttNijlWUu065jaTKBAqFiAz7tvAbybwnrqaZ4B8Q39rNtu7q9sbJiDz9mYTyyL+Lww/ljvX27e/sv/s+6nGUufhLo6g9TBb+UfzQg18+ftKfBL4YfDqzvm8GeGPsXmWjs4W9mcEqykcO5HBr3cv8R8DnGMhQp0pwdnFbNJa7u973b6Hfw5nGQYxvBqFR1Ks1OUmo2bvHonorRSSs/Nt3Z41b6/IEyHr0XQtJv9a+Gmj694ZtWngS5ng1kxDJhvC5ZPMx90PDs2E8EpIByrV4tBLIMKHOM10ngT4jeN/hprH9v+BvElxp1y0flymIhkmTIJSRGBSRMgHawIyBxxX09PEpXjO9pK2m61T+e3kfeZnw7GrSXsLc6d1fZ6NWbWq3vezs0tGe1+CvCPiW41CEy6dKqBwSWjPH419maS2reGf2Z9VW91q00ldV01rGwk1O98mOZ5MKzBfvSBFyxCKx4AANfHFp+158e5rLS4/+Em0qM3FzEkkkHhLTI3wWAOGS2DKcdwQat/tc+PfGfiD9pTxPZ654mvLuLR9Ul07TEuJiwt7aJtiRrn0A5PViSzEkkn2sJmeEyLA1a9LmqSkuSzSilzJ66OTdkttPU/Is54QzHO8yoUMS6dOMb1Lxcpt8koq1nGFruS110T0PWtB8GeCrFV/t39oMSSY+dbLRNyZ9meVWI+qCuu0v4ZWuuof+EB+L9jfXGMx2uo2ptt/+yGV3GfcgD1Ir5CtNX1JmG68c/U12fgHxBrVnrFu9rqUsZ3jlWr4l5hlspWqYSNn/ACymn/6U196a8jrx3DOYU6bnHFttdHCFvwin+J7Vq2u+KvAeuSeHfGGlz2N7EAWhl7qejKRwynswyD2Navh742x6X51jqFubuxvECXlr5mxiAcq6Ng7XU8g4I5IIIJFa/wC1Eq6p+yp4X8YagBLqlt4gW1hvW/1iwyQSu8ee6lkU4PQg4xk5+crPUr47c3THis8zoVMjzGLw824yipRvvaS2l0fVPo10V7Hi5TgsPnuXurVglJSlF2va8Xuuq6NdU+rtc+oNB+IPh+4KzaF8R4rVuiw6rDLBKPbcgeMj3LL9BXSp4z8YahEIJvHmj3EIOQr+KLYL9drSA/pXydDqN8CMXLdfWrn9q6jHAXS7cEDIINRSzak1yunKKe6jNpP1T5jDEcJ05SvGaf8Aiin+XKfWdnrW3C3vxD0C3z2W8km/LykYfrXQaPqPheXBvPigWwORbWIwfxeQH/x2vmv4R+E9C8V/D658SeILaW5vIrp1SVrqRQABwNqsFP5Vn+MIF8P6RYano0ktvNPdlJWSZsMoHTaTgfgK+l5vqOEWJ9jGS5ebWdRu3ycVf5Hz1ThyhXxUsPGs1JOz9yNr2vpu7H2BDe/DHaBceO9Rc+qSxKPy2mmXUvw8uFxZfEm+gPYyxxyj8srXx7F4i1tlBOpy9B/FUsev60Rk6lL1/vV5743i42eEhb1kvxTuc/8AqPUi7rEv7l/kfVdzoOs3YLeGviTol6e0d4ZLZj+OGX/x6sXV9H+NumxmZvAdxexL0k0eeO7BHriJi36V89ad4o8QxuDHq0w+jV3Pgvx94yhkTy/ENwOn8QpU88yjHytUoTg/7k9PumpP8URV4exuDjzKcJr+9Fp/fFpfgzb1n4o6toUph8Q6Pf6ew4K3tm8R/wDHgKpwfGXTpOV1NOeuWr1Twh8RPG11ai3uvEdxLGV5jkIZT+BGK14vCHgvxjcKnibwNoV2X+9JJoluJD/wMIG/WvZocLQzJJ4XEyTfSUF+am/yPKnmeFwraxGHWnWMr/g4r8zyGD4tWEnJv4/++uavW3xQtmAKX6fTdXqniv8AZN/Z9Oj/ANoR/DyOKUrnMGo3MYz9FkA/Svnn4h/DXwb4ev5YtH0yWFUbCj7dM2Pzc1hmnA2fZPFTqV4NPs5frFHVleP4fzqTjRjNNd4x/STPQIPifHjaLpDx61aX4pRxpn7QP++v/r14JY2cP2jy98u3d089/wDGvY/gv8J/Afiy/SDxBo8twhHKnUJ1/wDQXFeblmU53j8QqNGrFPzbt+CZ3Znl+V5bQdWrdpdkr/i0bJ+MVmi/vb5R7eZzV7S/GfinxGufDfhy/vEP/LWG3Yxj6vjaPxNdNqfgDwT8P9QW28JeFbG1wuVma2WWUHHaSTc4/OsTxN4u8SRIxTWJsgYBJBP5mver5JVy2TjjcRJtbqC0+Um//bT5mFbCYuzw1LR7OT/NJf8Atxeg8NfES6USapd6fpqHkrNd+Y+PYRhh+BIpW0jSbMltY8aTSnukESxgfiS38q4XQte1nX/GFtpWr6nNNbyuA8fmFcj6rg175H8MfAOhWMVzY+FrV5GQMXvFNwc/9tS2K9XJMipZ5TnUw0Eowdm6kpOX3RSi/nY48zrvK5whWestUoRSX3ttnniX/gRD5UUU1yR2kumY/wDjmKtJqGlFcWvgqd1x1WCZq9S0m4ksINlgqQL2WGJVH5AYq8mrai2N12xr6WlwdHS9eKflRj+fNc8CpnL5rKm36zf/AMiePv4j0e0TbdeEJYx3LwSDH4mqsnizwBcny2Mts3/TO4PH4NmvcIdRvTyblqS803TNXTy9X0u1ulJ5W5tkkB/76BraXA86sbQrxfrSX5qV0RHPaUZe/Sfym/ycTwLUJY5FMmgeJbeY9orj5G+gOSD+OK5TWPHeraRObbUkaJuoBPDD1B6EfSve/iD8DfhRc+H7jVR4LtoJ40LI9lJJbgH6RMoP5V8iXms6oNcutEa8Z7VZyqwy4cADp97Jz79a/O+LOGsbkE4Kc4rn25XJr5qSuvlJn23DVfCZ1TnKmn7m/Mkn8mm7/NI6u4+J0mCftAH1NZt18UG53XeT/vV5p4huri11Oe3gmZURyFXOcD8axrnUL0jm5bpX5pUx+LjJpy2P0ChkOFlFM9VufintyPtB/OqFx8Vioz55H/Aq8nur+8yR9oasq81G9xn7S1QsbiX9o9Sjw7hWewXPxc2ZzP8AjuqjcfGNhkef+teMXepXwPFy1e0/8E8PC/h/x1+0GbfxhpUWoxafo895aQ3Q3Ik6FNrlejYyeCCM84yK9PJ8PjM4zOjgoT5XUko3d7K/UeaZZgMmyqtjqkeZU4uVlu7dDuJb/wAI/CTwXB8Vv2n/ABPPoOm3ib9E8PWw3anrGBn5Iz/q05HztgcjJXIJ8K+Lv/BRr4qfEO2fwb8LLOLwL4YBKpYaNIRd3CdAZ7jhmJHULtBzzu614B8aviV48+K/xV1rxd8RfFN3q2oNqE0QuLt87I1dgsaKMKiAdFUAD0rP0liep6dK+1qY2OXUXhsBeEdnJ/HP1a2X92Nl35nqfVZRwBgMNCOMzJKtW3St+7h5Qi92v55XlfVKK0O803xBdyzGaeZ3d23OzNksT3JPWuo0jX50IbzDnHrXn+ku2U+btXU6SzNEMnvXyVepJO562Nw9Psdzpniu4ACeaQB71u2HjW5UgCc/TNe/fso/syfA/wAe+EINX8W+BxeXDICztqNymfwWQD9K0P2kv2Z/gj4C8Jzax4S8ECzuEHyuuoXLgfg0hH6V9QuC85eUPMlUhyWva8ub/wBJt+J+SYjjLIJZw8u9lPnva9o2v/4Ff8DxHTvHN2oA88/nXSaV8QZo8BpT+deTWksgk4c8GtexuZ8j96a+Ihjq9OWjPZxWWYeXQ9q0bx2s+EebP41v2clrqE0d1bytFMjBo5YmwVYdwRyDXiukXVwrqBKa7/wje3QdAJj2r6nKc8xCmk9T5PMMshRTlB2PVfEHgPRP2gdHXRfGMkVv4mtotujeIVQKZ8dILjH3gezdR+e7wl/Cms+GdZuPD+uWL293aTGK4hkHKsP5j37ivevBs0pVGLnIwQfSov2odOsW8ZaBqxtU+03+iq15MFwZWU4BPvjjP+FfT8T5VQzbKf7UXu1YOKk/51J2Tf8AeTtr1W+yPm8ozStgMd9R3pyTcV/K1q7dotdOj23Z5RpOlTyYwh9q6zQfClxOy7kP5Vq6ZpthaWBuYLVA6pkEjP6GuW1X4l+N7a8e1sdda2VeFNpDHC2P95FB/Wvko4XAZXCM8Td325Uv1aPTlXxOPlKNGyt3/wCAmenaZ4btfDtqt/r15BYQkZWW8kCbv90Hl/8AgINUfE/xrs7Szk0HwGZB5ilJ9VkGx2XusS9UB/vH5j6LXkkl9e39y11fXck0rnLySuWZj7k8mp4XbA5rTEcV11RdDBQ9lF6XveVvJ6JX8lfzOaOQ03UVTEy5322X3a3/AC8jdjugTndVqK7I71jW7NtzmrcDsep7V8vGZ2zppGxDeD/Jq1DdejVjQu3rVuJmHQ963jNnLOkjZtr9kbg8VuaLrLpIv7z8zXKRM2M5rT0l2MindXo4LEVKdVNHn4ihGcHc9R8Pam8sYy1bnjHTE8WeB5nK7rrTl82Ju5UDkfiB+YFcf4VdsKN3au+8PASWF7G/IazbI9eK/beH7ZlgJ4WtrGpFp/ddP1TSaPgcwX1auqsN4tP8f8jxtJD/AAnP0or0KDQtF0rShf2elW4lCZDSRCTB+jZFFfCy4WeHjH29azav7sbr73KP5HsLMVUbdOGi7u36M//Z\";// 解码到目录// 将图片解码到项目根目录下的 readme 目录中，使用随机串作为图片的文件名File img = FileUtils.decodeBase64ImageStrToDirectory(\"readme\", base64ImageStr);// 解码到目录，并指定图片的文件名File img = FileUtils.decodeBase64ImageStrToDirectory(\"readme\", \"2017.jpg\", base64ImageStr); URL 文件12345678910111213141516171819// 获取 URL 输入流InputStream is = FileUtils.openUrlFile(\"http://www.qncye.com/buttom/images/hk06.jpg\").getInputStream();// 下载到文件FileUtils.openUrlFile(\"http://www.qncye.com/buttom/images/hk06.jpg\").writeToFile(\"readme/2017_1.jpg\");// 下载到目录FileUtils.openUrlFile(\"http://www.qncye.com/buttom/images/hk06.jpg\").writeToDirectory(\"readme\");// 读取文本内容String str = FileUtils.openUrlFile(\"https://www.duitang.com\").readString();// 配置项String str = FileUtils.openUrlFile(\"https://www.duitang.com\") // 设置连接超时时间, 默认为 30秒 .setConnectTimeout(30 * 1000) // 设置读取超时时间, 默认为 3分钟 .setReadTimeout(3 * 60 * 1000) .readString(); 文件下载1234567891011// 提供任意文件下载@RequestMapping(\"/download\")public void downloadFile(HttpServletResponse response) &#123; FileUtils.provideFileDownload(response, new File(\"readme.txt\"));&#125;// 提供任意文件下载，并指定下载的文件名称@RequestMapping(\"/download\")public void downloadFile(HttpServletResponse response) &#123; FileUtils.provideFileDownload(response, new File(\"readme.txt\"), \"读我.txt\");&#125; 本地文件本地文件上传在项目的 web.xml 中添加如下配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;LocalFileUploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileUploadServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileUploadServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件上传的 URL --&gt; &lt;url-pattern&gt;/files/upload&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在 JSP 文件中添加如下代码 ( 以下代码仅做示例用 )： 123456789101112131415161718192021222324252627&lt;!-- JQuery JS --&gt;&lt;script src=\"//cdn.bootcss.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- JQuery 表单异步提交组件 --&gt;&lt;script src=\"//cdn.bootcss.com/jquery.form/3.51/jquery.form.min.js\"&gt;&lt;/script&gt;&lt;!-- 文件上传表单, 支持多文件上传 --&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/files/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;!-- 拷贝多个此节点即可上传多个文件 --&gt; &lt;input type=\"file\" name=\"file\"&gt;&lt;/form&gt;&lt;button&gt;提交&lt;/button&gt;&lt;script&gt; $('button').click(function () &#123; $('form').ajaxSubmit(&#123; dataType: 'json', success: function (result) &#123; console.log(result); if (result.healthy) &#123; alert('本地文件上传成功，Key : ' + result.fileKeys[0]); &#125; else &#123; alert('本地文件上传失败，信息 : ' + result.failedMsgs[0]); &#125; &#125; &#125;); &#125;);&lt;/script&gt; 参数 类型 描述 healthy 布尔 文件上传报告是否健康，若是，表明文件上传全部成功，否则表示存在文件上传失败或空 failedNumber 整型 文件上传失败的个数 successfulNumber 整型 文件上传成功的个数 fileKeys 字符串数组 上传成功的文件 Key 列表，每个 Key 表示本地文件的地址 failedMsgs 字符串数组 文件上传失败的信息列表 可选配置项123456789101112131415161718192021222324252627&lt;servlet&gt; &lt;servlet-name&gt;LocalFileUploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileUploadServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 上传的文件最小大小, 默认0, 表示不限制 --&gt; &lt;param-name&gt;minSize&lt;/param-name&gt; &lt;!-- 1KB --&gt; &lt;param-value&gt;1024&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 上传的文件最大大小, 默认0, 表示不限制 --&gt; &lt;param-name&gt;maxSize&lt;/param-name&gt; &lt;!-- 100KB --&gt; &lt;param-value&gt;102400&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 允许上传的文件类型 --&gt; &lt;param-name&gt;allowedFileExtensions&lt;/param-name&gt; &lt;!-- *.jpg, *.png --&gt; &lt;param-value&gt;jpg,png&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileUploadServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件上传的 URL --&gt; &lt;url-pattern&gt;/files/upload&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 自定义文件上传在 SpringMVC 的 Controller 文件中添加如下代码 ( 以下代码仅做示例用 ) 12345678910111213141516171819202122232425262728293031323334@ResponseBody@RequestMapping(\"/files/upload2\")public FileUploadReport upload(@RequestParam(\"file\") MultipartFile[] files) &#123; // 文件上传 return FileUtils.uploadFile(files) // 设置允许上传的文件大小, 1KB ~ 100KB .setAllowedFileSize(1 * 1024, 100 * 1024) // 设置允许上传的文件类型, *.jpg, *.png .setAllowedFileExtensions(\"jpg\", \"png\") // 当上传的文件大小超出限制时, 通过此功能处理并手工完成上传作业, 处理成功返回 true, 否则需返回 false .setFileSizeSupportedFunction((inputStrean, file) -&gt; &#123; try &#123; // 保持图片比例不变压缩图片大小 Thumbnails.of(inputStrean).scale(1).outputQuality(0.8).toFile(file); return true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false; &#125;) // 当上传的文件是不支持的文件类型时, 通过此功能处理并手工完成上传作业, 处理成功返回 true, 否则需返回 false .setFileExtensionSupportedFunction((inputStrean, file) -&gt; &#123; try &#123; // 其余文件统统转成 jpg 文件 Thumbnails.of(inputStrean).outputFormat(\"jpg\").toFile(file); return true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false; &#125;) // 上传文件 .upload();&#125; 本地文件上传配置本地文件上传的根目录默认使用 Java IO 的目录，建议修改此路径。 在 Spring 配置文件中加入如下代码： 123&lt;!-- 本地文件上传配置 --&gt;&lt;!-- 引入 p 命名空间 xmlns:p=\"http://www.springframework.org/schema/p\" --&gt;&lt;bean class=\"org.fanlychie.commons.file.LocalFileUploadConfig\" p:storageRootFolder=\"C:/fileUplad\"/&gt; 参数 类型 描述 storageRootFolder 字符串 本地上传的文件存储根目录路径, 默认为 Java IO 目录 childFolderLength 字符串 本地上传的文件存储的子目录长度, 默认为 5 本地文件访问在项目的 web.xml 中添加如下配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;LocalFileAccessServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileAccessServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileAccessServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件访问的 URL --&gt; &lt;url-pattern&gt;/files/access&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问示例： http://domain.com/files/access?file=df1cdb878bf44e76b9ea5a4aca7959ea 可选配置项123456789101112131415&lt;servlet&gt; &lt;servlet-name&gt;LocalFileAccessServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileAccessServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 本地文件 Key 参数名称 --&gt; &lt;param-name&gt;fileKeyParameter&lt;/param-name&gt; &lt;!-- 默认参数名为 file, 值即为本地文件上传返回的 Key 字符串 --&gt; &lt;param-value&gt;key&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileAccessServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件访问的 URL --&gt; &lt;url-pattern&gt;/files/access&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问示例： http://domain.com/files/access?key=df1cdb878bf44e76b9ea5a4aca7959ea 自定义文件访问在 SpringMVC 的 Controller 文件中添加如下代码 ( 以下代码仅做示例用 ) 1234@RequestMapping(\"/files/access2\")public void access(HttpServletResponse response, String fileKey) &#123; FileUtils.accessLocalFile(response, fileKey);&#125; http://domain.com/files/access2?fileKey=df1cdb878bf44e76b9ea5a4aca7959ea 本地文件下载在项目的 web.xml 中添加如下配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;LocalFileDownloadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileDownloadServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileDownloadServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件下载的 URL --&gt; &lt;url-pattern&gt;/files/download&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问示例： http://domain.com/files/download?file=df1cdb878bf44e76b9ea5a4aca7959ea 或： http://domain.com/files/download?file=df1cdb878bf44e76b9ea5a4aca7959ea&amp;name=示例文件 可选配置项123456789101112131415161718192021&lt;servlet&gt; &lt;servlet-name&gt;LocalFileDownloadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileDownloadServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 文件 Key 参数的名称 --&gt; &lt;param-name&gt;fileKeyParameter&lt;/param-name&gt; &lt;!-- 默认参数名为 file, 值即为本地文件上传返回的 Key 字符串 --&gt; &lt;param-value&gt;key&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 文件名参数名称, 供下载时使用 --&gt; &lt;param-name&gt;fileNameParameter&lt;/param-name&gt; &lt;!-- 默认参数名为 name, 缺省值为原文件名称 --&gt; &lt;param-value&gt;filename&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileDownloadServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件下载的 URL --&gt; &lt;url-pattern&gt;/files/download&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问示例： http://domain.com/files/download?key=df1cdb878bf44e76b9ea5a4aca7959ea 或： http://domain.com/files/download?key=df1cdb878bf44e76b9ea5a4aca7959ea&amp;filename=示例文件 其他1234567891011121314151617181920212223// 创建本地文件对象LocalFile localFile = FileUtils.createLocalFile(\"jpg\");// 获取 classpath 下的资源文件File file = FileUtils.getClassPathFile(\"spring-mvc.xml\");// 获取 classpath 下的资源文件流InputStream is = FileUtils.getClassPathFileStream(\"spring-mvc.xml\");// 获取文件扩展名, 输出 txtString extension = FileUtils.getFileExtension(\"readme.txt\");// 获取文件大小字符串，输出 100KBString size = FileUtils.getFileSize(102401);// 获取本地文件File src = FileUtils.getLocalFile(\"df1cdb878bf44e76b9ea5a4aca7959ea\");// 获取 URL 文件名称, 输出 hk06.jpgString filename = FileUtils.getUrlFileName(\"http://www.qncye.com/buttom/images/hk06.jpg\");// 获取 URL 文件扩展名, 输出 jpgString fileExtension = FileUtils.getUrlFileExtension(\"http://www.qncye.com/buttom/images/hk06.jpg\"); 调试日志1log4j.logger.org.fanlychie.commons.file.web = DEBUG","tags":[{"name":"开发工具包","slug":"开发工具包","permalink":"http://yoursite.com/tags/开发工具包/"}]},{"title":"Redis 安装和应用","date":"2017-01-15T12:16:32.000Z","path":"post/redis-setup.html","text":"1. 简介Redis是一个开源的，基于键值对的存储系统。它所有的数据都存储在内存中，读写速度远超于硬盘，同时将内存中的数据异步写入硬盘进行持久化。Redis是一个单线程模型，所有的命令是串行执行，在并发的场景下不需要考虑数据的一致性问题。Redis支持的多种不同的数据类型，常用的有：String（字符串） 、Hash（哈希表）、List（列表）、Set（集合）、Zset（有序集合）。可用作NoSQL数据库、高速缓存、消息队列等方面的应用。 2. 安装安装包版本「redis-3.0.6.tar.gz」操 作 系 统「CentOS 7」 解压缩并进入解压缩后的目录： 1$ tar zxvf redis-3.0.6.tar.gz &amp;&amp; cd redis-3.0.6 编译安装： 1# make &amp;&amp; make install 如果报“/bin/sh: cc: command not found”说明缺少gcc编译环境。安装gcc编译环境： 1# yum install gcc重新编译安装：1# make clean &amp;&amp; make &amp;&amp; make install如果报“zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory”编译时需指定MALLOC=libc。重新编译安装：1# make clean &amp;&amp; make MALLOC=libc &amp;&amp; make install 为了方便管理，我们将redis的配置文件移动到一个统一的目录里面。首先创建这个目录： 1# mkdir /usr/local/redis 然后将安装目录下的redis.conf和sentinel.conf文件拷贝到该目录： 1# cp redis.conf sentinel.conf /usr/local/redis/ 3. 配置编辑redis配置文件“redis.conf”： 1# vi /usr/local/redis/redis.conf 修改内容如下： 1234567891011# 是否以守护进程的方式运行daemonize yes## 当redis作为守护进程运行时，它会将pid写入到该参数指定的文件里面pidfile /usr/local/redis/run/redis.pid## 文件保存到磁盘的快照文件的目录路径dir /usr/local/redis/data## 日志文件logfile /usr/local/redis/logs/redis.log 创建上面配置的对应的目录run，data，logs文件夹： 1# mkdir /usr/local/redis/&#123;run,data,logs&#125; 常用的配置项含义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# # # # # # # # # # # # # # # # # # 通用配置 # # # # # # # # # # # # # # # # # ## 是否以守护进程的方式运行（守护进程就是在后台一直运行的进程）daemonize yes## 当redis作为守护进程运行时，它会将pid写入到该参数指定的文件里面pidfile /usr/local/redis/run/redis.pid## 端口port 6379## 当客户端闲置多长时间后断开客户端与服务器之间的链接。0表示禁用此功能timeout 0## 日志级别。# redis提供4种日志级别，它们按从低到高分别是：debug &lt; verbose &lt; notice &lt; warningloglevel notice## 日志文件。默认是标准输出（输出到终端窗口）logfile /usr/local/redis/logs/redis.log## 数据库的数量。默认是使用0号数据库。可以使用select &lt;dbid&gt;命令来使用指定的数据库databases 16# # # # # # # # # # # # # # # # # # RDB 快照配置 # # # # # # # # # # # # # # # # ## 内存中缓存的数据保存到磁盘快照文件的规则（可以配置多个，只要条件满足其中的任意一个）# 配置规则：save &lt;seconds&gt; &lt;changes&gt;# 规则含义：当&lt;seconds&gt;秒内有&lt;changes&gt;个键发生变化时则触发一次持久化# 当900秒内有1个键发生变化时# 当300秒内有10个键发生变化时# 当60秒内有10000个键发生变化时save 900 1save 300 10save 60 10000## 存储到磁盘中的快照文件是否进行压缩# 压缩可以节省磁盘空间，但压缩数据会消耗CPU资源# 不压缩不会额外消耗CPU资源，但占用磁盘空间变大rdbcompression yes## 保存到磁盘的快照文件的文件名dbfilename dump.rdb## 文件保存到磁盘的快照文件的目录路径dir /usr/local/redis/data## # # # # # # # # # # # # # # # # # 主从配置 # # # # # # # # # # # # # # # # # ## 配置语法：slaveof &lt;masterip&gt; &lt;masterport&gt;# 配置该项说明当前服务是一个slave节点。它会根据配置从master节点进行数据同步slaveof 10.10.10.127 6379## 当master节点设置了密码时，当前slave服务连接master时使用的密码masterauth 654321## 配置当前slave节点是否为只读。# 如果配置为no，即可读可写。需要注意的是，写入slave的数据将会在主从同步发生后被清理掉slave-read-only yes## salve会按该值（单位：秒）周期性的向master发送PING包repl-ping-slave-period 10## PING的超时时间（单位：秒）repl-timeout 60## slave的优先级。数值越小，优先级越高# 优先级高的salve将会在master故障后被选中升级为master。如果设置为0，则永远不会被选中slave-priority 100## # # # # # # # # # # # # # # # # # 安全配置 # # # # # # # # # # # # # # # # # ## 密码。如果设置了密码，客户端链接时需要先进行密码验证。requirepass 123456## # # # # # # # # # # # # # # # # # 限制配置 # # # # # # # # # # # # # # # # # ## 同一时间内redis可以接受的客户端连接数的最大值maxclients 10000## # # # # # # # # # # # # # # # # # AOF 配置 # # # # # # # # # # # # # # # # # ## 是否开启AOF日志功能appendonly no## 保存到磁盘的AOF文件的文件名appendfilename appendonly.aof## 日志文件更新的模式。有三种可选值：# no： 让操作系统自行决定同步的时间。这种模式下，redis性能最好# always： 每次写入都同步到日志文件。这种模式下，redis性能慢，但数据最安全# everysec：每秒同步一次。这是性能和数据安全的一个折中模式appendfsync everysec 4. 启动和关闭命令默认的方式启动（按默认的redis.conf配置在前台启动）： 1# redis-server 指定配置文件启动： 1# redis-server /usr/local/redis/redis.conf 关闭服务（redis-cli -p [port] shutdown）： 1# redis-cli -p 6379 shutdown 强行杀死进程可以使用kill -9 [pid]。 5. 开放端口开放防火墙端口： 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 6379 -j ACCEPT 6. 简单应用# pom.xml1234567891011&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 单元测试： 1234567891011121314151617181920212223242526272829303132333435363738public class RedisDemoTest &#123; private JedisPool jedisPool; @Before public void doBefore() &#123; // 链接池配置 JedisPoolConfig poolConfig = new JedisPoolConfig(); // 当没有可用链接时是否阻塞，直到超时 poolConfig.setBlockWhenExhausted(true); // 最大空闲链接数 poolConfig.setMaxIdle(8); // 最小空闲链接数 poolConfig.setMinIdle(4); // 最大链接数 poolConfig.setMaxTotal(8); // 最大等待时间 poolConfig.setMaxWaitMillis(30000); // 获取链接时是否检查可用性 poolConfig.setTestOnBorrow(true); // 链接归还池时是否检查可用性 poolConfig.setTestOnReturn(true); // 链接池 jedisPool = new JedisPool(poolConfig, \"10.10.10.127\", 6379, 5000); &#125; @Test public void doTest() &#123; Jedis jedis = jedisPool.getResource(); if (jedis.exists(\"myname\")) &#123; System.out.println(\"=====&gt; \" + jedis.get(\"myname\")); &#125; else &#123; jedis.set(\"myname\", \"fanlychie\"); &#125; jedis.close(); &#125; &#125; 7. 与Spring集成# pom.xml1234567891011121314151617181920212223242526272829303132&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.12.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.18.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; redis 参数配置： # redis.properties1234567891011121314151617181920# 主机redis.hostName = 10.10.10.127# 端口redis.port = 6379# 数据库redis.database = 0# 当没有可用链接时是否阻塞，直到超时redis.blockWhenExhausted = true# 最大空闲链接数redis.maxIdle = 8# 最小空闲链接数redis.minIdle = 4# 最大链接数redis.maxTotal = 8# 最大等待时间redis.maxWaitMillis = 30000# 获取链接时是否检查可用性redis.testOnBorrow = true# 链接归还池时是否检查可用性redis.testOnReturn = true spring 配置： # spring-context.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:redis.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"org.fanlychie\"/&gt; &lt;!-- redis 链接池配置 --&gt; &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"blockWhenExhausted\" value=\"$&#123;redis.blockWhenExhausted&#125;\"/&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\"/&gt; &lt;property name=\"minIdle\" value=\"$&#123;redis.minIdle&#125;\"/&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.maxTotal&#125;\"/&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.maxWaitMillis&#125;\"/&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.testOnBorrow&#125;\"/&gt; &lt;property name=\"testOnReturn\" value=\"$&#123;redis.testOnReturn&#125;\"/&gt; &lt;/bean&gt; &lt;!-- redis 链接配置 --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"poolConfig\" ref=\"poolConfig\"/&gt; &lt;property name=\"hostName\" value=\"$&#123;redis.hostName&#125;\"/&gt; &lt;property name=\"port\" value=\"$&#123;redis.port&#125;\"/&gt; &lt;property name=\"database\" value=\"$&#123;redis.database&#125;\"/&gt; &lt;/bean&gt; &lt;!-- redis 字符串序列化 --&gt; &lt;bean id=\"stringRedisSerializer\" class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; &lt;!-- redis 对象转为json串序列化 --&gt; &lt;bean id=\"jsonRedisSerializer\" class=\"org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer\"&gt; &lt;constructor-arg name=\"mapper\"&gt; &lt;bean class=\"com.fasterxml.jackson.databind.ObjectMapper\"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- redis 模板 --&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;property name=\"keySerializer\" ref=\"stringRedisSerializer\"/&gt; &lt;property name=\"valueSerializer\" ref=\"jsonRedisSerializer\"/&gt; &lt;property name=\"hashKeySerializer\" ref=\"stringRedisSerializer\"/&gt; &lt;property name=\"hashValueSerializer\" ref=\"jsonRedisSerializer\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 单元测试： 1234567891011121314151617181920@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"/spring-context.xml\")public class RedisSpringDemoTest &#123; @Autowired private RedisTemplate redisTemplate; @Test public void doTest() &#123; if (redisTemplate.hasKey(\"myinfo\")) &#123; System.out.println(\"=====&gt; \" + redisTemplate.opsForValue().get(\"myinfo\")); &#125; else &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"fanlychie\"); map.put(\"mail\", \"fanlychie@yeah.net\"); redisTemplate.opsForValue().set(\"myinfo\", map); &#125; &#125; &#125;","tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"CAS 实现 SSO 单点登录","date":"2016-10-24T16:47:29.000Z","path":"post/java-cas-server-client-configure.html","text":"环境 cas-server-4.1.8，cas-client-3.4.0，Java-8，Maven-3，Tomcat-7.0.72 CAS Server 安装 点此进入 CAS 下载列表，选择下载 cas-4.1.8.zip。 解压缩 cas-4.1.8.zip 并进入 cas-server-webapp 目录，在当前目录打开 cmd 并执行安装命令 1mvn -e -ff clean install -Dmaven.test.skip=true 经亲身测试（自己拉的电信12M网络），该安装过程非常漫长，主要因为镜像原因导致依赖包下载非常慢，此过程需静心等待。或直接下载我已经打好包的 cas.war 文件（注：该文件的依赖包版本有稍做修改，此不影响正常使用）。 安装完成后，在 cas-server-webapp/target 目录下可以看到 cas.war 文件，该文件便是 cas server 应用服务的 war 包。 cas server 安全认证是基于 https 的，这里使用 JDK 自带的 keytool 工具生成数字证书，生产环境系统的应用需要到证书提供商处购买证书。证书的生成及 Tomcat 的配置可参考文章：keytool 生成数字证书 - tomcat https 配置 。 首先确保 tomcat 的 https 可以正常访问，将 cas.war 文件拷贝到 apache-tomcat-7.0.72/webapps 下进行发布，启动 tomcat，访问 https://www.fanlychie.com:8443/cas 上图是用火狐浏览器打开的链接，选择高级 -&gt; 添加例外 -&gt; 确认安全例外 用户名和密码在 apache-tomcat-7.0.72/webapps/cas/WEB-INF/deployerConfigContext.xml 配置文件中，找到并打开该文件，大概在 105 行 12345678&lt;bean id=\"primaryAuthenticationHandler\" class=\"org.jasig.cas.authentication.AcceptUsersAuthenticationHandler\"&gt; &lt;property name=\"users\"&gt; &lt;map&gt; &lt;entry key=\"casuser\" value=\"Mellon\" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 可以看到默认的用户名是 casuser，密码是 Mellon。 看到上图的页面，表明 cas server 已经部署成功。 CAS Server 配置基于数据库用户认证 回到 cas-4.1.8.zip 解压缩的目录，并进入 cas-server-support-jdbc 目录，在当前目录打开 cmd 并执行安装命令 1mvn -e -ff clean install -Dmaven.test.skip=true 安装完成后在 target 目录得到 cas-server-support-jdbc-4.1.8.jar 文件。 将该文件拷贝到 apache-tomcat-7.0.72/webapps/cas/WEB-INF/lib 目录下，并向此目录添加 c3p0-0.9.1.2.jar，mysql-connector-java-5.1.17.jar 两个文件。嫌麻烦的话，点此下载这三个 jar 包的压缩包文件。 再次打开 apache-tomcat-7.0.72/webapps/cas/WEB-INF/deployerConfigContext.xml 文件，大概在第 54 行 12345678910111213141516171819202122232425262728293031323334353637&lt;bean id=\"authenticationManager\" class=\"org.jasig.cas.authentication.PolicyBasedAuthenticationManager\"&gt; &lt;constructor-arg&gt; &lt;map&gt; &lt;!-- | IMPORTANT | Every handler requires a unique name. | If more than one instance of the same handler class is configured, you must explicitly | set its name to something other than its default name (typically the simple class name). --&gt; &lt;entry key-ref=\"proxyAuthenticationHandler\" value-ref=\"proxyPrincipalResolver\" /&gt; &lt;!-- 注销此项 &lt;entry key-ref=\"primaryAuthenticationHandler\" value-ref=\"primaryPrincipalResolver\" /&gt; --&gt; &lt;!-- 添加此项 --&gt; &lt;entry key-ref=\"myAuthenticationHandler\" value-ref=\"primaryPrincipalResolver\" /&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;!-- Uncomment the metadata populator to capture the password. &lt;property name=\"authenticationMetaDataPopulators\"&gt; &lt;util:list&gt; &lt;bean class=\"org.jasig.cas.authentication.CacheCredentialsMetaDataPopulator\"/&gt; &lt;/util:list&gt; &lt;/property&gt; --&gt; &lt;!-- | Defines the security policy around authentication. Some alternative policies that ship with CAS: | | * NotPreventedAuthenticationPolicy - all credential must either pass or fail authentication | * AllAuthenticationPolicy - all presented credential must be authenticated successfully | * RequiredHandlerAuthenticationPolicy - specifies a handler that must authenticate its credential to pass --&gt; &lt;property name=\"authenticationPolicy\"&gt; &lt;bean class=\"org.jasig.cas.authentication.AnyAuthenticationPolicy\" /&gt; &lt;/property&gt;&lt;/bean&gt; 按以上配置注销掉第二个 entry 并添加一个 entry。接着在后面添加两个 bean 配置 1234567891011121314151617181920&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://127.0.0.1:3306/cas_test_db?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8\" /&gt; &lt;property name=\"user\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"initialPoolSize\" value=\"10\" /&gt; &lt;property name=\"maxIdleTime\" value=\"1800\" /&gt; &lt;property name=\"maxPoolSize\" value=\"60\" /&gt; &lt;property name=\"acquireIncrement\" value=\"5\" /&gt; &lt;property name=\"acquireRetryAttempts\" value=\"60\" /&gt; &lt;property name=\"acquireRetryDelay\" value=\"2000\" /&gt; &lt;property name=\"breakAfterAcquireFailure\" value=\"false\" /&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\" /&gt; &lt;property name=\"checkoutTimeout\" value=\"30000\" /&gt; &lt;property name=\"idleConnectionTestPeriod\" value=\"900\" /&gt;&lt;/bean&gt;&lt;bean id=\"myAuthenticationHandler\" class=\"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler\" p:dataSource-ref=\"dataSource\" p:sql=\"SELECT passwd FROM user WHERE name = ?\" /&gt; 其中 cas_test_db 数据库中的 user 建表语句为 123456CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `passwd` varchar(255) NOT NULL, PRIMARY KEY (`id`)) 重启 tomcat，访问 https://www.fanlychie.com:8443/cas，用数据库中的 name/passwd 作为用户名和密码登录系统，若登录成功，表明配置已成功。 CAS Client 客户端使用和配置 使用 maven 创建两个 web 项目 cas-client1，cas-client2。点此下载 demo 文件。 cas-client1 项目 pom.xml 配置 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8881&lt;/port&gt; &lt;httpsPort&gt;8081&lt;/httpsPort&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;protocol&gt;org.apache.coyote.http11.Http11NioProtocol&lt;/protocol&gt; &lt;clientAuth&gt;false&lt;/clientAuth&gt; &lt;keystoreFile&gt;C:\\Users\\fanlychie\\.keystore\\selfissue.jks&lt;/keystoreFile&gt; &lt;keystorePass&gt;123654&lt;/keystorePass&gt; &lt;keystoreType&gt;JKS&lt;/keystoreType&gt; &lt;url&gt;http://localhost:8081/manager/html&lt;/url&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 首先必须确保项目 https 协议可以正常访问，否则 cas server 无法认证。 选中项目 -&gt; Run As -&gt; Maven build… -&gt; tomcat7:run 访问 https://www.fanlychie.com:8081，若能访问到，表明 tomcat 已准备好。 cas-client1 项目 web.xml 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;!-- 此处配置的是 cas server 地址 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;!-- 此处配置的是 cas server 登录地址 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8443/cas/login&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;!-- 此处配置的是当前项目地址, 且必须使用 https 服务, 否则 cas server 无法认证 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8081&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;!-- 此处配置的是 cas server 地址 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;!-- 此处配置的是当前项目地址, 且必须使用 https 服务, 否则 cas server 无法认证 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8081&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 以上是 cas client 标准配置，具体信息可参考 https://github.com/apereo/java-cas-client cas-client2 配置基本与 cas-client1 配置相同，详情可见 demo，同时启动这两个项目 cas-client1 - https://www.fanlychie.com:8081 cas-client2 - https://www.fanlychie.com:8082 访问其中的一个项目 https://www.fanlychie.com:8081，会自动跳到 https://www.fanlychie.com:8443/cas/login?service=https%3A%2F%2Fwww.fanlychie.com%3A8081%2F 由于还没有登录过 CAS 认证系统，CAS 认证系统拦截到你的访问，进入到认证系统登录界面，当登录成功后，CAS 服务会跳转向到你刚刚访问的地址。 当你访问 https://www.fanlychie.com:8082，此时是不需要登录了的 至此，CAS 实现 SSO 单点登录系统搭建结束。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"CAS","slug":"CAS","permalink":"http://yoursite.com/tags/CAS/"}]},{"title":"keytool 生成数字证书 - tomcat https 配置","date":"2016-10-24T06:36:59.000Z","path":"post/java-keytool-tomcat-https.html","text":"环境 Java8 + Tomcat7 + Windows10 生成证书 Win + R 打开 cmd，接下来使用 JDK 自带的 keytool 工具生成数字证书，首先查看命令参数 1C:\\Users\\fanlychie\\.keystore&gt;keytool -genkey -help 创建一个存放密钥库的目录，并进入此目录 12C:\\Users\\fanlychie&gt;md .keystoreC:\\Users\\fanlychie&gt;cd .keystore 生成一个密钥库文件 1C:\\Users\\fanlychie\\.keystore&gt;keytool -genkey -alias selfissue -keyalg RSA -keysize 2048 -keypass 123654 -validity 3660 -keystore selfissue.jks -storepass 123654 -alias 设定一个别名，-validity 设定证书的有效天数，-keypass 密钥口令设置和 -storepass 密钥库口令相同，-keystore 设定密钥库名称。 第一处询问 “您的名字与姓氏是什么?“，该处填写的是单点登录服务器的域名。其余项可自由填写。 执行完成后生成的密钥库文件在 C:\\Users\\fanlychie\\.keystore\\selfissue.jks 查看密钥库 1C:\\Users\\fanlychie\\.keystore&gt;keytool -list -keystore selfissue.jks 输入口令 123654 返回上层目录，创建一个存放证书的目录，并进入该目录 123C:\\Users\\fanlychie\\.keystore&gt;cd ..C:\\Users\\fanlychie&gt;md .certificateC:\\Users\\fanlychie&gt;cd .certificate 导出证书 1C:\\Users\\fanlychie\\.certificate&gt;keytool -export -alias selfissue -keystore ../.keystore/selfissue.jks -file selfissue.crt -storepass 123654 执行完成后生成的证书文件在 C:\\Users\\fanlychie\\.certificate\\selfissue.crt 客户端导入证书 1C:\\Users\\fanlychie\\.certificate&gt;keytool -import -keystore %JAVA_HOME%\\jre\\lib\\security\\cacerts -file selfissue.crt -alias selfissue 需要注意的是密钥库口令不是上面生成证书设置的密码 123654，而必须是 changeit Tomcat7 Https 配置 打开 conf/server.xml，找到 1&lt;Connector port=\"8080\" redirectPort=\"8443\" connectionTimeout=\"20000\" protocol=\"HTTP/1.1\"/&gt; 改成 12345678910&lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" maxThreads=\"200\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\" clientAuth=\"false\" sslProtocol=\"TLS\" keystoreFile=\"C:\\Users\\fanlychie\\.keystore\\selfissue.jks\" keystorePass=\"123654\" keystoreType=\"JKS\" /&gt; 配置参数可参考 https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html https://tomcat.apache.org/tomcat-7.0-doc/config/http.html 打开 C:\\Windows\\System32\\drivers\\etc\\hosts（以管理员身份取得该文件所有权限，否则无法编辑该文件），向该文件添加如下一行，并保存退出。 1127.0.0.1 www.fanlychie.com 启动 Tomcat，访问 https://www.fanlychie.com:8443","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Spring+MyBatis 多数据源配置和切换","date":"2016-10-22T12:21:58.000Z","path":"post/spring-mybatis-multiple-datasource.html","text":"环境 两台 MySQL 数据库（属于 master-slave 主从关系），基于 Java8，Spring4，MyBatis3.2 环境。 maven 依赖配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjlib&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; jdbc.properties 配置 12345678910111213141516171819202122jdbc.driver = com.mysql.jdbc.Driverjdbc.key.slave = slavejdbc.username.slave = rootjdbc.password.slave = rootjdbc.url.slave = jdbc:mysql://192.168.1.104:3306/test_db?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8jdbc.key.master = masterjdbc.username.master = rootjdbc.password.master = rootjdbc.url.master = jdbc:mysql://192.168.1.102:3306/test_db?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8c3p0.initialPoolSize = 10c3p0.maxIdleTime = 1800c3p0.maxPoolSize = 60c3p0.acquireIncrement = 5c3p0.acquireRetryAttempts = 60c3p0.acquireRetryDelay = 2000c3p0.breakAfterAcquireFailure = falsec3p0.autoCommitOnClose = falsec3p0.checkoutTimeout = 30000c3p0.idleConnectionTestPeriod = 900 spring-datasources.xml 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"&gt; &lt;!-- aspectj 注解 --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=\"org.fanlychie\" /&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"baseDataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"initialPoolSize\" value=\"$&#123;c3p0.initialPoolSize&#125;\" /&gt; &lt;property name=\"maxIdleTime\" value=\"$&#123;c3p0.maxIdleTime&#125;\" /&gt; &lt;property name=\"maxPoolSize\" value=\"$&#123;c3p0.maxPoolSize&#125;\" /&gt; &lt;property name=\"acquireIncrement\" value=\"$&#123;c3p0.acquireIncrement&#125;\" /&gt; &lt;property name=\"acquireRetryAttempts\" value=\"$&#123;c3p0.acquireRetryAttempts&#125;\" /&gt; &lt;property name=\"acquireRetryDelay\" value=\"$&#123;c3p0.acquireRetryDelay&#125;\" /&gt; &lt;property name=\"breakAfterAcquireFailure\" value=\"$&#123;c3p0.breakAfterAcquireFailure&#125;\" /&gt; &lt;property name=\"autoCommitOnClose\" value=\"$&#123;c3p0.autoCommitOnClose&#125;\" /&gt; &lt;property name=\"checkoutTimeout\" value=\"$&#123;c3p0.checkoutTimeout&#125;\" /&gt; &lt;property name=\"idleConnectionTestPeriod\" value=\"$&#123;c3p0.idleConnectionTestPeriod&#125;\" /&gt; &lt;/bean&gt; &lt;!-- slave 从库只读数据源 --&gt; &lt;bean id=\"slaveDataSource\" parent=\"baseDataSource\"&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url.slave&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username.slave&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password.slave&#125;\" /&gt; &lt;/bean&gt; &lt;!-- master 主库读写数据源(主要负责写操作) --&gt; &lt;bean id=\"masterDataSource\" parent=\"baseDataSource\"&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url.master&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username.master&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password.master&#125;\" /&gt; &lt;/bean&gt; &lt;!-- 多数据源自动切换 --&gt; &lt;bean id=\"dataSource\" class=\"org.fanlychie.core.MultipleDataSource\"&gt; &lt;property name=\"targetDataSources\"&gt; &lt;map key-type=\"java.lang.String\"&gt; &lt;entry key=\"$&#123;jdbc.key.slave&#125;\" value-ref=\"slaveDataSource\" /&gt; &lt;entry key=\"$&#123;jdbc.key.master&#125;\" value-ref=\"masterDataSource\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 默认使用的数据源 --&gt; &lt;!-- &lt;property name=\"defaultTargetDataSource\" ref=\"masterDataSource\"/&gt; --&gt; &lt;/bean&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"typeAliasesPackage\" value=\"org.fanlychie.entity\" /&gt; &lt;/bean&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"org.fanlychie.mapper\" /&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 配置使用 slave 数据源的业务方法前缀列表 --&gt; &lt;util:list id=\"useSlaveDataSourceMethodPrefix\"&gt; &lt;value&gt;select&lt;/value&gt; &lt;/util:list&gt; &lt;!-- 配置使用 master 数据源的业务方法前缀列表 --&gt; &lt;util:list id=\"useMasterDataSourceMethodPrefix\"&gt; &lt;value&gt;insert&lt;/value&gt; &lt;value&gt;update&lt;/value&gt; &lt;value&gt;delete&lt;/value&gt; &lt;/util:list&gt; &lt;bean class=\"org.fanlychie.core.MultipleDataSourceAspect\" /&gt; &lt;bean class=\"org.fanlychie.core.MultipleDataSourceContext\" /&gt;&lt;/beans&gt; 基于 AbstractRoutingDataSource 和 AOP 实现多数据源自动切换 1234567891011121314151617181920212223242526272829import org.springframework.beans.factory.annotation.Value;public class MultipleDataSourceContext &#123; public static String slave; public static String master; private static final ThreadLocal&lt;String&gt; context = new ThreadLocal&lt;&gt;(); public static void setKey(String name) &#123; context.set(name); &#125; public static String getKey() &#123; return context.get(); &#125; @Value(\"$&#123;jdbc.key.slave&#125;\") void setSlave(String slave) &#123; MultipleDataSourceContext.slave = slave; &#125; @Value(\"$&#123;jdbc.key.master&#125;\") void setMaster(String master) &#123; MultipleDataSourceContext.master = master; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334import java.util.List;import javax.annotation.Resource;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before; @Aspectpublic class MultipleDataSourceAspect &#123; @Resource private List&lt;String&gt; useSlaveDataSourceMethodPrefix; @Resource private List&lt;String&gt; useMasterDataSourceMethodPrefix; @Before(\"execution(* org.fanlychie.service.*.*(..))\") public void before(JoinPoint point) &#123; String method = point.getSignature().getName(); boolean useSlave = useSlaveDataSourceMethodPrefix.stream().anyMatch(i -&gt; method.startsWith(i)); if (useSlave) &#123; MultipleDataSourceContext.setKey(MultipleDataSourceContext.slave); System.out.println(\"--- slave ---\"); return ; &#125; boolean useMaster = useMasterDataSourceMethodPrefix.stream().anyMatch(i -&gt; method.startsWith(i)); if (useMaster) &#123; MultipleDataSourceContext.setKey(MultipleDataSourceContext.master); System.out.println(\"--- master ---\"); return ; &#125; throw new UnsupportedOperationException(\"can not match datasource for method '\" + method + \"'\"); &#125;&#125; 12345678910import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class MultipleDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return MultipleDataSourceContext.getKey(); &#125;&#125; 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Date;public class User &#123; private Integer id; private String sex; private String name; private Date createTime; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; @Override public String toString() &#123; return \"User [id=\" + id + \", sex=\" + sex + \", name=\" + name + \", createTime=\" + createTime + \"]\"; &#125; &#125; mapper 配置文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.fanlychie.mapper.UserMapper\"&gt; &lt;resultMap id=\"UserResultMap\" type=\"org.fanlychie.entity.User\"&gt; &lt;id property=\"id\" column=\"ID\" /&gt; &lt;result property=\"sex\" column=\"SEX\" /&gt; &lt;result property=\"name\" column=\"NAME\" /&gt; &lt;result property=\"createTime\" column=\"CREATE_TIME\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectList\" resultMap=\"UserResultMap\"&gt; SELECT * FROM USER ORDER BY ID &lt;/select&gt; &lt;insert id=\"insert\" useGeneratedKeys=\"true\" keyProperty=\"id\" parameterType=\"User\"&gt; INSERT INTO USER (ID, NAME, SEX, CREATE_TIME) VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;sex&#125;, #&#123;createTime&#125;) &lt;/insert&gt;&lt;/mapper&gt; mapper 接口 123456789101112package org.fanlychie.mapper;import java.util.List;import org.fanlychie.entity.User;public interface UserMapper &#123; public int insert(User user); public List&lt;User&gt; selectList(); &#125; service 接口 12345678910import java.util.List;import org.fanlychie.entity.User;public interface UserService &#123; boolean insert(User user); List&lt;User&gt; selectList(); &#125; service 实现类 123456789101112131415161718192021222324import java.util.List;import org.fanlychie.entity.User;import org.fanlychie.mapper.UserMapper;import org.fanlychie.service.UserService;import org.springframework.stereotype.Service;import org.springframework.beans.factory.annotation.Autowired;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper mapper; @Override public boolean insert(User user) &#123; return mapper.insert(user) == 1; &#125; @Override public List&lt;User&gt; selectList() &#123; return mapper.selectList(); &#125;&#125; Junit 测试 123456789101112131415161718192021222324252627282930import java.util.Date;import org.fanlychie.entity.User;import org.fanlychie.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"/spring-datasources.xml\")public class JTest &#123; @Autowired private UserService userService; @Test public void doTest() &#123; User user = new User(); user.setName(\"李四\"); user.setSex(\"男\"); user.setCreateTime(new Date()); boolean success = userService.insert(user); if (success) &#123; System.out.println(\"保存数据成功\"); &#125; userService.selectList().forEach(u -&gt; System.out.println(u)); &#125; &#125; 测试结果 12345--- master ---保存数据成功--- slave ---User [id=1, sex=男, name=张三, createTime=Thu Oct 20 05:04:59 CST 2016]User [id=2, sex=男, name=李四, createTime=Sat Oct 22 21:27:30 CST 2016]","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"MySQL 主从配置 - 实现读写分离","date":"2016-10-20T08:41:01.000Z","path":"post/mysql-master-slave.html","text":"环境 两台 CentOS 6.5 测试机，均已安装 MySQL 5.6 服务。选取其中一台作为主（master），另外一台作为从（salve）服务。 主：192.168.1.102 从：192.168.1.104 主（master）配置 主库负责写操作（INSERT，UPDATE，DELETE），设置 InnoDB 为默认存储引擎，编辑 my.cnf 1# vi /etc/my.cnf 在 [mysqld] 后面加上 12345default-storage-engine=InnoDB // InnoDB 为行级锁, 支持事务, 并发写入性能比 MyISAM 好server-id=102 // 只要主从不一样即可, 通常取IP的最后一段log_bin=master-log-bin // 开启二进制日志, 同步的原理是salve从master同步日志并在slave本地执行一次binlog_do_db=test_db // 需要做同步的数据库名字, 多个配置多行binlog-ignore-db=mysql // 不需要做同步的数据库名, 多个配置多行 重启 MySQL 服务 1# service mysqld restart 在主库创建复制权限的用户 1mysql&gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO salveusr@'%' IDENTIFIED BY 'salveusr'; 从（slave）配置 从库负责读操作，设置 MyISAM 为默认存储引擎，编辑 my.cnf 1# vi /etc/my.cnf 在 [mysqld] 后面加上 1234default-storage-engine=MyISAM // MyISAM 查询速度比 InnoDB 快一些server-id=104replicate-do-db=test_dbreplicate-ignore-db=mysql 重启 MySQL 服务 1# service mysqld restart 在从库执行 12mysql&gt; CHANGE MASTER TO MASTER_HOST='192.168.1.102', MASTER_USER='salveusr', MASTER_PASSWORD='salveusr';mysql&gt; start slave; 准备测试的 SQL 在主从服务器分别创建 test_db 数据库 1CREATE DATABASE test_db DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 在主从服务器 test_db 数据库中分别创建 user 表 1234567CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `sex` varchar(255) NOT NULL, `create_time` datetime NOT NULL, PRIMARY KEY (`id`)) JDBC 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.time.LocalDateTime;import java.time.ZoneId;import java.util.Date;public class Test &#123; private static final String USERNAME = \"root\"; private static final String PASSWORD = \"root\"; private static final String SLAVE_URL = \"jdbc:mysql://192.168.1.104:3306/test_db?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8\"; private static final String MASTER_URL = \"jdbc:mysql://192.168.1.102:3306/test_db?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8\"; public static void main(String[] args) throws SQLException &#123; // 先查询一次, 查询使用的是 slave 数据源 select(); // 插入一条数据, 插入使用的是 master 数据源 insert(\"张三\", \"男\"); // 再次查询, 有一条数据, 该数据便是上面 master 数据源插入的数据 select(); &#125; // 查询 public static void select() throws SQLException &#123; try (Connection conn = getSlaveConnection()) &#123; String sql = \"SELECT * FROM USER\"; try (PreparedStatement stmt = conn.prepareStatement(sql)) &#123; try (ResultSet rs = stmt.executeQuery()) &#123; while (rs.next()) &#123; int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String sex = rs.getString(\"sex\"); Date createTime = rs.getTimestamp(\"create_time\"); LocalDateTime datetime = createTime.toInstant().atZone(ZoneId.systemDefault()) .toLocalDateTime(); System.out.println(id + \"\\t\" + name + \"\\t\" + sex + \"\\t\" + datetime); &#125; System.out.println(\"--- 查询结束 ---\"); &#125; &#125; &#125; &#125; // 插入 public static void insert(String name, String sex) throws SQLException &#123; try (Connection conn = getMasterConnection()) &#123; String sql = \"INSERT INTO USER(id, name, sex, create_time) VALUES(null, ?, ?, now())\"; try (PreparedStatement stmt = conn.prepareStatement(sql)) &#123; stmt.setString(1, name); stmt.setString(2, sex); stmt.executeUpdate(); &#125; &#125; &#125; // slave 连接 public static Connection getSlaveConnection() throws SQLException &#123; return DriverManager.getConnection(SLAVE_URL, USERNAME, PASSWORD); &#125; // master 连接 public static Connection getMasterConnection() throws SQLException &#123; return DriverManager.getConnection(MASTER_URL, USERNAME, PASSWORD); &#125; static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试结果 123--- 查询结束 ---1 张三 男 2016-10-20T05:04:59--- 查询结束 ---","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Java Http 工具类","date":"2016-09-26T00:58:05.000Z","path":"post/java-http-util.html","text":"开发环境 基于 JAVA-8，HttpClient-4.5.2 开发，源码地址见 HttpUtils.java 发送 Http 请求 工具类提供了常用的 GET，POST，PUT，DELETE 方法请求 12345678// GET 请求HttpUtils.get(\"http://www.duitang.com\")...// PUT 请求HttpUtils.put(\"http://www.duitang.com\")...// POST 请求HttpUtils.post(\"http://www.duitang.com\")...// DELETE 请求HttpUtils.delete(\"http://www.duitang.com\")... 可选配置项 以下 set 方法都是可选的配置项，下面设定的都是它们的原始默认数值。 1234567891011// GET 请求HttpUtils.get(\"http://www.duitang.com\") // 设置连接超时时间 .setConnectTimeoutSecond(60) // 设置读取超时时间 .setReadTimeoutSecond(120) // 设置失败重试次数 .setRetryTimes(3) // 设置读取结果使用的字符集编码 .setReadResultCharset(\"UTF-8\") ... 设置代理 通过 setProxy(host, port, schema) 可设置代理，schema 的可选值为 http 或 https，默认为 http。若为 HTTP 的代理，可直接通过调用 setProxy(host, port) 来设置代理。 12345// GET 请求HttpUtils.get(\"http://www.duitang.com\") // 设置代理 .setProxy(\"122.96.59.106\", 80, \"http\") ... 设置请求参数 通过 addParam(String, Object) 可设置请求的参数 12345// GET 请求HttpUtils.get(\"http://www.duitang.com/search/\") // 请求参数 .addParam(\"type\", \"feed\").addParam(\"kw\", \"插画\") ... 或者通过 setParams(Object…) 来设置请求的参数 12345// GET 请求HttpUtils.get(\"http://www.duitang.com/search/\") // 请求参数 .setParams(\"type\", \"feed\", \"kw\", \"插画\") ... 或者通过 setParams(Map) 来设置请求的参数 123456789Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();params.put(\"type\", \"feed\");params.put(\"kw\", \"插画\");// GET 请求HttpUtils.get(\"http://www.duitang.com/search/\") // 请求参数 .setParams(params) .... JSON 参数的请求可以通过 setBody(String) 来设置 12345// GET 请求HttpUtils.get(\"http://www.duitang.com/search/\") // 请求参数 .setBody(\"&#123;\\\"kw\\\":\\\"插画\\\",\\\"type\\\":\\\"feed\\\"&#125;\") ... 设置请求头参数 请求头参数的设值与请求参数的设值相似，如： 12345// GET 请求HttpUtils.get(\"http://www.duitang.com\") // 请求头参数 .setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36 SE 2.X MetaSr 1.0\") ... 执行 HTTP 请求 通过调用 execute(BiConsumer&lt;Integer, String&gt;) 方法来执行 HTTP 请求。 其中，第一个参数为 HTTP 请求结果的状态码值，第二个参数为 HTTP 请求结果的文本内容。一个完整的示例： 1234567HttpUtils.get(\"http://www.duitang.com\").execute((status, response) -&gt; &#123; if (status == 200) &#123; System.out.println(response); &#125; else &#123; System.out.println(\"--- 请求失败 ---\"); &#125;&#125;);","tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"Eclipse PyDev 插件离线安装和配置","date":"2016-09-21T07:35:05.000Z","path":"post/eclipse-pydev-install.html","text":"目前 PyDev 最新版本为 5.2.0，点此下载 PyDev 5.2.0.zip。 下载完成后解压缩 features 和 plugins 两个文件夹的内容到 Eclipse 安装路径下的 features 和 plugins 目录中，重启 Eclipse。打开 Window -&gt; Preferences -&gt; PyDev -&gt; Interpreters -&gt; Python 点击右上侧的 New，在弹出的窗口中点击 Browse，并选到 Python 安装目录下的 python.exe 文件，点击 OK 在弹出的窗口中直接点击 OK 回到主面板点击 OK 创建一个 Python 项目，New -&gt; Other -&gt; PyDev -&gt; PyDev Project 在 src 目录下新建一个 hello.py 文件 1print('Hello World!') 选中 hello.py 右键 Run As -&gt; Python Run，即可看到结果。","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://yoursite.com/tags/Eclipse/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Java8 Map 新增方法","date":"2016-09-21T01:19:10.000Z","path":"post/java8-map.html","text":"Java8 中的 Map 接口新增了一批由 default 声明的默认方法。以下示例中列举了 getOrDefault(Object, V) putIfAbsent(K, V) remove(Object, Object) replace(K, V) replace(K, V, V) replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt;) forEach(BiConsumer&lt;? super K, ? super V&gt;) compute(K, BiFunction&lt;? super K, ? super V, ? extends V&gt;) Map.Entry.comparingByValue() / Map.Entry.comparingByKey() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private static Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();private static Map&lt;String, Integer&gt; unsorted = new HashMap&lt;&gt;();static &#123; map.put(\"Paris\", \"巴黎\"); map.put(\"London\", \"伦敦\"); map.put(\"NewYork\", \"纽约\"); unsorted.put(\"a\", 2); unsorted.put(\"b\", 1); unsorted.put(\"c\", 3);&#125;public static void main(String[] args) &#123; // Java8 以前, 根据 Key 获取值, 若没有匹配的项, 则返回 null Object hk1 = map.get(\"HongKong\"); // null // 根据 Key 获取值, 若没有匹配的项, 则返回 defaultValue Object hk2 = map.getOrDefault(\"HongKong\", \"香港\"); // 香港 // 遍历 map.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // London = 伦敦 // NewYork = 纽约 // Paris = 巴黎 // 当 key 匹配的项不存在或为 null 时, 则执行 put 并返回 null Object result1 = map.putIfAbsent(\"HongKong\", \"香港\"); // null // 当 key 匹配的项存在且不为 null 时, 则直接返回该项的值 Object result2 = map.putIfAbsent(\"HongKong\", \"香干\"); // 香港 // 若 key 或 value 其中的一个不匹配时, 则直接返回 false boolean bool1 = map.remove(\"HongKong\", \"香干\"); // false // 当 key 和 value 同时匹配时, 则执行 remove 并返回 true boolean bool2 = map.remove(\"HongKong\", \"香港\"); // true // 当 key 匹配的项不存在时, 则直接返回 null Object value1 = map.replace(\"HongKong\", \"香港\"); // null // 当 key 匹配的项存在时, 用 value 替换之前的值, 并返回替换之前的值 Object value2 = map.replace(\"NewYork\", \"纽约！纽约\"); // 纽约 // 与新增的 remove 方法类似, key 和 value 同时匹配时才替换 boolean bool3 = map.replace(\"Paris\", \"巴黎\", \"巴黎！巴黎\"); // 全部替换 map.replaceAll((k, v) -&gt; k + \", \" + v); // 输出替换后的结果 map.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // London = London, 伦敦 // NewYork = NewYork, 纽约！纽约 // Paris = Paris, 巴黎！巴黎 // 简而言之, replace 规则 : 存在则替换 // 只要 BiFunction 函数产生 non-null 值, 皆执行 put 操作, 并返回该结果 Object obj1 = map.compute(\"HongKong\", (k, v) -&gt; k); // HongKong // 只要 BiFunction 函数产生 null 值, 如果 map 中存在该 key 匹配的项, 执行 remove 移除, 并返回 null Object obj2 = map.compute(\"HongKong\", (k, v) -&gt; null); // null // 未排序之前 unsorted.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // a = 2 // b = 1 // c = 3 // 用于存储排序的结果 Map&lt;String, Integer&gt; sorted = new LinkedHashMap&lt;&gt;(); // 按值自然排序 unsorted.entrySet().stream().sorted(Map.Entry.comparingByValue()).forEach((e) -&gt; sorted.put(e.getKey(), e.getValue())); // 按值自然排序的结果 sorted.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // b = 1 // a = 2 // c = 3 sorted.clear(); // 按值降序排序 unsorted.entrySet().stream().sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()).forEach((e) -&gt; sorted.put(e.getKey(), e.getValue())); // 按值降序排序的结果 sorted.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // c = 3 // a = 2 // b = 1&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 日期时间处理","date":"2016-09-18T06:55:13.000Z","path":"post/java-8-date-time.html","text":"在 Java8 之前，为了得到一个过去或未来的日期时间，我们往往需要组合 Date 和 Calendar 一起使用。不幸的是，这对组合并不那么好使，正所谓谁用谁知道，心照不宣吧。 Java8 中新增了一套全新的日期时间 API，它明确的将日期时间划分为 LocalDate、LocalTime 以及 LocalDateTime，分别用于表示日期、时间和日期时间，并且产生的结果是不可变的和线程安全的。 Month 月份在 Java8 中声明成了枚举类型，增强了代码的可读性和可靠性。 123456789101112131415161718// 枚举类型Month january = Month.JANUARY; // JANUARY// 获取显示的名字String displayName = january.getDisplayName(TextStyle.FULL, Locale.getDefault()); // 一月// 月份+1, 得到的是2月份Month february = january.plus(1); // FEBRUARY// 2月份的天数最少的时候的值int minDaysOfMonth = february.minLength(); // 28// 2月份的天数最多的时候的值int maxDaysOfMonth = february.maxLength(); // 29// 获取2016年2月份的天数int daysOfMonth = february.length(Year.isLeap(2016)); // 29// 获取2月份表示的整数值int februaryValue = february.getValue(); // 2// 月份-2, 得到的是12月份Month december = february.minus(2); // DECEMBER// 用整数值构造月份, 1表示1月份, 4表示4月份...Month april = Month.of(4); // APRIL DayOfWeek 星期在 Java8 中也声明成了枚举类型，增强了代码的可读性和可靠性。 123456789101112// 枚举类型DayOfWeek monday = DayOfWeek.MONDAY; // MONDAY// 获取显示的名字String displayName = monday.getDisplayName(TextStyle.FULL, Locale.getDefault()); // 星期一// 星期+4, 得到的是星期五DayOfWeek friday = monday.plus(4); // FRIDAY// 获取星期五表示的整数值int fridayValue = friday.getValue(); // 5// 星期-2, 得到的是星期三DayOfWeek wednesday = friday.minus(2); // WEDNESDAY// 用整数值构造星期, 1表示星期一, 7表示星期日...DayOfWeek sunday = DayOfWeek.of(7); // SUNDAY LocalDate 用于表示日期，不包含时间和时区，采用标准的 ISO-8601 日历日期表示方法（年-月-日, yyyy-MM-dd），如 2007-12-03 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 当前的日期LocalDate now = LocalDate.now(); // 2016-09-19// 获取年份值int year = now.getYear(); // 2016// 获取月份值int month = now.getMonthValue(); // 9// 获取天数值int dayOfMonth = now.getDayOfMonth(); // 19// 获取今天是今年的第几天int dayOfYear = now.getDayOfYear(); // 263// 获取月份Month currMonth = now.getMonth(); // SEPTEMBER// 获取星期DayOfWeek dayOfWeek = now.getDayOfWeek(); // MONDAY// 是否为闰年boolean leapYear = now.isLeapYear(); // true// 今年有多少天int lengthOfYear = now.lengthOfYear(); // 366// 本月有多少天int lengthOfMonth = now.lengthOfMonth(); // 30// 修改月份为10月LocalDate date1 = now.withMonth(Month.OCTOBER.getValue()); // 2016-10-19// 修改年份为2017年LocalDate date2 = now.withYear(2017); // 2017-09-19// 修改天数为今年的第2天LocalDate date3 = now.withDayOfYear(2); // 2016-01-02// 修改天数为本月的第2天LocalDate date4 = now.withDayOfMonth(2); // 2016-09-02// 天数+1LocalDate date5 = now.plusDays(1); // 2016-09-20// 月份+1LocalDate date6 = now.plusMonths(1); // 2016-10-19// 增加一个星期LocalDate date7 = now.plusWeeks(1); // 2016-09-26// 年份+1LocalDate date8 = now.plusYears(1); // 2017-09-19// 天数-1LocalDate date9 = now.minusDays(1); // 2016-09-18// 月份-1LocalDate date10 = now.minusMonths(1); // 2016-08-19// 减少一个星期LocalDate date11 = now.minusWeeks(1); // 2016-09-12// 年份-1LocalDate date12 = now.minusYears(1); // 2015-09-19// 构造一个日期对象LocalDate date13 = LocalDate.of(2016, Month.OCTOBER, 1); // 2016-10-01// 修改日期LocalDate date14 = now.with(TemporalAdjusters.next(DayOfWeek.MONDAY)); // 2016-09-26// 必须是严格的 yyyy-MM-dd 格式, 否则将抛出 DateTimeParseException 异常LocalDate date15 = LocalDate.parse(\"2016-09-09\");// 自定义解析格式LocalDate date16 = LocalDate.parse(\"2016/09/09\", DateTimeFormatter.ofPattern(\"yyyy/MM/dd\")); 除此之外，用于表示日期的还有 YearMonth（年月），MonthDay（月日），Year（年）。 12345678910111213141516171819202122232425262728// 当前的年月YearMonth yearMonth1 = YearMonth.now(); // 2016-09// 构造一个年月YearMonth yearMonth2 = YearMonth.of(2016, Month.FEBRUARY); // 2016-02// 本月份的天数int lengthOfMonth = yearMonth2.lengthOfMonth(); // 29// ----------------------------------------------------------------------// 当前的月天MonthDay monthDay1 = MonthDay.now(); // --09-19// 构造一个月天MonthDay monthDay2 = MonthDay.of(Month.FEBRUARY, 29); // --02-29// 先后判断boolean bool = monthDay2.isBefore(monthDay1); // true// ----------------------------------------------------------------------// 当前的年份Year year = Year.now(); // 2016// 2014年Year year2014 = Year.of(2014);// 判断是否为闰年boolean leapYear1 = year2014.isLeap(); // false// 判断是否为闰年boolean leapYear2 = Year.isLeap(2016); // true// 获取该年份有多少天int length = year2014.length(); // 365 LocalTime 表示与时区无关的本地时间，不包含日期，采用标准的 ISO-8601 日历时间表示方法：HH:mm，HH:mm:ss，HH:mm:ss.SSS，HH:mm:ss.SSSSSS，HH:mm:ss.SSSSSSSSS对于某个特定的时间，LocalTime 将采用其中的一个能表示它且格式是最短的一个，其余位没有的则隐含为0。如 10:15:30. 用法与 LocalDate 相似： 12345678// 当前时间LocalTime now = LocalTime.now(); // 16:14:15.809// 获取小时int hour = now.getHour(); // 16// 小时+2LocalTime time1 = now.plusHours(2); // 18:14:15.809// 构造时间LocalTime time2 = LocalTime.of(20, 18, 16); // 20:18:16 LocalDateTime 表示与时区无关的本地日期时间，采用标准的 ISO-8601 日历日期时间表示方法，按 ISO-8601 标准，日期和时间的组合表示时，需要在时间前面加一大写字母 T，如2004年5月3日下午5点30分8秒表示成2004-05-03T17:30:08. 用法与 LocalDate 和 LocalTime 相似： 1234567891011121314// 当前日期时间LocalDateTime now = LocalDateTime.now(); // 2016-09-19T16:46:12.988// 转化成日期LocalDate date = now.toLocalDate(); // 2016-09-19// 转化成时间LocalTime time = now.toLocalTime(); // 16:46:12.988// 构造日期时间LocalDateTime datetime1 = LocalDateTime.of(2018, Month.APRIL, 1, 8, 30, 20); // 2018-04-01T08:30:20// 构造日期时间LocalDateTime datetime2 = date.atTime(8, 30, 20); // 2016-09-19T08:30:20// 构造日期时间LocalDateTime datetime3 = time.atDate(LocalDate.of(2016, Month.DECEMBER, 8)); // 2016-12-08T16:46:12.988// 格式化日期时间String formatStr = now.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")); // 2016-09-19 16:46:12","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Stream","date":"2016-09-16T14:44:36.000Z","path":"post/java8-stream.html","text":"Java8 中新引入的 Stream 和以往的 I/O 流是完全不同的两个东西，Java8 中的 Stream 是对集合功能的增强，它结合 Java8 中新引入的 Lambda 表达式，可以使我们编写少量的代码就能够完成一些复杂的功能。 你可以对 Stream 进行两种操作，Intermediate 操作（中间操作）和 Terminal 操作（最终操作）。 Intermediate 操作是将修改后的 Stream 返回给调用方，因此，对一个 Stream 可以使用零个或多个 Intermediate 操作。 Terminal 操作是对 Stream 的最后一个操作，此后，该 Stream 无法再被操作，一个 Stream 只能有一个 Terminal 操作。 forEach Terminal 操作，用于遍历元素。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().forEach(System.out::print); // 135246&#125; filter Intermediate 操作，用于对 Stream 的每个元素进行判断，符合判断的元素才会被留下来。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().filter((i) -&gt; i % 2 == 0).forEach(System.out::print); // 246&#125; sorted Intermediate 操作，用于对 Stream 的元素进行自然排序。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().sorted().forEach(System.out::print); // 123456&#125; map Intermediate 操作，用于将原始 Stream 的每一个元素映射成任意类型的另外一个元素。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().map((i) -&gt; (char)('a' + i)).forEach(System.out::print); // bdfceg&#125; match Terminal 操作，用于判断元素是否满足某种特定的条件。 123456789101112public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); // allMatch : 所有元素符合条件才返回 true boolean result1 = list.stream().allMatch((i -&gt; i % 2 == 0)); // anyMatch : 只要有一个元素符合条件即返回 true boolean result2 = list.stream().anyMatch((i -&gt; i % 2 == 0)); // noneMatch : 所有元素都不符合条件才返回 true boolean result3 = list.stream().noneMatch((i -&gt; i % 2 == 0)); System.out.println(result1); // false System.out.println(result2); // true System.out.println(result3); // false&#125; count Terminal 操作，用于统计 Stream 中元素的总数。 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); long result = list.stream().filter((i) -&gt; i % 2 == 0).count(); System.out.println(result); // 3&#125; limit Intermediate 操作，用于取得 Stream 的前 n 个元素。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().limit(3).forEach(System.out::print); // 135&#125; skip Intermediate 操作，用于跳过 Stream 的前 n 个元素。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().skip(3).forEach(System.out::print); // 246&#125; reduce Terminal 操作，用于依据参数给定的 BinaryOperator 运算规则，将 Stream 中的元素组合起来。 BinaryOperator（二元操作）是一个函数式接口，它继承于 BiFunction（二元函数）。 BiFunction 与 Function 接口非常相似，不同的是，BiFunction 有两个输入参数，而 Function 只有一个参数输入。 BinaryOperator 继承于 BiFunction，其目的仅仅是为了将两个输入参数声明为同一种类型而已。以下为源码片段： 12345678910111213@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; &#123;... ...&#125;@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;... ...&#125; 使用 reduce 对 Stream 中的元素进行求和。 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Integer result = list.stream().reduce(0, (n1, n2) -&gt; n1 + n2); System.out.println(result); // 21&#125; 这里用到 T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); 其中 identity 是作为此次运算的起始值（种子），然后依据 accumulator 提供的运算规则将 Stream 中的元素逐个逐个与前面的组合起来。这相当于： 12345int result = 0; // 参数 identity 指定的起始值for (int item : list) &#123; result += item;&#125;return result; 因为我们给定了起始值，因此我们认为 Stream 中至少存在一个元素，因此它总能返回一个具体的值。 与它非常相似的还有一个方法 Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 由于此方法中没有起始值参数，当 Stream 中没有元素，即空的 Stream，此时会返回一个空的 Optional 对象，以防止 NullPointerException 的发生。这是两者之间的区别。 1234567public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); // 没有起始值, 返回的是 Optional 对象 Optional&lt;Integer&gt; optional = list.stream().reduce((n1, n2) -&gt; n1 + n2); Integer result = optional.get(); System.out.println(result); // 21&#125; min Terminal 操作，是一种特殊的 reduce，由于 Stream 可能是空的，返回值为 Optional。 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Optional&lt;Integer&gt; optional = list.stream().min(Integer::compareTo); Integer result = optional.get(); System.out.println(result); // 1&#125; max Terminal 操作，是一种特殊的 reduce，由于 Stream 可能是空的，返回值为 Optional。 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Optional&lt;Integer&gt; optional = list.stream().max(Integer::compareTo); Integer result = optional.get(); System.out.println(result); // 6&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Optional","date":"2016-09-16T02:38:35.000Z","path":"post/java8-optional.html","text":"Optional 是 Java8 中新引入的一个类，它用于作为一个值可能为 null 或 non-null 的容器对象。如果一个方法的返回值是一个 Optional 类型，这是在向我们表明该方法的返回值可能为 null，调用时需要进行判空处理，这样可以有效的防止 NullPointerException 异常。如果通过调用 Optional.isPresent() 返回 true，则表明结果 non-null，此时可以放心调用 Optional.get() 获得此对象。 of 通过调用 Optional.of 可以构造一个 Optional 对象，参数要求是 non-null 值，否则抛出 NullPointerException 异常。 1234567public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.of(\"foo\"); if (optional.isPresent()) &#123; String result = optional.get(); System.out.println(result); // foo &#125;&#125; ofNullable 通过调用 Optional.ofNullable 可以构造一个 Optional 对象，参数如果是 null 值，则返回一个值为空的 Optional 对象。 1234public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.ofNullable(null); System.out.println(optional.isPresent()); // false&#125; orElse 如果 Optional 对象的值不存在，则返回 orElse 给定的值。 12345public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.ofNullable(null); String result = optional.orElse(\"foo\"); System.out.println(result); // foo&#125; ifPresent 如果 Optional 对象的值存在，则将该值作为参数执行 Consumer。否则，什么事情都不做。 1234public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.of(\"foo\"); optional.ifPresent((s) -&gt; System.out.println(s.length())); // 3&#125; orElseGet 如果 Optional 对象的值存在，则直接返回该值。否则，调用 Supplier 并返回调用的结果值。 12345public static void main(String[] args) &#123; Optional&lt;Date&gt; optional = Optional.ofNullable(null); Date result = optional.orElseGet(Date::new); System.out.println(result); // Fri Sep 16 18:35:30 CST 2016&#125; filter 如果 Optional 对象的值不存在或值存在且该值匹配参数给定的 Predicate 规则，则返回当前的 Optional 对象本身。否则，返回一个空的 Optional 对象。 123456public static void main(String[] args) &#123; Optional&lt;String&gt; optional1 = Optional.of(\"foo\"); Optional&lt;String&gt; optional2 = optional1.filter((s) -&gt; s.length() == 3); System.out.println(optional2.isPresent()); // true System.out.println(optional2.get()); // foo&#125; map 如果 Optional 对象的值存在，则将该值作为参数调用 Function，如果调用的结果为 non-null 值，则返回一个新的以该结果作为值的 Optional 对象，否则，返回一个空的 Optional 对象。 123456public static void main(String[] args) &#123; Optional&lt;String&gt; optional1 = Optional.of(\"foo\"); Optional&lt;Integer&gt; optional2 = optional1.map((s) -&gt; s.length()); System.out.println(optional2.isPresent()); // true System.out.println(optional2.get()); // 3&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Supplier","date":"2016-09-15T14:33:04.000Z","path":"post/java8-supplier.html","text":"Supplier 是一个无参并返回一个任意类型值的函数式接口。 12345public static void main(String[] args) &#123; Supplier&lt;Date&gt; supplier = Date::new; Date date = supplier.get(); System.out.println(date); // Fri Sep 16 00:20:19 CST 2016&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Consumer","date":"2016-09-15T14:32:54.000Z","path":"post/java8-consumer.html","text":"Consumer 是一个接收一个任意类型的参数并不产生任何结果的函数式接口。 1234public static void main(String[] args) &#123; Consumer&lt;String&gt; consumer = (s) -&gt; System.out.println(\"The input string is : \" + s); consumer.accept(\"Hello Java8\"); // The input string is : Hello Java8&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Function","date":"2016-09-15T13:55:20.000Z","path":"post/java8-function.html","text":"Function 是一个接收一个参数并返回一个任意类型值的函数式接口。 12345public static void main(String[] args) &#123; Function&lt;String, Integer&gt; function = (s) -&gt; s.length(); Integer result = function.apply(\"foo\"); System.out.println(result); // 3&#125; 使用 Function 提供的默认方法可以组合多个 Function 一起工作。 123456public static void main(String[] args) &#123; Function&lt;String, Integer&gt; function1 = (s) -&gt; s.length(); Function&lt;Integer, Boolean&gt; function2 = (i) -&gt; i &gt; 5; Boolean result = function1.andThen(function2).apply(\"foo\"); System.out.println(result); // false&#125; andThen 是比较常见的一种用法，工作时，先执行 function1 再执行 function2。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Predicate","date":"2016-09-15T12:36:15.000Z","path":"post/java8-predicate.html","text":"Predicate 是一个接收一个参数并返回一个 boolean 类型值的函数式接口。它用于判断输入的参数对象是否符合某个特定的规则。 12345public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate = (n) -&gt; n % 2 == 0; boolean result = predicate.test(8); System.out.println(result); // true&#125; 除此之外，你还可以组合 Predicate 中提供的默认方法 or（或）、and（与）、negate（非）进行更加复杂的逻辑判断。 12345public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate = (n) -&gt; n % 2 == 0; boolean result = predicate.negate().test(8); System.out.println(result); // false&#125; or 逻辑时，先执行 predicate1 判断再执行 predicate2 判断。 123456public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate1 = (n) -&gt; n &gt; 0; Predicate&lt;Integer&gt; predicate2 = (n) -&gt; n &lt; 5; boolean result = predicate1.or(predicate2).test(8); System.out.println(result); // true&#125; and 逻辑时，先执行 predicate1 判断再执行 predicate2 判断。 123456public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate1 = (n) -&gt; n &gt; 0; Predicate&lt;Integer&gt; predicate2 = (n) -&gt; n &lt; 5; boolean result = predicate1.and(predicate2).test(8); System.out.println(result); // false&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 方法引用","date":"2016-09-15T07:09:50.000Z","path":"post/java8-method-reference.html","text":"在了解 Lambda 表达式之后，我们来看这样一段代码： 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2)); System.out.println(list); // [1, 2, 3, 4, 5, 6]&#125; 如果 Lambda 表达式中仅仅是调用了一个已存在的方法，在 Java8 中，可以使 :: 关键字来替代 Lambda 表达式。 关键字 :: 可以用来引用一个方法或构造器，这种特性称为方法引用。 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Collections.sort(list, Integer::compareTo); System.out.println(list); // [1, 2, 3, 4, 5, 6]&#125; 声明一个函数式接口 1234@FunctionalInterfaceinterface Converter&lt;I, O&gt; &#123; O convert(I input);&#125; 引用静态方法（类名::静态方法名） 1234567public static void main(String[] args) &#123; // 对应的 Lambda 表达式 // Converter&lt;String, Integer&gt; converter = (s) -&gt; Integer.valueOf(s); Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer result = converter.convert(\"256\"); System.out.println(result); // 256&#125; 引用对象的实例方法（对象::方法名） 12345678public static void main(String[] args) &#123; DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); // 对应的 Lambda 表达式 // Converter&lt;Date, String&gt; converter = (date) -&gt; format.format(date); Converter&lt;Date, String&gt; converter = format::format; String result = converter.convert(new Date()); System.out.println(result); // 2016-09-15&#125; 引用某种类型的任意对象的实例方法（类名::方法名） 1234567public static void main(String[] args) &#123; // 对应的 Lambda 表达式 // Converter&lt;String, Boolean&gt; converter = (s) -&gt; s.isEmpty(); Converter&lt;String, Boolean&gt; converter = String::isEmpty; Boolean result = converter.convert(\"foo\"); System.out.println(result); // false&#125; 引用构造方法（类名::new） 1234567public static void main(String[] args) &#123; // 对应的 Lambda 表达式 // Converter&lt;String, Integer&gt; converter = (s) -&gt; new Integer(s); Converter&lt;String, Integer&gt; converter = Integer::new; Integer result = converter.convert(\"256\"); System.out.println(result); // 256&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Lambda 表达式","date":"2016-09-14T07:39:00.000Z","path":"post/java8-lambda-expressions.html","text":"在 Java8 之前，当实现只有一个方法的接口，我们通常是通过使用匿名内部类的方式来重写接口的方法，以 Comparator 为例： 12345678List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6);Collections.sort(list, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1.compareTo(o2); &#125;&#125;);System.out.println(list); // [1, 2, 3, 4, 5, 6] Java8 中引入了 Lambda 表达式，提供了更加简洁的语法：() -&gt; {} 12345List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6);Collections.sort(list, (Integer o1, Integer o2) -&gt; &#123; return o1.compareTo(o2);&#125;);System.out.println(list); // [1, 2, 3, 4, 5, 6] 从 Java8 开始编译器可以从接口的方法签名中自动推导出参数类型，因此可以省略掉类型的声明 12345List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6);Collections.sort(list, (o1, o2) -&gt; &#123; return o1.compareTo(o2);&#125;);System.out.println(list); // [1, 2, 3, 4, 5, 6] 当方法体只有一行代码时，可以省略掉 {} 和 return 关键字以及代码行结束的分号“;” 123List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6);Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));System.out.println(list); // [1, 2, 3, 4, 5, 6] 对于只有一个抽象方法的接口，都可以使用 Lambda 表达式。为了确保接口符合要求，可以使用 @FunctionalInterface 注解标注接口，被 @FunctionalInterface 注解标注的接口（称为函数式接口），只允许存在一个抽象方法，没有或多于一个抽象方法，编译都将无法通过。由于默认的方法不是抽象的，因此，函数式接口依然可以存在一个或多个默认方法。其中，每个 Lambda 表达式都将匹配函数式接口的这个抽象方法，Lambda 表达式的类型也由该接口类型决定。 123456@FunctionalInterfaceinterface Operation&lt;I, O&gt; &#123; O calculate(I input);&#125; 对函数式接口使用 Lambda 表达式 12345public static void main(String[] args) &#123; Operation&lt;Integer, Integer&gt; square = (i) -&gt; i * i; Integer result = square.calculate(3); System.out.println(result); // 9&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 接口默认方法","date":"2016-09-13T07:02:19.000Z","path":"post/java-8-interface-default-method.html","text":"在 Java8 中，接口也可以为方法提供默认的实现，即，接口也可以有自己的实现方法，具体的做法是使用关键字 default 即可为接口声明一个默认的方法。 123456789interface Predators &#123; void doSomething(); default void eat() &#123; System.out.println(\"eat meat\"); &#125; &#125; 任何具体类在实现接口时，接口的默认方法不是必须实现的，非默认方法则必须实现。 12345678class Dog implements Predators &#123; @Override public void doSomething() &#123; System.out.println(\"wang....\"); &#125;&#125; 使用方面与平常无异，很自然。 12345public static void main(String[] args) &#123; Dog dog = new Dog(); dog.doSomething(); // wang.... dog.eat(); // eat meat&#125; 关于多重继承： 123456789interface Herbivore &#123; void doSomething(); default void eat() &#123; System.out.println(\"eat fruit\"); &#125; &#125; 以下这段代码将无法通过编译。因 Predators 和 Herbivore 两个接口使用了同样签名的默认方法（eat），那么，在 Person 类中就无法确定最终使用哪个接口的默认实现。 12345678class Person implements Predators, Herbivore &#123; @Override public void doSomething() &#123; System.out.println(\"duang....\"); &#125;&#125; 为了解决冲突，你必须要通过手动重写的方式来修复。若想引用 Herbivore 接口中的 eat 方法，如下所示： 12345678910111213class Person implements Predators, Herbivore &#123; @Override public void eat() &#123; Herbivore.super.eat(); &#125; @Override public void doSomething() &#123; System.out.println(\"duang....\"); &#125;&#125; 使用方面与平常无异，很自然。 12345public static void main(String[] args) &#123; Person person = new Person(); person.doSomething(); // duang.... person.eat(); // eat fruit&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"网络爬虫","date":"2016-01-08T12:57:21.000Z","path":"post/network-crawler.html","text":"Crawler4j 是一个开源的 Java 类库提供一个用于抓取 Web 页面的简单接口。可以利用它来构建一个多线程的 Web 爬虫。 pom.xml 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;edu.uci.ics&lt;/groupId&gt; &lt;artifactId&gt;crawler4j&lt;/artifactId&gt; &lt;version&gt;4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.8.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; 资源下载工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.io.File;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import org.apache.commons.lang3.StringUtils;import org.apache.http.HttpResponse;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpUriRequest;import org.apache.http.client.methods.RequestBuilder;import org.apache.http.impl.client.HttpClientBuilder;/** * 资源下载工具 * * @author fanlychie */public class HttpClientUtils &#123; private static Logger log = LoggerFactory.getLogger(HttpClientUtils.class); /** * 下载资源文件 * * @param url * 资源文件地址 * @param storeFolder * 下载的文件存放的目录 */ public static void download(String url, String storeFolder) &#123; String filename = null; if (StringUtils.isNotBlank(url)) &#123; filename = url.substring(url.lastIndexOf(\"/\") + 1, url.length()); &#125; download(url, storeFolder, filename); &#125; /** * 下载资源文件 * * @param url * 资源文件地址 * @param storeFolder * 下载的文件存放的目录 * @param filename * 下载的文件的名称 */ public static void download(String url, String storeFolder, String filename) &#123; try &#123; if (StringUtils.isBlank(url)) &#123; throw new IllegalArgumentException(\"外部链接地址为空\"); &#125; // HttpClient HttpClient httpClient = HttpClientBuilder.create().build(); // GET 方法请求 HttpUriRequest request = RequestBuilder.get().setUri(url).build(); // 执行 GET 请求 HttpResponse response = httpClient.execute(request); // 状态码 int statusCode = response.getStatusLine().getStatusCode(); // 200 OK if (statusCode == HttpURLConnection.HTTP_OK) &#123; log.info(\"downloading &#123;&#125; ( &#123;&#125; KB )\", url, response.getEntity().getContentLength() / 1024); // 下载资源的临时文件名称 String fileTempName = filename + \".temp\"; File file = new File(storeFolder, fileTempName); downloadFile(response.getEntity().getContent(), new FileOutputStream(file)); // 下载成功后重命名文件 file.renameTo(new File(storeFolder, filename)); &#125; &#125; catch (Throwable e) &#123; log.error(\"下载外部资源失败！\", e); &#125; &#125; /** * 下载文件 * * @param in * 输入流 * @param out * 输入流 * @throws Throwable */ private static void downloadFile(InputStream in, OutputStream out) throws Throwable &#123; byte bytes[] = new byte[1024 * 1024 / 4]; int read; while ((read = in.read(bytes)) != -1) &#123; out.write(bytes, 0, read); &#125; out.close(); &#125; &#125; log4j 123456log4j.rootLogger = INFO, consolelog4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.target = System.outlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.conversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%nlog4j.logger.org.apache.http = WARN 网络爬虫 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import org.jsoup.Jsoup;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.fanlychie.util.HttpClientUtils;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import edu.uci.ics.crawler4j.crawler.Page;import edu.uci.ics.crawler4j.crawler.WebCrawler;import edu.uci.ics.crawler4j.parser.HtmlParseData;import edu.uci.ics.crawler4j.url.WebURL;/** * 网络爬虫 * * @author fanlychie */public class MyWebCrawler extends WebCrawler &#123; private final static Pattern FILTERS = Pattern.compile(\".*(\\\\.(css|js|gif|jpg|png))$\"); /** * 哪些页面可以被爬取 */ @Override public boolean shouldVisit(Page page, WebURL url) &#123; String href = url.getURL().toLowerCase(); // 链接地址不是 css, js, 图片且链接地址必须以 http://www.hai360.com/shoes-clothes.html 开始的链接才爬取 return !FILTERS.matcher(href).matches() &amp;&amp; href.startsWith(\"http://www.hai360.com/shoes-clothes.html\"); &#125; /** * 当某个页面被爬取时该方法被调用 */ @Override public void visit(Page page) &#123; if (page.getParseData() instanceof HtmlParseData) &#123; HtmlParseData htmlParseData = (HtmlParseData) page.getParseData(); // 爬取到的 HTML 文本内容 String html = htmlParseData.getHtml(); Document doc = Jsoup.parse(html); // 解析 class=\"list-item\" 节点下的 img 标签 // 其中某一个的 img 标签内容如下 // &lt;img data-src=\"http://aimg.hai360.com/item/20151113/140613/617251.jpg@!250\" // width=\"250\" height=\"250\" alt=\"（秒杀国内价 国内同款1459）Kenneth Cole 凯尼斯·柯尔男士休闲皮鞋\"&gt; Elements es = doc.select(\".list-item img\"); // 迭代 class=\"list-item\" 节点下的 img 标签 for (Element e : es) &#123; // 商品图片的地址 String url = e.attr(\"data-src\"); // 商品图片的名称 String filename = e.attr(\"alt\"); // 商品图片文件的后缀格式名 String suffix = url.substring(url.lastIndexOf(\"/\") + 1, url.length()); suffix = suffix.substring(suffix.lastIndexOf(\".\"), suffix.length()); filename += suffix.substring(0, 4); // 下载商品图片 HttpClientUtils.download(url, \"D:/crawl/hai360/images\", filterStr(filename)); &#125; &#125; &#125; /** * 过滤特殊字串 * * @param str * 源字串 * @return 返回过滤后的字串 */ private static String filterStr(String str) &#123; String regex = \"[`~!@#$%^&amp;*()+=|&#123;&#125;':;',//[//].&lt;&gt;/?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。，、？]\"; Matcher m = Pattern.compile(regex).matcher(str); return m.replaceAll(\"\").trim(); &#125; &#125; 启动爬虫 1234567891011121314151617181920212223242526272829303132import edu.uci.ics.crawler4j.crawler.CrawlConfig;import edu.uci.ics.crawler4j.crawler.CrawlController;import edu.uci.ics.crawler4j.fetcher.PageFetcher;import edu.uci.ics.crawler4j.robotstxt.RobotstxtConfig;import edu.uci.ics.crawler4j.robotstxt.RobotstxtServer;/** * 启动爬虫 * * @author fanlychie */public class Controller &#123; public static void main(String[] args) throws Exception &#123; // 爬取过的 URL 记录目录 String crawlStorageFolder = \"D:/crawl/hai360\"; // 线程数 int numberOfCrawlers = 10; CrawlConfig config = new CrawlConfig(); config.setCrawlStorageFolder(crawlStorageFolder); config.setResumableCrawling(true); PageFetcher pageFetcher = new PageFetcher(config); RobotstxtConfig robotstxtConfig = new RobotstxtConfig(); RobotstxtServer robotstxtServer = new RobotstxtServer(robotstxtConfig, pageFetcher); CrawlController controller = new CrawlController(config, pageFetcher, robotstxtServer); // 种子地址, 可以添加多个 controller.addSeed(\"http://www.hai360.com/shoes-clothes.html\"); // 启动爬虫 controller.start(MyWebCrawler.class, numberOfCrawlers); &#125; &#125; 以上为爬取海360网站的商品图片，种子地址为：http://www.hai360.com/shoes-clothes.html CrawlConfig 配置项 描述 crawlStorageFolder 用于记录爬取过的 URL 目录 resumableCrawling 若设置为 true，重新启动程序可恢复爬取过程中意外发生终止的爬虫，默认为 false maxDepthOfCrawling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置爬取的深度。默认为 -1，即没有限制。第一个页面的深度为 0，第一个页面由超链接到达的第二个页面，则第二个页面的深度为 1，以此类推 maxPagesToFetch 设置页面抓取的最大数量。默认为 -1，即没有限制 userAgentString 向 Web 服务器表明你的爬虫。默认为 crawler4j (https://github.com/yasserg/crawler4j/) politenessDelay 请求前等待的毫秒数。默认为 200 毫秒。由于 crawler4j 并发高效的抓取能力，会给 Web 服务器带来一定量的压力，这可能会使 Web 服务器阻断你的请求 maxTotalConnections 设置最大连接数，默认为 100 connectionTimeout 设置连接超时，单位毫秒，默认为 30000 socketTimeout 设置读取超时，单位毫秒，默认为 20000 proxyHost 代理相关，代理服务器 proxyPort 代理相关，代理服务器端口 proxyUsername 代理相关，代理服务器账户 proxyPassword 代理相关，代理服务器密码 爬虫结果","tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/网络爬虫/"}]},{"title":"基于 memcached 的 tomcat 集群之 session 共享","date":"2015-12-05T18:22:53.000Z","path":"post/memcached-tomcat-session-share.html","text":"实现在多台服务器之间共享 session 会话中的数据。 JAR 包 asm-4.0.jar kryo-1.04.jar minlog-1.2.jar reflectasm-1.04.jar kryo-serializers-0.10.jar spymemcached-2.8.12.jar couchbase-client-1.1.4.jar msm-kryo-serializer-1.6.4.jar memcached-session-manager-1.6.4.jar memcached-session-manager-tc7-1.6.4.jar 配置将 JAR 包全部放到 $Tomcat/lib 目录下（$Tomcat 表示 Tomcat 安装的根目录，以下同）。 编辑 $Tomcat/conf/context.xml 文件，在 &lt;Context&gt; 节点下加入如下配置 12345678&lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot; memcachedNodes=&quot;n1:192.168.1.102:11211,n2:192.168.1.103:11211&quot; sticky=&quot;false&quot; lockingMode=&quot;auto&quot; sessionBackupAsync= &quot;false&quot; sessionBackupTimeout=&quot;300&quot; requestUriIgnorePattern= &quot;.*\\.(png|gif|jpg|ico|css|js)$&quot; transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot; /&gt; memcachedNodes必须项 配置 memcached 节点。格式：&lt;id&gt;:&lt;host&gt;:&lt;port&gt;，多个节点之间，用空格或英文逗号分隔 sticky可选项 是否粘性。默认为 true。粘性会话需要保证每个用户的请求都路由到同一台 Tomcat 服务器中。否则，需要设置成非粘性会话。 lockingMode可选项 用于非粘性会话。默认为 none。 可选值 描述 none 不锁定 session all 每个请求访问 session 的期间，session 一直被锁定，直到请求结束 auto 只锁定写请求的 session，只读请求的 session 不会被锁定 uriPattern:&lt;regexp&gt; 通过正则表达式的方式来对请求的 URI 进行匹配，匹配上的会被锁定 sessionBackupAsync可选项 设置 session 会话中的数据是否异步同步到 memcached 中，默认为 true。 requestUriIgnorePattern可选项 设置忽略会话同步的请求的 URI 地址的正则表达式。这应该包含静态资源的请求。 failoverNodes可选项 memcached 故障转移节点配置。用于粘性会话，非粘性会话不可用。如： failoverNodes=&quot;n1&quot;，含义是告诉 msm 将 session 会话中的数据存储到 memcached 的 n2 节点中，如果 n2 节点宕掉等致使其不能正常提供服务，msm 才会将 session 会话中的数据存储到 memcached 的 n1 节点中。 sessionAttributeFilter可选项 配置同步 session 会话数据的属性名称的正则表达式。如果不设置，则将 session 中全部的属性保存到 memcached 中。 transcoderFactoryClass可选项 配置序列化和反序列化 session 会话中的数据到 memcached 中的编码转换器的工厂类名。 默认是 de.javakaffee.web.msm.JavaSerializationTranscoderFactory backupThreadCount可选项 用于异步存储 session 会话中的数据到 memcached 中的线程数。（当 sessionBackupAsync=&quot;true&quot; 时，该配置项有效） sessionBackupTimeout可选项 备份 session 会话数据所需时间如果大于该值，将导致 session 会话数据同步失败。默认为 100（单位毫秒）","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"Memcached","slug":"Memcached","permalink":"http://yoursite.com/tags/Memcached/"}]},{"title":"基于 POI 和反射机制实现通用写出 Excel 文档文件","date":"2015-11-17T17:03:53.000Z","path":"post/poi-excel-write.html","text":"分享一个基于 POI 和反射机制实现的通用的写出 Excel 文档文件工具类，及简写出数据到 Excel 文档 源代码清单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370package org.fanlychie.excel;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.apache.poi.ss.usermodel.CellStyle;import org.apache.poi.ss.usermodel.Font;import org.apache.poi.ss.usermodel.IndexedColors;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import org.fanlychie.util.DynaBean;/** * 可进行写操作的 EXCEL 工具类 * * @author fanlychie */public class WritableExcel &#123; // 数据列表 private List&lt;?&gt; list; // 属性名称集 private String[] props; // 标题集 private String[] title; // 动态 Bean private DynaBean dynaBean; // 工作表 private XSSFSheet sheet; // 工作表的名称 private String sheetName; // 工作簿 private XSSFWorkbook workbook; // 数据格式 private static Map&lt;Class&lt;?&gt;, String&gt; dataFormat; /** * 构造一个可写的 Excel 实例 * * @param list * 数据列表 * @param mapper * 数据对象的属性名称与Excel文档标题之间的映射关系 */ public WritableExcel(List&lt;?&gt; list, LinkedHashMap&lt;String, String&gt; mapper) &#123; init(list, mapper); &#125; /** * 写出到文件 * * @param file * 文件对象 */ public boolean write(File file) &#123; try &#123; return write(new FileOutputStream(file)); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 写出到输出流 * * @param out * 输出流 */ public boolean write(OutputStream out) &#123; try &#123; // 创建工作表 sheet = workbook.createSheet(sheetName); // 构建并填充标题行 fillTitleRow(); // 主体行的索引 int rowIndex = 1; for (Object bean : list) &#123; // 创建并填充行 fillCreatedRow(rowIndex++, bean); &#125; workbook.write(out); return true; &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; &#125; catch (IOException e) &#123;&#125; &#125; &#125; /** * 设置工作表的名称, 默认名称 Sheet1 * * @param sheetName * 工作表的名称 */ public void setSheetName(String sheetName) &#123; this.sheetName = sheetName; &#125; /** * 设置日期格式, 默认格式 yyyy-MM-dd * * @param dateFormat * 日期格式 */ public void setDateFormat(String dateFormat) &#123; dataFormat.put(Date.class, dateFormat); &#125; /** * 初始化 * * @param list * 数据列表 * @param mapper * 数据对象的属性名称与Excel文档标题之间的映射关系 */ private void init(List&lt;?&gt; list, LinkedHashMap&lt;String, String&gt; mapper) &#123; this.list = list; int index = 0; int size = mapper.size(); props = new String[size]; title = new String[size]; // 迭代取出属性名称集和标题集 for (String prop : mapper.keySet()) &#123; props[index] = prop; title[index] = mapper.get(prop); index++; &#125; // 工作簿 this.workbook = new XSSFWorkbook(); // 动态 Bean this.dynaBean = new DynaBean(list.get(0).getClass()); // 默认的工作表名称 this.sheetName = \"Sheet1\"; &#125; /** * 构建并填充标题行 * * @throws Throwable */ private void fillTitleRow() throws Throwable &#123; // 单元格索引 int cellIndex = 0; // 单元格宽度 int cellWidth = 18 * 256; // 创建一行 XSSFRow row = sheet.createRow(0); // 设置行高 row.setHeightInPoints(25); // 标题行样式 CellStyle style = getTitleCellStyle(); // 迭代标题集 for (String text : title) &#123; // 设置宽度 sheet.setColumnWidth(cellIndex, cellWidth); // 创建单元格 XSSFCell cell = row.createCell(cellIndex++); // 设置单元格样式 cell.setCellStyle(style); // 设置单元格的值 cell.setCellValue(text); &#125; &#125; /** * 创建并填充行 * * @param index * 行的索引 * @param bean * 填充行的对象 * @throws Throwable */ private void fillCreatedRow(int index, Object bean) throws Throwable &#123; // 单元格索引 int cellIndex = 0; // 创建一行 XSSFRow row = sheet.createRow(index); // 设置行高 row.setHeightInPoints(20); // 迭代 Bean 属性集 for (String prop : props) &#123; // 属性的值 Object value = dynaBean.getFieldValue(bean, prop); // 属性类型 Class&lt;?&gt; type = dynaBean.getFieldType(prop); // 创建单元格 XSSFCell cell = row.createCell(cellIndex++); // 值为空 if (value == null) &#123; // 设置为空串 cell.setCellValue(\"\"); // 单元格样式 cell.setCellStyle(getBodyCellStyle(String.class)); &#125; else &#123; // 按类型设值 if (type == Boolean.TYPE || type == Boolean.class) &#123; boolean boolValue = Boolean.parseBoolean(value.toString()); cell.setCellValue(boolValue); &#125; else if ((Number.class.isAssignableFrom(type) || type.isPrimitive()) &amp;&amp; type != Byte.TYPE &amp;&amp; type != Character.TYPE) &#123; double doubleValue = Double.parseDouble(value.toString()); cell.setCellValue(doubleValue); &#125; else if (type == Date.class) &#123; Date dateValue = (Date) value; cell.setCellValue(dateValue); &#125; else &#123; cell.setCellValue(value.toString()); &#125; // 单元格样式 cell.setCellStyle(getBodyCellStyle(type)); &#125; &#125; &#125; /** * 主体单元格样式 * * @param type * 单元格填充的数据的类型 * @return CellStyle */ private CellStyle getBodyCellStyle(Class&lt;?&gt; type) &#123; // 单元格样式 CellStyle style = workbook.createCellStyle(); // 单元格数据格式 String cellDataFormat = dataFormat.get(type); if (cellDataFormat == null) &#123; cellDataFormat = dataFormat.get(String.class); &#125; // 水平居中 style.setAlignment(CellStyle.ALIGN_CENTER); // 垂直居中 style.setVerticalAlignment(CellStyle.VERTICAL_CENTER); // 背景颜色 setBackgroundColor(style, IndexedColors.LIGHT_TURQUOISE.index); // 字体 style.setFont(getFont(11, IndexedColors.GREY_50_PERCENT.index)); // 数据格式 style.setDataFormat(workbook.createDataFormat().getFormat(cellDataFormat)); // 自动换行 style.setWrapText(true); return style; &#125; /** * 标题行样式 * * @return CellStyle */ private CellStyle getTitleCellStyle() &#123; // 单元格样式 CellStyle style = workbook.createCellStyle(); // 水平居中 style.setAlignment(CellStyle.ALIGN_CENTER); // 垂直居中 style.setVerticalAlignment(CellStyle.VERTICAL_CENTER); // 背景颜色 setBackgroundColor(style, IndexedColors.YELLOW.index); // 字体 style.setFont(getFont(12, IndexedColors.BLUE_GREY.index)); // 数据格式 style.setDataFormat(workbook.createDataFormat().getFormat(\"GENERAL\")); // 自动换行 style.setWrapText(true); return style; &#125; /** * 设置单元格背景颜色 * * @param style * 单元格样式 * @param color * 颜色值 */ private void setBackgroundColor(CellStyle style, short color) &#123; // 边框设置 style.setBorderBottom(CellStyle.BORDER_THIN); style.setBorderLeft(CellStyle.BORDER_THIN); style.setBorderRight(CellStyle.BORDER_THIN); style.setBorderTop(CellStyle.BORDER_THIN); // 边框颜色 style.setBottomBorderColor(IndexedColors.GREY_25_PERCENT.index); style.setLeftBorderColor(IndexedColors.GREY_25_PERCENT.index); style.setRightBorderColor(IndexedColors.GREY_25_PERCENT.index); style.setTopBorderColor(IndexedColors.GREY_25_PERCENT.index); // 背景颜色 style.setFillPattern(CellStyle.SOLID_FOREGROUND); style.setFillForegroundColor(color); &#125; /** * 获取字体 * * @param fontSize * 字体大小 * @param fontColor * 字体颜色 * @return Font */ private Font getFont(int fontSize, short fontColor) &#123; // 创建字体 Font font = workbook.createFont(); // 字体颜色 font.setColor(fontColor); // 字体大小 font.setFontHeightInPoints((short) fontSize); // 字体名称 if (System.getProperty(\"os.name\").contains(\"Windows\")) &#123; font.setFontName(\"Microsoft YaHei\"); &#125; return font; &#125; // 数据格式 static &#123; dataFormat = new HashMap&lt;Class&lt;?&gt;, String&gt;(); dataFormat.put(Short.TYPE, \"0\"); dataFormat.put(Short.class, \"0\"); dataFormat.put(Integer.TYPE, \"0\"); dataFormat.put(Integer.class, \"0\"); dataFormat.put(Long.TYPE, \"0\"); dataFormat.put(Long.class, \"0\"); dataFormat.put(Float.TYPE, \"0.00\"); dataFormat.put(Float.class, \"0.00\"); dataFormat.put(Double.TYPE, \"0.00\"); dataFormat.put(Double.class, \"0.00\"); dataFormat.put(String.class, \"GENERAL\"); dataFormat.put(Date.class, \"yyyy-MM-dd\"); &#125; &#125; POI 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; 测试对象清单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static class Person &#123; private int id; private String name; private boolean local; private Date birthday; public Person() &#123; &#125; public Person(int id, String name, boolean local, Date birthday) &#123; this.id = id; this.name = name; this.local = local; this.birthday = birthday; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isLocal() &#123; return local; &#125; public void setLocal(boolean local) &#123; this.local = local; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; &#125; 测试清单1 1234567891011121314151617181920212223242526272829private static DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");public static void main(String[] args) throws Throwable &#123; File excelFile = new File(\"src/test/resources/test_excel.xlsx\"); List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); for (int i = 1; i &lt; 10; i++) &#123; list.add(new Person(i, \"范忠云\" + i, i % 2 == 0, format.parse(\"1990-04-0\" + i))); &#125; // 属性与 Excel 列的映射关系 LinkedHashMap&lt;String, String&gt; mapper = new LinkedHashMap&lt;String, String&gt;(); mapper.put(\"id\", \"编号\"); mapper.put(\"name\", \"姓名\"); mapper.put(\"local\", \"本地户口\"); mapper.put(\"birthday\", \"出生日期\"); // 创建一个可写的 Excel 对象 WritableExcel excel = new WritableExcel(list, mapper); // 写出 Excel 文档文件 boolean success = excel.write(excelFile); if (success) &#123; System.out.println(\"Excel 生成成功！\"); &#125; &#125; 测试结果","tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"基于 POI 和反射机制实现通用读取 Excel 表格数据","date":"2015-11-17T15:46:35.000Z","path":"post/poi-excel-read.html","text":"分享一个基于 POI 和反射机制实现的通用的读取 Excel 表格数据工具类，读取 Excel 表格数据只需 2 行代码 源代码清单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256package org.fanlychie.excel;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.ss.usermodel.WorkbookFactory;import org.fanlychie.util.DynaBean;/** * 可进行读操作的 EXCEL 工具类 * * @author fanlychie */public class ReadableExcel &#123; // 工作表 private Sheet sheet; // 工作表索引 private int sheetIndex; // Excel 列 与 Bean 属性的顺序映射集 private Map&lt;Integer, String&gt; mapper; // 动态 Bean private DynaBean dynaBean; // 最大解析的单元格索引 private int maxColumnIndex; /** * 构造可读的 Excel 实例 * * @param file * Excel 文件 */ public ReadableExcel(File file) &#123; try &#123; init(new FileInputStream(file)); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 构造可读的 Excel 实例 * * @param in * Excel 文件输入流 */ public ReadableExcel(InputStream in) &#123; init(in); &#125; /** * 解析 Excel 文档到一个 List 列表, 约定第一行为标题行, 标题行不被解析 * * @param beanClass * 简单的 JavaBean 类型, Excel 文档的每一行解析成该类的一个实例 * @param mapper * Excel 文档的列映射到 JavaBean 对象的属性列表&lt;br&gt; * 格式串 A：[\"prop_name1\", \"prop_name2\", ...]&lt;br&gt; * 格式串 B：[\"1:prop_name1\", \"2:prop_name2\", ...] * @return 返回解析 Excel 文档的 List 结果列表 */ public &lt;T&gt; List&lt;T&gt; asList(Class&lt;T&gt; beanClass, String... mapper) &#123; // 解析映射对照表 this.mapper = parseMapper(mapper); // 实例化一个动态 Bean 对象 this.dynaBean = new DynaBean(beanClass); List&lt;T&gt; beanList = new ArrayList&lt;T&gt;(); // 工作表的行集 Iterator&lt;Row&gt; rows = sheet.iterator(); // 约定第一行为标题行, 不解析 Row rowOfTitle = rows.next(); // 实际的总的列数 this.maxColumnIndex = rowOfTitle.getPhysicalNumberOfCells(); // 迭代工作表的行集 while (rows.hasNext()) &#123; @SuppressWarnings(\"unchecked\") T bean = (T) parseRow(rows.next()); beanList.add(bean); &#125; return beanList; &#125; /** * 设置读取的工作表的索引 * * @param sheetIndex * 工作表的索引 */ public void setSheetIndex(int sheetIndex) &#123; this.sheetIndex = sheetIndex; &#125; /** * 初始化工作表 * * @param in * Excel 输入流 */ private void init(InputStream in) &#123; try &#123; // 工作薄 Workbook workbook = WorkbookFactory.create(in); // 获取索引指定的工作表 sheet = workbook.getSheetAt(sheetIndex); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 解析 Excel 文档的一行到一个 Bean 的对象里 * * @param row * Excel 文档中的行对象 * @return 返回解析行的 Bean 对象 */ private Object parseRow(Row row) &#123; // 创建一个 Bean 的实例 dynaBean.newBeanInstance(); // 行的单元格列表 Iterator&lt;Cell&gt; cells = row.cellIterator(); // 迭代单元格列表 while (cells.hasNext()) &#123; // 单元格 Cell cell = cells.next(); // 当前的单元格的索引 int columnIndex = cell.getColumnIndex(); // 索引超出最大解析的索引值结束迭代 if (columnIndex &gt;= maxColumnIndex) &#123; break; &#125; // 单元格映射到 Bean 的属性名称 String name = mapper.get(columnIndex); // 如果不在对照表内, 跳过该列 if (name == null) &#123; continue ; &#125; // 单元格映射到 Bean 的属性类型 Class&lt;?&gt; type = dynaBean.getFieldType(name); // 单元格映射到 Bean 的属性的值 Object value; if (type == Date.class) &#123; value = cell.getDateCellValue(); &#125; else &#123; // 设置单元格的类型为字符串类型 cell.setCellType(Cell.CELL_TYPE_STRING); // 获取单元格字符串内容的值 String stringCellValue = cell.getStringCellValue(); // 进行数据类型转换 value = commonTypeConvert(stringCellValue, type); &#125; // 设置到 Bean 对象 dynaBean.setFieldValue(name, value); &#125; // 返回 Bean 的实例 return dynaBean.getBean(); &#125; /** * 解析映射的字符串 * * @param mapper * 格式串 A：[\"prop_name1\", \"prop_name2\", ...] * 格式串 B：[\"1:prop_name1\", \"2:prop_name2\", ...] * @return 返回解析后的对照表 */ private Map&lt;Integer, String&gt; parseMapper(String... mapper) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); String item; int length = mapper.length; for (int i = 0; i &lt; length; i++) &#123; item = mapper[i]; if (item.contains(\":\")) &#123; String[] items = item.split(\":\"); map.put(Integer.valueOf(items[0]), items[1]); &#125; else &#123; map.put(i, item); &#125; &#125; return map; &#125; /** * 常用的数据类型转换 * * @param value * 被转换的对象 * @param type * 期望得到的类型 * @return 返回转换后的数据类型对象 */ private Object commonTypeConvert(String value, Class&lt;?&gt; type) &#123; if (type == String.class) &#123; return value; &#125; if (type == Character.TYPE || type == Character.class) &#123; return value.charAt(0); &#125; if (type == Boolean.TYPE || type == Boolean.class) &#123; // 真值 if (value == \"1\" || value.equals(\"是\") || value.equalsIgnoreCase(\"Y\") || value.equalsIgnoreCase(\"YES\") || value.equalsIgnoreCase(\"T\") || value.equalsIgnoreCase(\"TRUE\")) &#123; return true; &#125; // 假值 if (value == \"0\" || value.equals(\"否\") || value.equalsIgnoreCase(\"N\") || value.equalsIgnoreCase(\"NO\") || value.equalsIgnoreCase(\"F\") || value.equalsIgnoreCase(\"FALSE\")) &#123; return false; &#125; &#125; // 解析成双精度类型 Double objVal = Double.valueOf(value); // 以下均基于双精度数据上作的类型转换 if (type == Byte.TYPE || type == Byte.class) &#123; return objVal.byteValue(); &#125; if (type == Short.TYPE || type == Short.class) &#123; return objVal.shortValue(); &#125; if (type == Integer.TYPE || type == Integer.class) &#123; return objVal.intValue(); &#125; if (type == Long.TYPE || type == Long.class) &#123; return objVal.longValue(); &#125; if (type == Float.TYPE || type == Float.class) &#123; return objVal.floatValue(); &#125; if (type == Double.TYPE || type == Double.class) &#123; return objVal; &#125; throw new ClassCastException(\"Cannot cast java.lang.String to \" + type.getName()); &#125;&#125; POI 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; 测试对象清单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static class Person &#123; private int id; private String name; private String sex; private boolean local; private Date birthday; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isLocal() &#123; return local; &#125; public void setLocal(boolean local) &#123; this.local = local; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getBirthdayStr() &#123; if (birthday == null) &#123; return null; &#125; return new SimpleDateFormat(\"yyyy-MM-dd\").format(birthday); &#125; @Override public String toString() &#123; return id + \"\\t\" + name + \"\\t\" + sex + \"\\t\" + local + \"\\t\" + getBirthdayStr(); &#125; &#125; 测试 Excel 表格数据清单 测试清单1 1234567891011121314151617public static void main(String[] args) &#123; File excelFile = new File(\"src/test/resources/person_excel.xlsx\"); // 创建一个可读的 Excel 对象 ReadableExcel excel = new ReadableExcel(excelFile); // 解析 Excel 数据为 JavaBean 对象 List&lt;Person&gt; persons = excel.asList(Person.class, \"id\", \"name\", \"sex\", \"local\", \"birthday\"); for (Person person : persons) &#123; System.out.println(person); &#125; &#125; 解析语法1：[&quot;id&quot;, &quot;name&quot;, &quot;sex&quot;, &quot;local&quot;, &quot;birthday&quot;] 从左至右依次对应 Excel 表格的列数据 测试结果 12345678910111213141516171 刘一 男 false 1990-04-022 陈二 男 false 1991-08-013 张三 女 false 1990-04-014 李四 女 false 1992-05-045 王五 女 true 1992-05-026 赵六 男 true 1991-07-067 孙七 女 true 1990-09-038 周八 女 false 1990-03-059 吴九 男 true 1993-01-03 测试清单2 1234567891011121314151617public static void main(String[] args) &#123; File excelFile = new File(\"src/test/resources/person_excel.xlsx\"); // 创建一个可读的 Excel 对象 ReadableExcel excel = new ReadableExcel(excelFile); // 解析 Excel 数据为 JavaBean 对象 List&lt;Person&gt; persons = excel.asList(Person.class, \"0:id\", \"2:name\", \"1:sex\"); for (Person person : persons) &#123; System.out.println(person); &#125; &#125; 解析语法2：[&quot;0:id&quot;, &quot;2:name&quot;, &quot;1:sex&quot;] 只提取想要的列的数据（0 代表第 1 列） &quot;2:name&quot; 表示将 Excel 表格第 3 列的数据解析成 JavaBean 对象的 name 属性的值 [&quot;0:id&quot;, &quot;2:name&quot;, &quot;1:sex&quot;] 等效于 [&quot;id&quot;, &quot;2:name&quot;, &quot;1:sex&quot;]，其余类似，可灵活提取表格数据 场景： 我们公司使用的短信供应商目前已有 3 家，在统计数据的时候，需要先在供应商短信系统导出短信 消息的 Excel 文档然后统计相关信息，但是不同供应商导出的 Excel 模板文件格式不一致，因此衍生 了这种解析 Excel 表格数据的处理方法。 假设供应商 A 导出的手机号码在第 2 列，供应商 B 导出的手机号码在第 3 列，我们可以这样做： 供应商 A 使用 &quot;1:mobile&quot; 供应商 B 使用 &quot;2:mobile&quot; 这样一来，我们只需要根据不同的供应商传整数值定向解析列的数据即可，这样可以适配多个不同 的 Excel 模板，只要 2 行代码完成解析工作 注：非公开公司代码，纯为个人积累及思考编码实现 测试结果 12345678910111213141516171 男 刘一 false null2 男 陈二 false null3 女 张三 false null4 女 李四 false null5 女 王五 false null6 男 赵六 false null7 女 孙七 false null8 女 周八 false null9 男 吴九 false null [&quot;0:id&quot;, &quot;2:name&quot;, &quot;1:sex&quot;] 这里故意将 name 和 sex 倒了过来，将第 2 列解析成 sex，第 3 列解析成 name，以示区分","tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"基于反射机制实现动态操纵 JavaBean","date":"2015-11-17T14:39:29.000Z","path":"post/java-reflect-bean.html","text":"分享一个基于反射机制实现的动态操纵 JavaBean 的工具类 源代码清单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package org.fanlychie.util;import java.util.Map;import java.util.HashMap;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * 动态 Bean * * @author 范忠云（fanlychie） */public class DynaBean &#123; // Bean 对象 private Object bean; // Bean 类型 private Class&lt;?&gt; beanClass; // Bean 对象的非静态属性对照表 private Map&lt;String, Field&gt; beanProps; /** * 实例化一个动态 Bean * * @param beanClass * Bean 类型 */ public DynaBean(Class&lt;?&gt; beanClass) &#123; this.beanClass = beanClass; this.beanProps = getDeclaredFieldsMap(beanClass); &#125; /** * 实例化一个 Bean 对象 */ public void newBeanInstance() &#123; try &#123; bean = beanClass.newInstance(); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取属性的类型 * * @param name * 属性名称 * @return 返回属性的类型 */ public Class&lt;?&gt; getFieldType(String name) &#123; Field field = beanProps.get(name); if (field == null) &#123; throw new RuntimeException(castExceptionMessage(name)); &#125; return field.getType(); &#125; /** * 设置属性的值 * * @param name * 属性名称 * @param value * 属性的值 */ public void setFieldValue(String name, Object value) &#123; Field field = beanProps.get(name); if (field == null) &#123; throw new RuntimeException(castExceptionMessage(name)); &#125; try &#123; field.set(bean, value); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取属性的值 * * @param bean * 对象 * @param name * 属性名称 * @return 返回对象中属性的值 */ public Object getFieldValue(Object bean, String name) &#123; Field field = beanProps.get(name); if (field == null) &#123; throw new RuntimeException(castExceptionMessage(name)); &#125; try &#123; return field.get(bean); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取 Bean 的实例 * * @return 返回 Bean 的实例 */ public Object getBean() &#123; return bean; &#125; /** * 获取类声明的非静态属性表 * * @param beanClass * 类 * @return 返回类声明的非静态属性表 */ private Map&lt;String, Field&gt; getDeclaredFieldsMap(Class&lt;?&gt; beanClass) &#123; // 获取类声明的属性集合 Field[] fields = beanClass.getDeclaredFields(); Map&lt;String, Field&gt; map = new HashMap&lt;String, Field&gt;(); // 迭代属性集合 for (Field field : fields) &#123; // 剔除静态属性 if ((field.getModifiers() &amp; Modifier.STATIC) != Modifier.STATIC) &#123; // 强行设置成可访问 field.setAccessible(true); map.put(field.getName(), field); &#125; &#125; return map; &#125; /** * 异常信息 * * @param name * 属性名称 * @return 返回异常信息 */ private String castExceptionMessage(String name) &#123; return String.format(&quot;Can not found property \\&quot;%s\\&quot; in class %s&quot;, name, beanClass.getSimpleName()); &#125; &#125; 测试对象清单12345678910111213141516171819202122232425262728public class Person &#123; private String name; private String sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, sex=&quot; + sex + &quot;]&quot;; &#125; &#125; 测试清单11234567891011121314151617181920212223242526public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); // 创建动态 Bean 实例 DynaBean dynaBean = new DynaBean(Person.class); // 创建一个 Bean 的实例 dynaBean.newBeanInstance(); // 设置 Bean 属性的值 dynaBean.setFieldValue(&quot;name&quot;, &quot;张三&quot;); dynaBean.setFieldValue(&quot;sex&quot;, &quot;男&quot;); // 取出 Bean 对象 persons.add((Person) dynaBean.getBean()); // 创建一个 Bean 的实例 dynaBean.newBeanInstance(); // 设置 Bean 属性的值 dynaBean.setFieldValue(&quot;name&quot;, &quot;李四&quot;); dynaBean.setFieldValue(&quot;sex&quot;, &quot;女&quot;); // 取出 Bean 对象 persons.add((Person) dynaBean.getBean()); System.out.println(persons); &#125; 使用场景可参考 ReadableExcel - 基于 POI 和反射机制实现通用读取 Excel 表格数据 测试结果1[Person [name=张三, sex=男], Person [name=李四, sex=女]] 测试清单212345678910111213141516171819202122232425262728public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); Person person1 = new Person(); person1.setName(&quot;张三&quot;); person1.setSex(&quot;男&quot;); persons.add(person1); Person person2 = new Person(); person2.setName(&quot;李四&quot;); person2.setSex(&quot;女&quot;); persons.add(person2); // 创建动态 Bean 实例 DynaBean dynaBean = new DynaBean(Person.class); for (Person person : persons) &#123; System.out.println(String.format(&quot;[name=%s, sex=%s]&quot;, // 获取 Bean 对象的 name 属性的值 dynaBean.getFieldValue(person, &quot;name&quot;), // 获取 Bean 对象的 sex 属性的值 dynaBean.getFieldValue(person, &quot;sex&quot;))); &#125;&#125; 使用场景可参考 WritableExcel - 基于 POI 和反射机制实现通用写出 Excel 文档文件 测试结果123[name=张三, sex=男][name=李四, sex=女]","tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"nginx 防盗链配置","date":"2015-11-14T18:00:16.000Z","path":"post/nginx-anti-theft-chain.html","text":"以图片资源为例 12345678910111213location ~ \\.(gif|jpg|jpeg|png|ico)$ &#123; valid_referers none blocked fanlychie.com www.fanlychie.com; if ($invalid_referer) &#123; return 403; &#125; expires 7d;&#125; 来路是 fanlychie.com 或 www.fanlychie.com 的请求图片正常显示 如一个 http://aabb.com 的站点发起一个 http://fanlychie.com/aabb.png 的请求，nginx 会拒绝 该请求，并给它返回 403 状态码，在 http://aabb.com 站点看到的图是一个破图","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"nginx 负载均衡配置","date":"2015-11-13T07:42:32.000Z","path":"post/nginx-slb.html","text":"配置文件的位置：/usr/local/nginx/conf/nginx.conf user1#user www www; nginx 运行的用户和用户组，默认为 nobody pid1pid logs/nginx.pid; 进程文件配置，默认为 logs/nginx.pid error_log1error_log logs/error.log warn; 错误日志配置。 日志级别可选：debug &lt; info &lt; notice &lt; warn &lt; error &lt; crit 日志级别越高，记录的日志信息越少 worker_processes1worker_processes 1; nginx 对外提供 web 服务的 worder 进程数。通常设置和 cpu 核数的数量相等 worker_rlimit_nofile1worker_rlimit_nofile 1024; 一个 worker 进程能打开的文件的最大数目。 理论值应该是系统最多能打开的文件数（在 linux 中执行 ulimit -n 可得到值）与 worker 进程数相 除得到的值，但是 nginx 分配请求并不均匀，建议与 ulimit -n 的值保持一致 events1234567events &#123; worker_connections 1024; use epoll;&#125; worker_connections1worker_connections 1024; 设置单个 worker 进程最大连接数 use1use epoll; 设置复用客户端线程的轮询方法 use &nbsp;[ &nbsp;kqueue&nbsp; | &nbsp;rtsig&nbsp; | &nbsp;epoll&nbsp; | &nbsp;select&nbsp; | &nbsp;poll&nbsp; ] epoll 是 linux 2.6 以上版本内核中的高性能网络 I / O 模型 如果不设置，nginx 会选择一个最适合你操作系统的模型 http123http &#123;&#125; http 服务器配置 include1include mime.types; 设置 MIME 类型（资源的媒体类型），通过 http 协议由 web 服务器返回给客户端浏览器，浏览器会自动使用指定应用程序来打开资源文件 mime.types 文件位于 /usr/local/nginx/conf/mime.types default_type1default_type application/octet-stream; 默认的资源文件的媒体类型，application/octet-stream 为任意的二进制数据流传输 log_format123log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; 日志格式。&quot;log_format &nbsp;main&quot;&nbsp; 这里的 main 是日志格式的名称，通过不同名称来定义多种日志格式 参数 描述 $remote_addr 客户端 IP 地址 $http_x_forwarded_for 客户端 IP 地址 $remote_user 客户端用户名 $time_local 访问时间和时区 $http_host 请求主机（域名） $request 请求的 uri 和 http 协议 $http_referer url 跳转来源（从哪个页面链接访问过来的） $status http 请求状态 $request_time 处理请求的时间 $body_bytes_sent 发送给客户端文件的主体内容大小 $http_user_agent 客户端浏览器信息 access_log1access_log logs/access.log main; 配置访问日志。可以指定使用的日志格式，如这里的 main charset1charset UTF-8; 使用的字符集编码 sendfile1sendfile on; 通过调用 sendfile 函数（sendfile 是一个系统调用，在内核空间中完成），可以高效的发送静态文件 tcp_nopush1tcp_nopush on; 一次性发送数据包。与 tcp_nodelay 配置项互斥，与 sendfile 配合工作 tcp_nodelay1#tcp_nodelay on; 每 0.2 秒后立即发送一个数据包，可以有效的防止网络阻塞，当需要及时发送数据时，应该开启它 keepalive_timeout1keepalive_timeout 60; 配置长连接的超时时间。服务器将在这个超时时间过后关闭链接 client_header_timeout1client_header_timeout 120; 等待客户端发送一个请求头的超时时间，超时 Nginx 返回一个请求超时的状态码（408，Request Timeout） client_body_timeout1client_body_timeout 120; 等待客户端发送一个请求体的超时时间，超时 Nginx 返回一个请求超时的状态码（408，Request Timeout） send_timeout1send_timeout 120; 客户端读取数据的超时时间，超时 Nginx 就会关闭该连接 client_header_buffer_size1client_header_buffer_size 16k; 缓存客户端请求头的大小 large_client_header_buffers1large_client_header_buffers 4 32k; 缓存客户端请求头的最大大小，此处为 4 个 32K 的大小 gzip1gzip on; 采用 gzip 压缩的形式发送数据，可以减少发送的数据量 gzip_min_length1gzip_min_length 1k; 大于该值的内容才压缩，0 表示所有的内容都压缩 gzip_buffers1gzip_buffers 4 16k; 缓存 gzip 压缩数据的空间大小，此处为 4 个 16K 的大小 gzip_types1gzip_types text/plain text/css application/x-javascript application/xml; 只有匹配配置的 MIME 类型的文档内容才会被压缩 nginx 默认会对 text/html 类型进行压缩，此处无需再配，若配置 text/html，nginx 会发出警告： nginx: [ warn ] duplicate MIME type &quot;text/html&quot; server_names_hash_bucket_size1server_names_hash_bucket_size 128; 服务器名称的 hash 表大小，如果太小，Nginx 无法启动 server123server &#123;&#125; 虚拟主机配置 listen1listen 80; 监听端口 server_name1server_name fanlychie.com www.fanlychie.com; 域名，可以配置多个，以空格分开 access_log1access_log logs/fanlychie.access.log main; 虚拟主机访问日志。 root1root www.fanlychie.com; 网站根目录，用于存放网站静态资源文件。若为相对路径，则是相对于 nginx 安装的目录。如此处的物理路径为 /usr/local/nginx/www.fanlychie.com location123location / &#123;&#125; 配置请求处理的方式 语法 描述 / 通用配置，可匹配任意请求的 url 地址 = 精确匹配 url 地址 ~ 区分大小写的正则表达式匹配 url 地址 ~* 不区分大小写的正则表达式匹配 url 地址 ^~ 禁止正则表达式的普通字串匹配 url 地址 多个 location 匹配 url 地址的优先级： &quot;=&quot; 被匹配，停止搜索其他匹配 &quot;^~&quot; 被匹配，停止搜索其他匹配 &quot;~&quot; 和 &quot;~*&quot; 按配置文件中出现的先后顺序，一旦匹配，停止搜索其他匹配 若以上都没有匹配到，则交给 &quot;/&quot; 处理请求 expires12345location ~ \\.(js|css)$ &#123; expires 1d;&#125; js 和 css 文件由 nginx 直接提供，缓存一天 如客户端访问 http://www.fanlychie.com/styles/main.css 由于上面已经配置 root &nbsp;www.fanlychie.com，nginx 会将 /usr/local/nginx/www.fanlychie.com/styles/main.css 文件直接返回给客户端 12345location ~ \\.(gif|jpg|jpeg|png|ico)$ &#123; expires 7d;&#125; 同上面，图片文件缓存 7 天 deny12345location ~* \\.jsp &#123; deny all;&#125; 禁止直接访问 *.jsp 文件（返回 403 状态码给客户端） proxy_pass1234567891011location = / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://www.fanlychie.com/index;&#125; proxy_pass 配置反向代理 即通过域名访问网站首页，nginx 将请求转发给真实的运用服务器处理，即 http://www.fanlychie.com/index&nbsp;（www.fanlychie.com 是上面配置的 server_name 的名称） proxy_set_header设置请求报头域的值 参数 描述 Host 指定请求的服务器的域名和端口号 X-Forwarded-For&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于记录代理 IP 信息每经过一级代理（匿名代理除外），代理服务器都会把这次请求的来源 IP追加在 X-Forwarded-For 中。一个 IP 来自 4.4.4.4 的请求，请求头中可能包含这样一行X-Forwarded-For&nbsp; : &nbsp;1.1.1.1, &nbsp;2.2.2.2, &nbsp;3.3.3.3 X-Real-IP 用于记录真实发出请求的客户端 IP上面的例子，如果配置了 X-Read-IP，将会是X-Real-IP&nbsp; : &nbsp;1.1.1.1 Referer url 跳转来源（从哪个页面链接访问过来的） 12345678910111213141516171819202122232425location / &#123; proxy_pass http://www.fanlychie.com; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffers 32 4k;&#125; proxy_redirectproxy_redirect 与 proxy_pass 用法类似，proxy_pass 是转发请求，客户端 url 地址不变； proxy_redirect 是请求重定向，客户端 url 地址发生变化。 client_max_body_size允许客户端请求的最大单文件字节数 client_body_buffer_size代理缓冲用户端请求的缓冲区最大字节数 proxy_connect_timeout代理连接超时时间（nginx 跟后端服务器连接超时时间） proxy_send_timeout代理发送超时时间（后端服务器数据回传时间） proxy_read_timeout代理接收超时时间（连接成功后，后端服务器响应时间） proxy_buffers代理缓冲区的大小 error_page1234567891011121314151617181920212223location = /403.html &#123; root html;&#125;location = /404.html &#123; root html;&#125;location = /50x.html &#123; root html;&#125;error_page 403 /403.html;error_page 404 /404.html;error_page 500 502 503 504 /50x.html; 错误页面配置。 upstream1234567upstream www.fanlychie.com &#123; server 192.168.1.102:8080; server 192.168.1.103:8080;&#125; 负载均衡配置 upstream &nbsp;www.fanlychie.com，此处的 www.fanlychie.com 是上面 server 模块配置的 server_name。server 指定真实的运用服务主机地址，可以配置多个。 nginx 默认采用轮询的策略，将请求平均的分配到各个运用服务主机中，当其中一台服务主机宕机 后，会自动的被剔除，另外一台服务主机仍然能正常提供服务。 weight1234567upstream www.fanlychie.com &#123; server 192.168.1.102:8080 weight=1; server 192.168.1.103:8080 weight=2;&#125; 在轮询的基础上加上权重，数值越大，表示权值越大，nginx 分发的请求越多 用于运用服务器性能不均的情况。当其中一台服务主机宕机后，会自动的被剔除，另外一台服务主 机仍然能正常提供服务 ip_hash123456789upstream www.fanlychie.com &#123; ip_hash; server 192.168.1.102:8080; server 192.168.1.103:8080;&#125; 每个请求按访问 ip 的 hash 结果分配服务主机 当新的请求到达时，先将用户 ip 通过哈希算法求值，在随后的请求客户端 ip 的哈希值只要相同， 就会被分配至同一个后端服务器，这种调度可以解决 session 共享的问题，但有时会导致分配不均 即无法保证负载均衡 附完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#user nobody;pid logs/nginx.pid;worker_processes 1;worker_rlimit_nofile 1024;error_log logs/error.log warn;events &#123; worker_connections 1024; use epoll;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; charset UTF-8; sendfile on; tcp_nopush on; #tcp_nodelay on; keepalive_timeout 60; client_header_timeout 120; client_body_timeout 120; send_timeout 120; client_header_buffer_size 16k; large_client_header_buffers 4 32k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_types text/plain text/css application/x-javascript application/xml; server_names_hash_bucket_size 128; upstream www.fanlychie.com &#123; server 192.168.1.102:8080; server 192.168.1.103:8080; &#125; server &#123; listen 80; server_name fanlychie.com www.fanlychie.com; access_log logs/fanlychie.access.log main; root www.fanlychie.com; location = / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://www.fanlychie.com/index; &#125; location ~ \\.(js|css)$ &#123; expires 1d; &#125; location ~ \\.(gif|jpg|jpeg|png|ico)$ &#123; expires 7d; &#125; location ~* \\.jsp &#123; deny all; &#125; location / &#123; proxy_pass http://www.fanlychie.com; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffers 32 4k; &#125; location = /403.html &#123; root html; &#125; location = /404.html &#123; root html; &#125; location = /50x.html &#123; root html; &#125; error_page 404 /404.html; error_page 403 /403.html; error_page 500 502 503 504 /50x.html; &#125;&#125; 附全局变量表 变量 描述 $args 请求的参数 $content_length 请求头中的 Content-length 域的值 $content_type 请求头中的 Content-Type 域的值 $host 请求主机域的值，否则为服务器名称 $http_user_agent 客户端 agent 信息 $http_cookie 客户端 cookie 信息 $request_method 客户端请求的动作，通常为 GET 或 POST $remote_addr 客户端的 IP 地址 $remote_port 客户端的端口 $remote_user 已经经过 Auth Basic Module 验证的用户名 $request_filename 当前请求的文件路径 $query_string 与 $args 同 $scheme HTTP 方法（如 http，https） $server_protocol 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1 $server_addr 服务器地址，在完成一次系统调用后可以确定这个值 $server_name 服务器名称 $server_port 请求到达服务器的端口号 $request_uri 包含请求参数的原始 URI，不包含主机名，如：&quot;/foo/bar.php?arg=baz&quot; $uri 不带请求参数的当前 URI，$uri 不包含主机名，如 &quot;/foo/bar.html&quot; $document_uri 与 $uri 同 附表达式列表 表达式 表达式 描述 -f !-f 判断文件是否存在 -d !-d 判断目录是否存在 -e !-e 判断文件或目录是否存在 -x !-x 判断文件是否可执行","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"nginx 安装","date":"2015-11-13T06:10:17.000Z","path":"post/nginx-setup.html","text":"nginx 是一个高性能的 HTTP 和反向代理服务器，它具有很多非常优越的特性，支持高并发和高效的负载均衡，目前，包括百度、新浪、网易、腾讯等知名网站已经开始使用 nginx 作为 WEB 应用服务器。 安装环境 CentOS 6.5 pcre-8.36.tar.gz zlib-1.2.8.tar.gz openssl-1.0.2d.tar.gz nginx-1.8.0.tar.gz 将下载的文件全部上传至服务器 /usr/local/src 目录下 安装 pcre 12345# tar xzvf pcre-8.36.tar.gz# cd pcre-8.36# ./configure# make# make install 若执行 ./configure 报错： configure: error: You need a C++ compiler for C++ support 则需要先安装 C++（pcre 模块需要 C++ 编译） 安装 C++（若已安装，跳过此步骤） 1# yum install -y gcc gcc-c++ 安装 zlib 12345# tar xzvf zlib-1.2.8.tar.gz# cd zlib-1.2.8# ./configure# make# make install 安装 openssl 12345# tar xzvf openssl-1.0.2d.tar.gz# cd openssl-1.0.2d# ./config# make# make install 安装 nginx 12345# tar xzvf nginx-1.8.0.tar.gz# cd nginx-1.8.0# ./configure# make# make install 建立 pcre 库链接 32 位系统 1# ln -s /usr/local/lib/libpcre.so.1 /lib 64 位系统 1# ln -s /usr/local/lib/libpcre.so.1 /lib64 防火墙配置 1# vi /etc/sysconfig/iptables 加入如下一行配置（开放 80 端口） 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT 重启防火墙服务 1# service iptables restart 启动 nginx 1# /usr/local/nginx/sbin/nginx 关闭 nginx 1# /usr/local/nginx/sbin/nginx -s stop 或 1# /usr/local/nginx/sbin/nginx -s quit 重新打开日志文件 1# /usr/local/nginx/sbin/nginx -s reopen 重新加载（使配置文件修改后生效） 1# /usr/local/nginx/sbin/nginx -s reload 查看 nginx 进程 1# ps -ef | grep nginx 测试 Nginx 安装是否成功，访问 http://192.168.1.104","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"SolrJ 的运用","date":"2015-11-11T15:17:30.000Z","path":"post/solrj-usage.html","text":"SolrJ 是操作 Solr 的 Java 客户端，它提供了增加、修改、删除、查询 Solr 索引的 Java 接口。SolrJ 针对 Solr 提供了 REST 的 Http 接口进行了封装， SolrJ 底层是通过使用 HttpClient 来完成 Solr 的操作。 pom.xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; SQL 脚本（MySQL）12345678910CREATE TABLE `product` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `name` varchar(200) NOT NULL COMMENT &apos;商品名称&apos;, `sort_name` varchar(128) NOT NULL COMMENT &apos;分类名称&apos;, `sub_sort_name` varchar(128) NOT NULL COMMENT &apos;子分类名称&apos;, `price` decimal(10,0) NOT NULL COMMENT &apos;价格&apos;, `sales` int(11) DEFAULT &apos;0&apos; COMMENT &apos;销量&apos;, `area` varchar(64) NOT NULL COMMENT &apos;地区&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=742 DEFAULT CHARSET=utf8 COMMENT=&apos;商品表&apos;; 点此下载数据库脚本（数据从爱淘宝网站中爬取） 建立数据模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package org.fanlychie.model;import org.apache.solr.client.solrj.beans.Field;public class Product &#123; /** * 主键 */ @Field(&quot;id&quot;) private Integer id; /** * 商品名称 */ @Field(&quot;name&quot;) private String name; /** * 分类名称 */ @Field(&quot;sortName&quot;) private String sortName; /** * 子分类名称 */ @Field(&quot;subSortName&quot;) private String subSortName; /** * 价格 */ @Field(&quot;price&quot;) private Double price; /** * 销量 */ @Field(&quot;sales&quot;) private Integer sales; /** * 地区 */ @Field(&quot;area&quot;) private String area; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSortName() &#123; return sortName; &#125; public void setSortName(String sortName) &#123; this.sortName = sortName; &#125; public String getSubSortName() &#123; return subSortName; &#125; public void setSubSortName(String subSortName) &#123; this.subSortName = subSortName; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; public Integer getSales() &#123; return sales; &#125; public void setSales(Integer sales) &#123; this.sales = sales; &#125; public String getArea() &#123; return area; &#125; public void setArea(String area) &#123; this.area = area; &#125; @Override public String toString() &#123; return &quot;Product [id=&quot; + id + &quot;, name=&quot; + name + &quot;, sortName=&quot; + sortName + &quot;, subSortName=&quot; + subSortName + &quot;, price=&quot; + price + &quot;, sales=&quot; + sales + &quot;, area=&quot; + area + &quot;]&quot;; &#125;&#125; @Field(&quot;id&quot;) 与 schema.xml 中的 &lt;field name=&quot;id&quot; /&gt; 节点相呼应 建立索引文件时，SolrJ 会将 @Field 注解的属性转换成 Solr 文档对象的字段 在检索的时候，SolrJ 会将 Solr 文档对象的字段转换成 @Field 注解的 Bean 的属性 schema.xml 配置片段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;schema name=&quot;core1&quot; version=&quot;1.5&quot;&gt; [ . . . . . . ] &lt;field name=&quot;_version_&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;!-- 商品 ID --&gt; &lt;field name=&quot;id&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品名称 --&gt; &lt;field name=&quot;name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品一级分类 --&gt; &lt;field name=&quot;sortName&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品二级分类 --&gt; &lt;field name=&quot;subSortName&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品价格 --&gt; &lt;field name=&quot;price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品销量 --&gt; &lt;field name=&quot;sales&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 发货地 --&gt; &lt;field name=&quot;area&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 检索域 --&gt; &lt;field name=&quot;text&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot; required=&quot;false&quot;/&gt; &lt;!-- 唯一键 --&gt; &lt;uniqueKey&gt;id&lt;/uniqueKey&gt; &lt;!-- 把需要检索的字段, 拷贝到 text 字段中 --&gt; &lt;copyField source=&quot;name&quot; dest=&quot;text&quot;/&gt; &lt;!-- 把需要检索的字段, 拷贝到 text 字段中 --&gt; &lt;copyField source=&quot;sortName&quot; dest=&quot;text&quot;/&gt; &lt;!-- 把需要检索的字段, 拷贝到 text 字段中 --&gt; &lt;copyField source=&quot;subSortName&quot; dest=&quot;text&quot;/&gt; &lt;!-- 采用 IK 中文分词的字段类型 --&gt; &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt; &lt;analyzer type=&quot;index&quot;&gt; &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; /&gt; &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt; &lt;/analyzer&gt; &lt;analyzer type=&quot;query&quot;&gt; &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; /&gt; &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; [ . . . . . . ]&lt;/schema&gt; Solr 服务启动报错： Caused by: org.apache.solr.common.SolrException: Invalid Number: MA147LL/A 解决办法： 将 $SOLR_HOME/core1/conf/elevate.xml（竞价排名）配置文件中的 id 的值改为整型值即可 使用 JDBC 从数据库获取数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package org.fanlychie.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import org.fanlychie.model.Product;public class ProductDao &#123; public static List&lt;Product&gt; getAll() &#123; Connection conn = null; try &#123; String username = &quot;root&quot;; String password = &quot;root&quot;; String url = &quot;jdbc:mysql://localhost:3306/product_repo&quot;; conn = DriverManager.getConnection(url, username, password); PreparedStatement pstmt = conn.prepareStatement(&quot;select * from product&quot;); ResultSet rs = pstmt.executeQuery(); List&lt;Product&gt; products = new ArrayList&lt;Product&gt;(); while (rs.next()) &#123; Product product = new Product(); product.setId(rs.getInt(&quot;id&quot;)); product.setSales(rs.getInt(&quot;sales&quot;)); product.setArea(rs.getString(&quot;area&quot;)); product.setName(rs.getString(&quot;name&quot;)); product.setPrice(rs.getDouble(&quot;price&quot;)); product.setSortName(rs.getString(&quot;sort_name&quot;)); product.setSubSortName(rs.getString(&quot;sub_sort_name&quot;)); products.add(product); &#125; return products; &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (Exception e) &#123;&#125; &#125; &#125; &#125; static &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; log4j.xml 配置123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;http://toolkit.alibaba-inc.com/dtd/log4j/log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&apos;http://jakarta.apache.org/log4j/&apos;&gt; &lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%n%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;org.apache&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;WARN&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http.impl.conn.DefaultClientConnection&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 建立索引123456789101112131415161718192021222324252627282930313233343536373839private static final int RESPONSE_STATUS_OK = 0; public static void main(String[] args) throws Throwable &#123; // 创建一个 Solr 客户端 SolrClient solrClient = new HttpSolrClient(&quot;http://192.168.1.102:8081/solr/core1&quot;); // 文档对象绑定器 DocumentObjectBinder binder = solrClient.getBinder(); // Solr 输入文档 List&lt;SolrInputDocument&gt; documents = new ArrayList&lt;SolrInputDocument&gt;(); // 从数据库中取得需要建立索引的数据 List&lt;Product&gt; products = ProductDao.getAll(); for (Product product : products) &#123; // 将 Bean 转换成 Solr 文档 documents.add(binder.toSolrInputDocument(product)); &#125; // 添加文档到客户端 solrClient.add(documents); // 提交事务 UpdateResponse response = solrClient.commit(); if (response.getStatus() == RESPONSE_STATUS_OK) &#123; System.out.println(&quot;创建索引成功！&quot;); &#125; else &#123; System.out.println(&quot;创建索引失败！&quot;); &#125; // 关闭 solrClient.close();&#125; 检索文档123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws Throwable &#123; // 创建一个 Solr 客户端 SolrClient solrClient = new HttpSolrClient(&quot;http://192.168.1.102:8081/solr/core1&quot;); // 创建一个 Solr 查询 SolrQuery solrQuery = new SolrQuery(); // 设置查询串 solrQuery.setQuery(&quot;打底加绒上衣男&quot;); // 执行查询得到查询响应对象 QueryResponse response = solrClient.query(solrQuery); // 从查询响应对象中获取查询结果 SolrDocumentList documentList = response.getResults(); // 文档对象绑定器 DocumentObjectBinder binder = solrClient.getBinder(); List&lt;Product&gt; products = new ArrayList&lt;Product&gt;(); for (SolrDocument document : documentList) &#123; // 将 Solr 文档对象转换成 Bean 对象 products.add(binder.getBean(Product.class, document)); &#125; // 关闭客户端 solrClient.close(); // 打印消息 System.out.println(products);&#125; 搜索结果 1234567891011121314151617DEBUG 2015-12-02 21:51:06 org.apache.http.impl.conn.DefaultClientConnection : 268 Sending request: GET /solr/core1/select?q=%E6%89%93%E5%BA%95%E5%8A%A0%E7%BB%92%E4%B8%8A%E8%A1%A3%E7%94%B7&amp;wt=javabin&amp;version=2 HTTP/1.1DEBUG 2015-12-02 21:51:06 org.apache.http.impl.conn.DefaultClientConnection : 253 Receiving response: HTTP/1.1 200 OKDEBUG 2015-12-02 21:51:06 org.apache.http.impl.conn.DefaultClientConnection : 176 Connection 0.0.0.0:53836&lt;-&gt;192.168.1.102:8081 closedDEBUG 2015-12-02 21:51:06 org.apache.http.impl.conn.DefaultClientConnection : 176 Connection 0.0.0.0:53836&lt;-&gt;192.168.1.102:8081 closed[ Product [id=371, name=男士长袖t恤男装高领紧身秋衣男青少年加绒加厚打底衫韩版上衣服, sortName=男装, subSortName=T恤, price=30.0, sales=7681, area=浙江 杭州], Product [id=310, name=男装长袖T恤冬季加绒加厚保暖衣青少年V领打底上衣潮男冬装加大码, sortName=男装, subSortName=T恤, price=48.0, sales=631, area=广东 深圳]] POST 请求1QueryResponse response = solrClient.query(solrQuery, SolrRequest.METHOD.POST); 最小匹配1solrQuery.setQuery(&quot;打底加绒上衣男&quot;); 执行查询请求，服务器端记录的日志信息 1[core1] webapp=/solr path=/select params=&#123;q=打底加绒上衣男&amp;wt=javabin&amp;version=2&#125; hits=2 status=0 QTime=1 hits = 2，即该请求匹配到 2 个文档。 123solrQuery.setQuery(&quot;打底加绒上衣男&quot;); solrQuery.setParam(&quot;mm&quot;, &quot;2&quot;); mm（minimal should match）最小应该匹配多少个短语（查询串分词后的短语）。 再次执行查询请求，服务器端记录的日志信息 1[core1] webapp=/solr path=/select params=&#123;mm=2&amp;q=打底加绒上衣男&amp;wt=javabin&amp;version=2&#125; hits=120 status=0 QTime=4 hits = 120，即该请求匹配到 120 个文档。 查询参数1solrQuery.setQuery(&quot;sortName:男装 AND area:广东\\\\ 广州&quot;); 查询分类是男装，发货地是广东广州的商品（广东广州有空格，需要转义） 1[core1] webapp=/solr path=/select params=&#123;q=sortName:男装+AND+area:广东\\+广州&amp;wt=javabin&amp;version=2&#125; hits=19 status=0 QTime=3 结果排序12345solrQuery.setQuery(&quot;羽绒服女&quot;); solrQuery.addSort(&quot;price&quot;, SolrQuery.ORDER.asc); solrQuery.addSort(&quot;sales&quot;, SolrQuery.ORDER.desc); 先按价格升序排序，价格相同按销量降序排序。注意不能用 setSort，如 12345solrQuery.setQuery(&quot;羽绒服女&quot;); solrQuery.setSort(&quot;price&quot;, SolrQuery.ORDER.asc); solrQuery.setSort(&quot;sales&quot;, SolrQuery.ORDER.desc); 该方式只会按销量降序排序，价格的排序被覆盖掉不起作用。 facet 查询Facet 是 solr 的高级搜索功能之一，在检索文档的同时，能够按照 Facet 的域（字段）进行分组统计。Facet 的字段必须被索引，一般来说该字段无需分词，无需存储。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) throws Throwable &#123; // 创建一个 Solr 客户端 SolrClient solrClient = new HttpSolrClient(&quot;http://192.168.1.102:8081/solr/core1&quot;); // 创建一个 Solr 查询 SolrQuery solrQuery = new SolrQuery(); solrQuery.setRows(Integer.MAX_VALUE); // 设置查询串 solrQuery.setQuery(&quot;女装&quot;); // facet 查询 solrQuery.setFacet(true); // 每个分组中的数据至少有一个值才返回 solrQuery.setFacetMinCount(1); // 不统计 NULL 的值 solrQuery.setFacetMissing(false); // 排序 solrQuery.setFacetSort(FacetParams.FACET_SORT_COUNT); // facet 结果的返回行数 solrQuery.setFacetLimit(200); // 分组统计的域 solrQuery.addFacetField(&quot;sortName&quot;, &quot;subSortName&quot;); // 执行查询得到查询响应对象 QueryResponse response = solrClient.query(solrQuery, SolrRequest.METHOD.POST); List&lt;FacetField&gt; facetFieldList = response.getFacetFields(); for (FacetField facetField : facetFieldList) &#123; System.out.println(facetField.getName()); System.out.println(&quot;---------------------------------------------------&quot;); List&lt;Count&gt; counts = facetField.getValues(); for (Count count : counts) &#123; System.out.println(count.getName() + &quot; : &quot; + count.getCount()); &#125; System.out.println(); &#125; solrClient.close();&#125; 输出结果 123456789101112sortName---------------------------------------------------女装 : 348男装 : 1subSortName---------------------------------------------------羽绒服 : 76T恤 : 75毛呢外套 : 75连衣裙 : 75鞋子 : 48","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"Solr solrconfig.xml 配置","date":"2015-11-07T20:02:42.000Z","path":"post/solr-solrconfig-config.html","text":"luceneMatchVersion1&lt;luceneMatchVersion&gt;5.2.0&lt;/luceneMatchVersion&gt; solr 底层使用的 lucene 版本 dataDir1&lt;dataDir&gt;$&#123;solr.data.dir:/opt/apache-tomcat-solr/conf/solr/core1/data&#125;&lt;/dataDir&gt; 配置索引数据文件存放的目录，默认的目录是 $SOLR_HOME/data directoryFactory1&lt;directoryFactory name=&quot;DirectoryFactory&quot; class=&quot;$&#123;solr.directoryFactory:solr.NRTCachingDirectoryFactory&#125;&quot; /&gt; 目录工厂，决定了索引存储的方式。 工厂 描述 StandardDirectoryFactory 基于文件系统，依赖当前操作系统和 java 虚拟机 MMapDirectoryFactory 使用虚拟内存和内核中一个叫 mmap 的特性来访问存在磁盘中的索引文件。它允许 Lucene 直接访问 I/O 缓存，当不需要近实时搜索（Near Real Time Search），这是一个不错的选择 NIOFSDirectoryFactory 适用于多线程环境，在 Windows 平台不能很好的工作 NRTCachingDirectoryFactory&nbsp;&nbsp;&nbsp;&nbsp; 将部分索引存储在内存中，提升近实时搜索（Near Real Time Search）的效率 SimpleFSDirectoryFactory 适用于小型应用程序，不支持大数据和多线程 RAMDirectoryFactory 索引存储在 RAM 内存中，不支持持久化存储。服务重启等会造成索引丢失 updateHandler1234&lt;updateLog&gt; &lt;str name=&quot;dir&quot;&gt;$&#123;solr.ulog.dir:&#125;&lt;/str&gt; &lt;int name=&quot;numVersionBuckets&quot;&gt;$&#123;solr.ulog.numVersionBuckets:65536&#125;&lt;/int&gt;&lt;/updateLog&gt; 设置索引库的更新日志，默认的目录是 $SOLR_HOME/data/tlog 12345&lt;autoCommit&gt; &lt;maxDocs&gt;10000&lt;/maxDocs&gt; &lt;maxTime&gt;$&#123;solr.autoCommit.maxTime:30000&#125;&lt;/maxTime&gt; &lt;openSearcher&gt;true&lt;/openSearcher&gt; &lt;/autoCommit&gt; 设置自动硬提交的方式。自动硬提交对性能有一定的影响，它确保索引数据同步到磁盘，因此不会因为宕机等异常状况而造成大量数据丢失。硬提交后的文档是不可见的，需要重新打开一个新的 Searcher，才能看得见变化 参数 描述 maxDocs 设置达到多少个文档时提交一次 maxTime 设置达到多长时间时提交一次 openSearcher&nbsp;&nbsp;&nbsp;&nbsp; 文档提交后是否开启新的 Searcherfalse：文档只是提交到索引库，搜索结果中搜不到此次提交的文档true&nbsp;：文档提交到索引库，搜索结果中也能搜到此次提交的文档 1234&lt;autoSoftCommit&gt; &lt;maxDocs&gt;1000&lt;/maxDocs&gt; &lt;maxTime&gt;2000&lt;/maxTime&gt;&lt;/autoSoftCommit&gt; 自动软提交，只确保变化是看得见的，但不保证数据同步到磁盘。软提交后的文档立即可用 query1&lt;maxBooleanClauses&gt;1024&lt;/maxBooleanClauses&gt; 条件搜索时，会产生大量的 boolean 条件，如果条件数达到设定的这个阀值时，将抛出异常，限制这个条件数，可以防止条件过多查询等待时间过长 1234&lt;filterCache class=&quot;solr.FastLRUCache&quot; size=&quot;2048&quot; initialSize=&quot;2048&quot; autowarmCount=&quot;512&quot;/&gt; 配置过滤器缓存。filterCache 存储了无序的文档的 ID 集合。如 filter queries（&quot;fq&quot; 参数）得到的文档的 ID 集合结果等 LRUCache 是基于 LinkedHashMap，读写操作都是对 map 的全局锁，并发性方面稍差 FastLRUCache 是基于 ConcurrentHashMap ，具有更快的读取能力和较好的并发性能 参数 描述 size 缓存中的最大数目 initialSize 初始容量 autowarmCount&nbsp;&nbsp;&nbsp;&nbsp; 当打开一个新的 Searcher 时，可以对新的 Searcher 做预热处理。即从老的 Searcher 中取该值指定的缓存条目数目填充到新的 Searcher 中。如果使用的是 LRUCache，则取最近访问的条目填充到新的 Searcher 中 1234&lt;queryResultCache class=&quot;solr.LRUCache&quot; size=&quot;4096&quot; initialSize=&quot;4096&quot; autowarmCount=&quot;512&quot;/&gt; 配置查询结果缓存。查询结果缓存的是查询条件的结果的有序文档的 ID 集合。同 filterCache 参数 1234&lt;documentCache class=&quot;solr.LRUCache&quot; size=&quot;5120&quot; initialSize=&quot;5120&quot; autowarmCount=&quot;0&quot;/&gt; 配置文档缓存。文档缓存的是 &lt; 文档 ID, 文档对象 &gt; 键值对。参数与 filterCache 同 1234&lt;fieldValueCache class=&quot;solr.FastLRUCache&quot; size=&quot;512&quot; autowarmCount=&quot;128&quot; showItems=&quot;32&quot; /&gt; 配置字段值缓存。字段缓存使用文档 ID 进行快速访问。默认情况下创建 fieldValueCache，即使这里没有配置 1&lt;enableLazyFieldLoading&gt;true&lt;/enableLazyFieldLoading&gt; 是否允许字段延迟加载。若为 true，非必须字段（required = &quot;false&quot;）将被延迟加载，特别是一些大的压缩文本字段，延迟加载可以提升性能 1&lt;queryResultWindowSize&gt;50&lt;/queryResultWindowSize&gt; 优化 queryResultCache（查询结果缓存）。如从查询结果每次取匹配的 10 个文档，如 10 到 19，那么文档 0 到 49 将被用来收集和缓存条目用。下次请求 20 到 39 的数据时，直接命中缓存，很快就能拿到结果。该值越大，查询结果缓存的文档的 ID 集合就越大，命中缓存的概率也就越大，但是这样也会很浪费内存 1&lt;queryResultMaxDocsCached&gt;800&lt;/queryResultMaxDocsCached&gt; 查询结果最大缓存的文档的数目。 1&lt;useColdSearcher&gt;true&lt;/useColdSearcher&gt; 是否使用冷搜索。当一个搜索请求到来时，如果当前没有注册的搜索可用，那么将立即注册一个，并且需等到自热后才能使用它。若该值为 false，那么，所有的搜索请求将阻塞在第一个搜索，直到第一个搜索注册并自热完成 1&lt;maxWarmingSearchers&gt;2&lt;/maxWarmingSearchers&gt; 设置最大的 Searcher 数量，这些 Searcher 都是事先预热好的，随时可以使用。如果超过这个数量，将会报错。 在一个只读的索引库中，2 个预热的 Searcher 是相对合理的；如果是读写的索引库中，可以给一个相对大一点的值 1&lt;requestDispatcher handleSelect=&quot;false&quot;&gt; 配置请求分发器。当访问的 URL 为 /select，如 /select?qt=xxx 若 handleSelect=&quot;true&quot;，SolrDispatchFilter 将请求转发给 qt 指定的处理器（前提是 /select 已经注册） 当 handleSelect=&quot;false&quot; 时会直接访问 /select，若 /select 未注册则报 404 123456789101112&lt;requestHandler name=&quot;/select&quot; class=&quot;solr.SearchHandler&quot; default=&quot;true&quot;&gt; &lt;lst name=&quot;defaults&quot;&gt; &lt;str name=&quot;echoParams&quot;&gt;explicit&lt;/str&gt; &lt;int name=&quot;rows&quot;&gt;10&lt;/int&gt; &lt;str name=&quot;q.op&quot;&gt;AND&lt;/str&gt; &lt;str name=&quot;q.alt&quot;&gt;*:*&lt;/str&gt; &lt;str name=&quot;fl&quot;&gt;*,score&lt;/str&gt; &lt;!-- &lt;str name=&quot;df&quot;&gt;text&lt;/str&gt; --&gt; &lt;str name=&quot;defType&quot;&gt;edismax&lt;/str&gt; &lt;str name=&quot;qf&quot;&gt;name^5 sortName^2 subSortName^3&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 配置请求处理器。更多参数见如下表格 查询参数 描述 q 查询字符串 start 用于分页查询的结果。指定第一条记录在查询结果中的偏移量。默认值为 0 rows 指定从搜索结果中取多少条数据。与 start 配合使用 sort 搜索结果排序。默认为 score desc（按文档的得分降序排序） fl 用来指定文档结果中应返回的字段列表。多个字段之间用逗号分隔，默认为 &quot;*&quot; 指返回所有的字段。score 返回文档的得分，如： *,score q.alt 当查询串 q 为空时，使用该值，通常设置 q.alt 为 *:* wt 指定查询结果输出的格式，如 json，xml 等，默认为 xml 格式 fq 过滤查询。在 q 查询的结果中，再用 fq 条件过滤一次结果 q.op 搜索串中有空格时，使用 OR 逻辑 还是 AND 逻辑 df 指定默认的查询字段 qt 当访问的 url 为 /select，如 /select?qt=xxx，solr 将使用 qt 参数的值来确定使用哪个 requestHandler 来处理查询请求 indent 返回的结果是否缩进，默认关闭，一般调试输出才有必要用这个参数 echoParams&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是否显示查询参数。none：不显示；explicit：只显示查询参数；all：显示所有的参数 qf 指定从哪些字段中查询，如果没有配置，则使用 df 的值 defType 指定处理查询的 Query Parser。如 defType=lucene&nbsp;&nbsp;&nbsp;（Standard Query Parser）defType=dismax&nbsp;&nbsp;（DisMax Query Parser）defType=edismax（Extended DisMax Query Parser）","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"Solr IKAnalyzer 中文分词配置","date":"2015-11-07T18:33:50.000Z","path":"post/solr-ikanalyzer.html","text":"下载 IKAnalyzer-2012FF_hf1_support_solr5.jar，并将它放到 solr 应用的 WEB-INF / lib 目录下 打开并编辑 $SOLR_HOME 下的 schema.xml 配置文件，加入如下配置 12345678&lt;fieldType name=\"text_ik\" class=\"solr.TextField\" positionIncrementGap=\"100\"&gt; &lt;analyzer type=\"index\"&gt; &lt;tokenizer class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"false\" /&gt; &lt;/analyzer&gt; &lt;analyzer type=\"query\"&gt; &lt;tokenizer class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"true\" /&gt; &lt;/analyzer&gt;&lt;/fieldType&gt; &lt;analyzer type=&quot;index&quot;&gt; 配置索引分词 &lt;analyzer type=&quot;query&quot;&gt; 配置搜索分词 useSmart=&quot;false&quot; 使用细粒度分词，useSmart=&quot;true&quot; 使用智能分词。 男士运动鞋中文分词结果 类别 分词 索引（细粒度分词） 男士，运动鞋，运动，鞋 搜索（智能分词） 男士，运动鞋","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"Solr schema.xml 配置","date":"2015-11-07T08:01:36.000Z","path":"post/solr-schema-config.html","text":"schema1&lt;schema name=&quot;core1&quot; version=&quot;1.5&quot;&gt; 参数 描述 name schema 的名称，仅用于展示 version solr 的 schema 语法的版本号 fieldType1&lt;fieldType name=&quot;string&quot; class=&quot;solr.StrField&quot; sortMissingLast=&quot;true&quot; /&gt; 参数 描述 name 字段类型的名称 class 以“solr.”开始，后面为对应的 java 类的短类名构成其中，solr.TextField 类型的 fieldType 还有 analyzer 属性具体可参见 solr-core-5.jar / org.apache.solr.schema 包 sortMissingLast 若为 true，检索结果中，没有该字段类型的数据排在有该字段类型的数据之后，而不管排序请求时设定的排序规则 sortMissingFirst 若为 true，检索结果中，没有该字段类型的数据排在有该字段类型的数据之前，而不管排序请求时设定的排序规则 positionIncrementGap&nbsp;&nbsp;&nbsp;&nbsp; 用于多值字段（multiValued = true）的短语查询如一个文档有两个 tag（标签）：tag1&nbsp; :&nbsp;&nbsp; AB &nbsp; CDtag2&nbsp; :&nbsp;&nbsp; XY &nbsp; ZW若 positionIncrementGap = 0，那么这 4 个词的位置分别为 0, 1, 2, 3如果搜索 CD &nbsp; XY，那么这个文档将会被匹配如果认为该文档不应该被匹配，可将 positionIncrementGap 调大一些，如 positionIncrementGap = 100，那么现在这 4 个词的位置分别为 0, 1 , 100, 101。这样短语查询就不会匹配到该文档 field1&lt;field name=&quot;id&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot; /&gt; 参数 描述 name 具体字段的名称 type 字段类型的名称，参考 &lt;fieldType&gt; 节点 indexed 是否被索引，不需要被检索的字段应该设为 false，以提升性能 stored 是否被存储，需要返回内容值的字段应该设为 true，否则在检索结果中取不到值 docValues 是否有文档值，仅支持 StrField，UUIDField，Trie*Field multiValued&nbsp;&nbsp;&nbsp;&nbsp; 是否有多个值，默认 false omitNorms 是否省略规范，规范是用来提升字段长度标准化和索引时间。只有全文本和需要提升索引时间的字段需要规范。若为 true，solr 不会存储规范，因此索引大小会变小，节省内存，默认为 true required 字段是否是必须的。若为 true，建立索引的时候该字段必须有值，否则抛出异常 default 字段没有值时，默认使用的值 dynamicField动态字段 name = “*_i” 将匹配所有以 “_i” 结束的字段名，如 id_i，age_i 参数属性参考 &lt;field&gt; 1&lt;dynamicField name=&quot;*_i&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; uniqueKey设置文档的唯一键，不同的键值表示不同的文档对象 1&lt;uniqueKey&gt;id&lt;/uniqueKey&gt; copyField将 source 指定的字段名称拷贝到 dest 指定的字段名中，以便进行统一的检索 12345&lt;copyField source=&quot;name&quot; dest=&quot;text&quot;/&gt;&lt;copyField source=&quot;sortName&quot; dest=&quot;text&quot;/&gt;&lt;copyField source=&quot;subSortName&quot; dest=&quot;text&quot;/&gt; 附完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;schema name=&quot;core1&quot; version=&quot;1.5&quot;&gt; &lt;field name=&quot;_version_&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;!-- 商品 ID --&gt; &lt;field name=&quot;id&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品名称 --&gt; &lt;field name=&quot;name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品一级分类 --&gt; &lt;field name=&quot;sortName&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品二级分类 --&gt; &lt;field name=&quot;subSortName&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品价格 --&gt; &lt;field name=&quot;price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品销量 --&gt; &lt;field name=&quot;sales&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 发货地 --&gt; &lt;field name=&quot;area&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 检索域 --&gt; &lt;field name=&quot;text&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot; required=&quot;false&quot;/&gt; &lt;dynamicField name=&quot;*_i&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_is&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_s&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt; &lt;dynamicField name=&quot;*_ss&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_l&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_ls&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_t&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_txt&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_b&quot; type=&quot;boolean&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_bs&quot; type=&quot;boolean&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_f&quot; type=&quot;float&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_fs&quot; type=&quot;float&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_d&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_ds&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_dt&quot; type=&quot;date&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_dts&quot; type=&quot;date&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_ti&quot; type=&quot;tint&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_tl&quot; type=&quot;tlong&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_tf&quot; type=&quot;tfloat&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_td&quot; type=&quot;tdouble&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_tdt&quot; type=&quot;tdate&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_c&quot; type=&quot;currency&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;ignored_*&quot; type=&quot;ignored&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;attr_*&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;random_*&quot; type=&quot;random&quot; /&gt; &lt;uniqueKey&gt;id&lt;/uniqueKey&gt; &lt;copyField source=&quot;name&quot; dest=&quot;text&quot;/&gt; &lt;copyField source=&quot;sortName&quot; dest=&quot;text&quot;/&gt; &lt;copyField source=&quot;subSortName&quot; dest=&quot;text&quot;/&gt; &lt;fieldType name=&quot;string&quot; class=&quot;solr.StrField&quot; sortMissingLast=&quot;true&quot; /&gt; &lt;fieldType name=&quot;boolean&quot; class=&quot;solr.BoolField&quot; sortMissingLast=&quot;true&quot;/&gt; &lt;fieldType name=&quot;int&quot; class=&quot;solr.TrieIntField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;float&quot; class=&quot;solr.TrieFloatField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;long&quot; class=&quot;solr.TrieLongField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;double&quot; class=&quot;solr.TrieDoubleField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tint&quot; class=&quot;solr.TrieIntField&quot; precisionStep=&quot;8&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tfloat&quot; class=&quot;solr.TrieFloatField&quot; precisionStep=&quot;8&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tlong&quot; class=&quot;solr.TrieLongField&quot; precisionStep=&quot;8&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tdouble&quot; class=&quot;solr.TrieDoubleField&quot; precisionStep=&quot;8&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;date&quot; class=&quot;solr.TrieDateField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tdate&quot; class=&quot;solr.TrieDateField&quot; precisionStep=&quot;6&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;binary&quot; class=&quot;solr.BinaryField&quot;/&gt; &lt;fieldType name=&quot;random&quot; class=&quot;solr.RandomSortField&quot; indexed=&quot;true&quot; /&gt; &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt; &lt;analyzer type=&quot;index&quot;&gt; &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; /&gt; &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt; &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt; &lt;/analyzer&gt; &lt;analyzer type=&quot;query&quot;&gt; &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; /&gt; &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt; &lt;filter class=&quot;solr.SynonymFilterFactory&quot; synonyms=&quot;synonyms.txt&quot; ignoreCase=&quot;true&quot; expand=&quot;true&quot;/&gt; &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; &lt;fieldType name=&quot;text_ws&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt; &lt;analyzer&gt; &lt;tokenizer class=&quot;solr.WhitespaceTokenizerFactory&quot;/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; &lt;fieldType name=&quot;ignored&quot; stored=&quot;false&quot; indexed=&quot;false&quot; multiValued=&quot;true&quot; class=&quot;solr.StrField&quot; /&gt; &lt;fieldType name=&quot;currency&quot; class=&quot;solr.CurrencyField&quot; precisionStep=&quot;8&quot; defaultCurrency=&quot;USD&quot; currencyConfig=&quot;currency.xml&quot; /&gt;&lt;/schema&gt;","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"Solr 环境搭建","date":"2015-11-07T03:30:33.000Z","path":"post/solr-setup.html","text":"Solr 是一个独立的企业级搜索应用服务器，基于 Lucene 的全文搜索服务器。同时对其进行了扩展，提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。 安装环境 CentOS 6.5 Solr 5.2.0 JDK 1.7 Tomcat 7 安装 到 Solr 官网下载所需版本文件，本文使用 Solr 5.2.0，安装文件 solr-5.2.0.tgz 在服务器端创建 $CATALINA_HOME/webapps/solr 目录 其中，$CATALINA_HOME 表示 Tomcat 安装的根目录，以下同 本地解压缩 solr-5.2.0.tgz，得到 solr-5.2.0 目录 并将 solr-5.2.0/server/webapps/solr.war 上传到服务器 $CATALINA_HOME/webapps/solr 解压缩 $CATALINA_HOME/webapps/solr/solr.war 包，并备份 solr.war 包 123# cd $CATALINA_HOME/webapps/solr# jar xvf solr.war# mv solr.war solr.war_5.2.0_backup 以 JNDI 的方式设置 SOLR_HOME 变量，SOLR_HOME 是 Tomcat 安装 Solr 实例必不可少的配置 在 $CATALINA_HOME/conf/Catalina/localhost 目录下新建一个 solr.xml 配置文件，内容如下 123&lt;Context docBase=\"/opt/apache-tomcat-solr/webapps/solr\" debug=\"0\" crossContext=\"true\" &gt; &lt;Environment name=\"solr/home\" type=\"java.lang.String\" value=\"/opt/apache-tomcat-solr/conf/solr\" override=\"true\" /&gt;&lt;/Context&gt; docBase 指定到 solr 应用的目录，solr/home 的值指定到 SOLR_HOME 的根目录 将 solr-5.2.0/server/solr 整个文件夹上传到 $CATALINA_HOME/conf/ 下 形成的 $CATALINA_HOME/conf/solr 即是 SOLR_HOME 的目录（以下用 $SOLR_HOME 表示） 删掉 $SOLR_HOME/configsets 目录 12# cd $SOLR_HOME# rm -rf configsets 新建 $SOLR_HOME/core1 目录 1# mkdir core1 新建 $SOLR_HOME/core1/conf 目录 1# mkdir core1/conf 新建 $SOLR_HOME/core1/data 目录 1# mkdir core1/data 将 solr-5.2.0/server/solr/configsets/sample_techproducts_configs 下面的文件 全部上传到 $SOLR_HOME/core1/conf 目录下 将 solr-5.2.0/server/lib/ext 下的 jar 包 全部上传到 $CATALINA_HOME/webapps/solr/WEB-INF/lib 目录下 在 $CATALINA_HOME/webapps/solr/WEB-INF 下创建文件夹 classes 将 solr-5.2.0/server/resources/log4j.properties 上传到 $CATALINA_HOME/webapps/solr/WEB-INF/classes 目录下 添加 core 配置 启动 tomcat，访问 http://192.168.1.102:8081/solr 在 Core Admin 菜单栏，填写如上图表单，点击 Add Core，添加一个 Core 前提：$SOLR_HOME 目录下必须已存在与上图 instanceDir 名称相同的目录， 且该目录存在 data/，conf/schema.xml，conf/solrconfig.xml 目录文件。 否则添加会发生异常导致失败。若添加成功，图示 在左侧菜单栏 Core Selector 下拉框中选择刚添加的 core1，图示 至此，Solr 5.2.0 在 linux 环境下搭建完成。","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"ActiveMQ与Spring集成","date":"2015-11-04T15:20:50.000Z","path":"post/activemq-usage.html","text":"1. ActiveMQ发送和接收消息生产者示例： 12345678910111213141516171819202122232425262728public class Producer &#123; public static void main(String[] args) throws Exception &#123; // 连接工厂 ConnectionFactory factory = new ActiveMQConnectionFactory(\"tcp://192.168.139.129:61616\"); // 创建一条连接 Connection conn = factory.createConnection(); // 启动连接 conn.start(); // 创建会话 Session session = conn.createSession(true, Session.AUTO_ACKNOWLEDGE); // 发送目的地 Destination destination = session.createQueue(\"TEST.QUEUE\"); // 消息生产者 MessageProducer producer = session.createProducer(destination); // 持久化（MQ重启后消息不会丢失） producer.setDeliveryMode(DeliveryMode.PERSISTENT); // 文本内容消息 TextMessage message = session.createTextMessage(\"=== Hello ActiveMQ ===\"); // 发送到目的地 producer.send(message); // 提交事务 session.commit(); // 关闭连接 conn.close(); &#125; &#125; 消费者示例： 123456789101112131415161718192021222324public class Consumer &#123; public static void main(String[] args) throws Throwable &#123; // 连接工厂 ConnectionFactory factory = new ActiveMQConnectionFactory(\"tcp://192.168.139.129:61616\"); // 创建一条连接 Connection conn = factory.createConnection(); // 启动连接 conn.start(); // 创建会话 Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE); // 目的地 Destination destination = session.createQueue(\"TEST.QUEUE\"); // 消息消费者 MessageConsumer consumer = session.createConsumer(destination); while (true) &#123; // 接收消息 TextMessage message = (TextMessage) consumer.receive(); // 打印接收到的消息 System.out.println(String.format(\"[接收消息]: %s\", message.getText())); &#125; &#125; &#125; 2. 与Spring整合pom.xml 配置： # pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;properties&gt; &lt;activemq.version&gt;5.15.2&lt;/activemq.version&gt; &lt;spring.version&gt;4.3.7.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- MQ依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-broker&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- SPRING依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Spring提供了一个方便的JmsTemplate来屏蔽发送消息时的JMS细节，但是JmsTemplate在发送每条消息时，都会创建一个新的Connection，Session，MessageProducer实例，当消息发送出去之后再关闭它们。这样效率非常低下。PooledConnectionFactory支持Connection，Session，MessageProducer实例的池化，使得Connection，Session，MessageProducer实例在使用完之后可以返回池中，以便以后可以重复使用它们。使用PooledConnectionFactory，需要添加activemq-pool依赖包的支持。 生产者配置： # spring-activemq-producer.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 连接工厂 --&gt; &lt;bean id=\"activeMQConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"$&#123;mq.brokerURL&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 连接池工厂 --&gt; &lt;bean id=\"pooledConnectionFactory\" class=\"org.apache.activemq.pool.PooledConnectionFactory\"&gt; &lt;property name=\"connectionFactory\" ref=\"activeMQConnectionFactory\"/&gt; &lt;property name=\"maxConnections\" value=\"$&#123;mq.maxConnections&#125;\"/&gt; &lt;property name=\"maximumActiveSessionPerConnection\" value=\"$&#123;mq.maximumActiveSessionPerConnection&#125;\"/&gt; &lt;property name=\"idleTimeout\" value=\"$&#123;mq.idleTimeout&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 消息模板 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"pooledConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 消息队列 --&gt; &lt;bean id=\"mqQueue1\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"TEST.QUEUE1\" /&gt; &lt;/bean&gt; &lt;bean id=\"mqQueue2\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"TEST.QUEUE2\" /&gt; &lt;/bean&gt; &lt;/beans&gt; # activemq.properties12345678# 链接地址, 采用故障转移策略mq.brokerURL = failover:(tcp://192.168.139.129:61616,tcp://192.168.139.130:61616)?randomize=false&amp;timeout=3000# 最大的连接数, 默认值是1, 可以适当调大一些mq.maxConnections = 100# 连接的空闲时间, 超时则回收, 默认是30秒, 可以适当调大一些, 提高连接的重用时间mq.idleTimeout = 180000# 每个连接最大的会话数, 默认是500, 可以适当调小一些mq.maximumActiveSessionPerConnection = 300 故障转移配置语法： 1failover:(uri1,...,uriN)?transportOptions&amp;nestedURIOptions 或者： 1failover:uri1,...,uriN 如果某台消息服务器宕机等异常情况导致uri1地址失效，ActiveMQ的故障转移机制会从配置的地址列表中选取另外一个地址进行重连。需要注意的是，ActiveMQ并不是按照配置的地址列表来选取地址的，而是随机进行选取的。如果想要关闭随机选取的机制，可以添加randomize=false参数。想要了解更多的配置信息可以链接到官网查阅 failover-transport-reference。 Spring 配置： # spring-context.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"org.fanlychie\"/&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:activemq.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;import resource=\"spring-activemq-producer.xml\"/&gt; &lt;/beans&gt; 消息生产者： # MessageProducer.java1234567891011121314151617181920212223242526272829303132333435@Componentpublic class MessageProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired @Qualifier(\"mqQueue1\") private Destination mqQueue1; @Autowired @Qualifier(\"mqQueue2\") private Destination mqQueue2; public void sendQueue1Message(final String message) &#123; jmsTemplate.send(mqQueue1, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; System.out.println(\"&lt;=== [TEST.QUEUE1] 发送消息：\" + message); return session.createTextMessage(message); &#125; &#125;); &#125; public void sendQueue2Message(final String message) &#123; jmsTemplate.send(mqQueue2, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; System.out.println(\"&lt;=== [TEST.QUEUE2] 发送消息：\" + message); return session.createTextMessage(message); &#125; &#125;); &#125; &#125; Junit单元测试： # TestMessageProducer.java123456789101112131415161718@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"/spring-context.xml\")public class TestMessageProducer &#123; @Autowired private MessageProducer messageProducer; @Test public void testSendQueue1Message() &#123; messageProducer.sendQueue1Message(\"=== QUEUE 1 ===\"); &#125; @Test public void testSendQueue2Message() &#123; messageProducer.sendQueue2Message(\"=== QUEUE 2 ===\"); &#125; &#125; 消费者配置： # spring-activemq-consumer.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 连接工厂 --&gt; &lt;bean id=\"activeMQConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"$&#123;mq.brokerURL&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 连接池工厂 --&gt; &lt;bean id=\"pooledConnectionFactory\" class=\"org.apache.activemq.pool.PooledConnectionFactory\"&gt; &lt;property name=\"connectionFactory\" ref=\"activeMQConnectionFactory\"/&gt; &lt;property name=\"maxConnections\" value=\"$&#123;mq.maxConnections&#125;\"/&gt; &lt;property name=\"maximumActiveSessionPerConnection\" value=\"$&#123;mq.maximumActiveSessionPerConnection&#125;\"/&gt; &lt;property name=\"idleTimeout\" value=\"$&#123;mq.idleTimeout&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 消息队列 --&gt; &lt;bean id=\"mqQueue1\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"TEST.QUEUE1\"/&gt; &lt;/bean&gt; &lt;bean id=\"mqQueue2\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"TEST.QUEUE2\" /&gt; &lt;/bean&gt; &lt;!-- 消息队列监听器 --&gt; &lt;bean id=\"mqQueue1MessageConsumerListener\" class=\"org.fanlychie.mq.MqQueue1MessageConsumerListener\"/&gt; &lt;bean id=\"mqQueue2MessageConsumerListener\" class=\"org.fanlychie.mq.MqQueue2MessageConsumerListener\"/&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean id=\"mqQueue1MessageListenerContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"pooledConnectionFactory\"/&gt; &lt;property name=\"destination\" ref=\"mqQueue1\"/&gt; &lt;property name=\"messageListener\" ref=\"mqQueue1MessageConsumerListener\"/&gt; &lt;!-- &lt;property name=\"concurrency\" value=\"5-10\"/&gt; --&gt; &lt;/bean&gt; &lt;bean id=\"mqQueue2MessageListenerContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"pooledConnectionFactory\"/&gt; &lt;property name=\"destination\" ref=\"mqQueue2\"/&gt; &lt;property name=\"messageListener\" ref=\"mqQueue2MessageConsumerListener\"/&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;property name=”concurrency” value=”5-10”/&gt;concurrency属性可以用来设定消息监听器中的消费者数量的上限和下限。例如“5-10”意味着消息监听器初始会维护最小的5个消费者线程，在系统负载不断增加的情况下，最终的消费者数量会增长至最大数值10。并且当负载降低后，现有的消费者的数量也不会再主动减少。 # activemq.properties12345678# 链接地址, 采用故障转移策略mq.brokerURL = failover:(tcp://192.168.139.129:61616,tcp://192.168.139.130:61616)?randomize=false&amp;timeout=3000# 最大的连接数, 默认值是1, 可以适当调大一些mq.maxConnections = 100# 连接的空闲时间, 超时则回收, 默认是30秒, 可以适当调大一些, 提高连接的重用时间mq.idleTimeout = 180000# 每个连接最大的会话数, 默认是500, 可以适当调小一些mq.maximumActiveSessionPerConnection = 300 Spring 配置： # spring-context.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=\"org.fanlychie\"/&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:activemq.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;import resource=\"spring-activemq-consumer.xml\"/&gt; &lt;/beans&gt; 消息消费监听器： # MqQueue1MessageConsumerListener.java12345678910111213public class MqQueue1MessageConsumerListener implements MessageListener &#123; @Override public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage) message; System.out.println(\"===&gt; [TEST.QUEUE1] 接收消息：\" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; # MqQueue2MessageConsumerListener.java12345678910111213public class MqQueue2MessageConsumerListener implements MessageListener &#123; @Override public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage) message; System.out.println(\"===&gt; [TEST.QUEUE2] 接收消息：\" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 测试示例： 1234567public class TestMessageConsumerListener &#123; public static void main(String[] args) &#123; new ClassPathXmlApplicationContext(\"/spring-context.xml\"); &#125; &#125; 3. 基于注解方式的消费者# spring-activemq-consumer.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms.xsd\"&gt; &lt;!-- 连接工厂 --&gt; &lt;bean id=\"activeMQConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"$&#123;mq.brokerURL&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 连接池工厂 --&gt; &lt;bean id=\"pooledConnectionFactory\" class=\"org.apache.activemq.pool.PooledConnectionFactory\"&gt; &lt;property name=\"connectionFactory\" ref=\"activeMQConnectionFactory\"/&gt; &lt;property name=\"maxConnections\" value=\"$&#123;mq.maxConnections&#125;\"/&gt; &lt;property name=\"maximumActiveSessionPerConnection\" value=\"$&#123;mq.maximumActiveSessionPerConnection&#125;\"/&gt; &lt;property name=\"idleTimeout\" value=\"$&#123;mq.idleTimeout&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 消息监听容器工厂 --&gt; &lt;bean id=\"jmsListenerContainerFactory\" class=\"org.springframework.jms.config.DefaultJmsListenerContainerFactory\"&gt; &lt;property name=\"connectionFactory\" ref=\"pooledConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 开启JMS注解 --&gt; &lt;jms:annotation-driven container-factory=\"jmsListenerContainerFactory\"/&gt; &lt;/beans&gt; 消息消费监听器： # MessageConsumerListener.java1234567891011121314@Componentpublic class MessageConsumerListener &#123; @JmsListener(destination = \"TEST.QUEUE1\") public void mqQueue1MessageConsumer(String message) &#123; System.out.println(\"===&gt; [TEST.QUEUE1] 接收消息：\" + message); &#125; @JmsListener(destination = \"TEST.QUEUE2\") public void mqQueue2MessageConsumer(String message) &#123; System.out.println(\"===&gt; [TEST.QUEUE2] 接收消息：\" + message); &#125; &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring-4.7、ActiveMQ-5.15.2完整示例项目链接：activemq-samples","tags":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://yoursite.com/tags/ActiveMQ/"}]},{"title":"RabbitMQ 安装","date":"2015-11-03T15:32:32.000Z","path":"post/rabbitmq-setup.html","text":"RabbitMQ是基于Erlang编程语言实现的一个高并发高可靠的AMQP消息队列服务器。安装RabbitMQ需要首先安装依赖的Erlang语言环境。 1. Erlang安装到Erlang官网下载安装所需的应用包otp_src_20.2.tar.gz。解压缩： 1$ tar xvf otp_src_20.2.tar.gz 进入到Erlang解压缩的目录： 1# cd otp_src_20.2 安装Erlang编译依赖： 1# yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel 编译Erlang： 1# ./configure --prefix=/usr/local/erlang --with-ssl -enable-threads -enable-smmp-support -enable-kernel-poll --enable-hipe --without-javac 安装Erlang： 1make &amp;&amp; make install 配置Erlang环境变量： 1# vi /etc/profile 添加如下配置： 123ERLANG_HOME=/usr/local/erlangPATH=$PATH:$ERLANG_HOME/binexport PATH 使配置文件生效： 1# source /etc/profile 检查Erlang是否安装成功： 12345$ erl Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:10] [hipe] [kernel-poll:false] Eshell V9.2 (abort with ^G) 2. RabbitMQ安装和配置2.1 安装到RabbitMQ官网下载安装所需的应用包rabbitmq-server-generic-unix-3.7.4.tar.xz。解压缩即可： 1$ tar Jxvf rabbitmq-server-generic-unix-3.7.4.tar.xz 进入到RabbitMQ解压缩的目录： 1$ cd rabbitmq_server-3.7.4 2.2 服务端口 端口 描述 5672 默认的JMS服务端口 15672 默认的控制台管理服务端口 开启防火墙端口： 1# vi /etc/sysconfig/iptables 添加如下配置： 12-A INPUT -m state --state NEW -m tcp -p tcp --dport 5672 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 15672 -j ACCEPT 重启防火墙： 1# service iptables restart 2.3 用户管理添加用户： rabbitmqctl add_user 用户名 密码 1$ ./sbin/rabbitmqctl add_user admin admin 分配角色： rabbitmqctl set_user_tags 用户名 角色 角色类型和描述说明可参考文档 http://www.rabbitmq.com/management.html#permissions 1$ ./sbin/rabbitmqctl set_user_tags admin administrator 添加权限： 1$ rabbitmqctl set_permissions -p \"/\" admin \".*\" \".*\" \".*\" 修改密码： rabbitmqctl change_password 用户名 新密码 1$ ./sbin/rabbitmqctl change_password admin 123654 查看用户列表： rabbitmqctl list_users 1$ ./sbin/rabbitmqctl list_users 删除用户： rabbitmqctl delete_user 用户名 1$ ./sbin/rabbitmqctl delete_user admin 2.4 管理控制台开启管理控制台： 1$ ./sbin/rabbitmq-plugins enable rabbitmq_management 访问地址http://ip:15672 默认的账户密码（仅本机可以登录）：guest/guest。远程访问需要新增配置一个账户才可以登录。 2.5 命令后台启动： 1$ ./sbin/rabbitmq-server -detached 前台启动： 1$ ./sbin/rabbitmq-server start 关闭服务： 1$ ./sbin/rabbitmqctl stop","tags":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://yoursite.com/tags/RabbitMQ/"}]},{"title":"ActiveMQ 安装","date":"2015-11-03T15:02:42.000Z","path":"post/activemq-setup.html","text":"1. 安装到官网下载应用安装包 apache-activemq-5.15.2-bin.tar.gz。解压缩就可以直接用： 1$ tar zxvf apache-activemq-5.15.2-bin.tar.gz 1.1 端口 端口 描述 8161 默认的控制台管理服务端口 61616 默认的JMS服务端口 1.1.1 开启服务端口（CentOS6）编辑配置文件： 1# vi /etc/sysconfig/iptables 添加配置行： 12-A INPUT -m state --state NEW -m tcp -p tcp --dport 8161 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 61616 -j ACCEPT 重启防火墙： 1# service iptables restart 1.1.2 开启服务端口（CentOS7）添加端口： 12# firewall-cmd --permanent --add-port=8161/tcp# firewall-cmd --permanent --add-port=61616/tcp 重新加载： 1# firewall-cmd --reload 2. 常用命令2.1 启动1$ ./bin/activemq start 2.2 停止1$ ./bin/activemq stop 2.3 重启1$ ./bin/activemq restart 3. 管理控制台启动 ActiveMQ，访问 http://ip:8161。点击Manage ActiveMQ broker进去管理控制台。初始的账户密码是admin/admin。 3.1 修改账户密码如果需要修改默认的账户密码，可以编辑conf/jetty-realm.properties文件来更改。 1$ vi conf/jetty-realm.properties 配置格式：“用户名: 密码, 角色”。 12admin: admin, adminuser: user, user 3.2 队列视图 参数 描述 Name 队列的名称 Number Of Pending Messages 积压（未消费）的消息数量 Number Of Consumers 消费者实例的数量 Messages Enqueued 入队的消息数量（该数量只会增加，不会减少） Messages Dequeued 出队的消息数量（已消费的消息数量） 当Number Of Pending Messages=0 且Messages Enqueued=Messages Dequeued时，表明队列中的消息已全部被消费完成。","tags":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://yoursite.com/tags/ActiveMQ/"}]},{"title":"定时任务","date":"2015-10-31T09:42:10.000Z","path":"post/java-scheduled-task.html","text":"实现方式一：Timerschedule 示例清单1234567891011121314151617181920import java.util.Timer;import java.util.TimerTask;public class TimerDemo &#123; public static void main(String[] args) &#123; // 从现在开始, 此后每隔 3 秒执行一次任务 new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, 0, 3 * 1000); &#125; &#125; 特性：任务由同一个线程调度，串行执行。下一个任务按照前一个任务的实际执行完成的时间起算向后推一个时间间隔的时长，若前一个任务发生延迟，下一个任务也会被延后执行。不存在线程安全问题。 scheduleAtFixedRate 示例清单1234567891011121314151617181920import java.util.Timer;import java.util.TimerTask;public class TimerDemo &#123; public static void main(String[] args) &#123; // 从现在开始, 此后每隔 3 秒执行一次任务 new Timer().scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, 0, 3 * 1000); &#125; &#125; 特性：下一个任务按照前一个任务开始执行的时间开始计算，若前一个任务发生延迟，下一个任务不会被延后，存在并发性的可能性，需要考虑线程安全问题。 实现方式二：ScheduledExecutorServicescheduleWithFixedDelay 示例清单1234567891011121314151617181920212223import java.util.concurrent.TimeUnit;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;public class ScheduledExecutorServiceDemo &#123; public static void main(String[] args) &#123; ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); // 从现在开始, 此后每隔 3 秒执行一次任务 service.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, 0, 3, TimeUnit.SECONDS); &#125; &#125; newSingleThreadScheduledExecutor() 等效于 Executors.newScheduledThreadPool(1)。 特性：下一个任务按照前一个任务的实际执行完成的时间起算向后推一个时间间隔的时长，若前一个任务发生延迟，下一个任务也会被延后执行。是基于不固定时间间隔进行的任务调度。 scheduleAtFixedRate 示例清单1234567891011121314151617181920212223import java.util.concurrent.TimeUnit;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;public class ScheduledExecutorServiceDemo &#123; public static void main(String[] args) &#123; ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); // 从现在开始, 此后每隔 3 秒执行一次任务 service.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, 0, 3, TimeUnit.SECONDS); &#125; &#125; newSingleThreadScheduledExecutor() 等效于 Executors.newScheduledThreadPool(1)。 特性：下一个任务按照前一个任务开始执行的时间开始计算，若前一个任务发生延迟，下一个任务不会被延后，是基于固定时间间隔进行的任务调度。 借助 Calendar 实现复杂的任务调度123456789101112131415161718192021222324252627282930313233import java.util.Calendar;import java.util.concurrent.TimeUnit;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;public class ScheduledExecutorServiceDemo &#123; public static void main(String[] args) &#123; ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.HOUR_OF_DAY, 4); calendar.set(Calendar.MINUTE, 0); calendar.set(Calendar.SECOND, 0); calendar.set(Calendar.MILLISECOND, 0); // 距凌晨 04 点的时间戳 long delay = calendar.getTime().getTime() - System.currentTimeMillis(); // 每天凌晨 04 点执行任务 service.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, delay, 24 * 60 * 60 * 1000, TimeUnit.MILLISECONDS); &#125; &#125; 实现方式三：QuartzCron 触发器表达式格式：秒 分 时 日 月 周 年 [ 可选 ] 字段名 值范围 特殊字符 秒 0 - 59 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ 分 0 - 59 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ 时 0 - 23 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ 日 0 - 31 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/&nbsp;&nbsp;L&nbsp;&nbsp;W&nbsp;&nbsp;C&nbsp;&nbsp;? 月 1 - 12 [ JAN - DEC ] ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ 周 1 - 7 &nbsp;&nbsp;[ SUN - SAT ] ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/&nbsp;&nbsp;L&nbsp;&nbsp;C&nbsp;&nbsp;#&nbsp;&nbsp;? 年 1970 - 2099 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ &nbsp; 特殊字符&nbsp;&nbsp;&nbsp;&nbsp; 含义描述 , 用于指定多个值。如在周字段中，MON, WED, FRI 表示一三五 - 用于指定一个范围的值。如在时字段中，03-04 表示凌晨 3 至 4 点 * 表示任意值 / 表示增量值。如在分字段中，5/30 表示从第 5 分钟起，每 30 分钟一次 # 只用于周字段，表示月的第几周，如 MON#2 表示该月的第二个星期一 ? 表示不确定值，是什么值不重要。 C Calendar 的缩写，表示基于日历计算出来的值。 L Last 的缩写，在日字段中单独出现，表示该月最后一天；在周字段中单独出现表示 7 或 SAT，组合出现，如 7L，表示该月最后一个周六 W 表示工作日（周一 至 周五） &nbsp; 示例&nbsp;&nbsp;&nbsp;&nbsp; 描述 0 0 3 * * * 每天凌晨 3 点触发 0 0 3 * * ? 每天凌晨 3 点触发 0 0 3 * * ? * 每天凌晨 3 点触发 0 * 3 * * ? 每天凌晨 3 点 至 3 点 59 分，每分钟触发一次 0 */5 * * * ? 每隔 5 分钟触发一次 0 */5 3 * * ? 每天凌晨 3 点 至 3 点 59 分，每 5 分钟触发一次 0 0 3-4 * * ? 每天凌晨 3 至 4 点，每小时触发一次 0 0 3 * * MON,WED,FRI 每个周一、周三、周五的凌晨 3 点触发一次 0 0 3 L * ? 每个月的最后一天凌晨 3 点触发 0 0 3 * * 2L 每个月的最后一个周一的凌晨 3 点触发 0 0 3 * * MON#2 每个月的第二个周一的凌晨 3 点触发 &nbsp; 示例清单 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CronDemo &#123; public static void main(String[] args) throws Throwable &#123; // 从工厂中获取一个实例 Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // 作业实例, 名称 &quot;MY-JOB&quot; JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(&quot;MY-JOB&quot;).build(); JobDataMap jobDataMap = job.getJobDataMap(); // 键值对信息 jobDataMap.put(&quot;msg&quot;, &quot;Hello World！&quot;); // Cron 触发器, 每 5 秒触发一次 CronTrigger trigger = TriggerBuilder.newTrigger() .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;)).build(); scheduler.scheduleJob(job, trigger); scheduler.start(); &#125; public static class MyJob implements Job &#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobDetail jobDetail = context.getJobDetail(); JobKey jobKey = jobDetail.getKey(); JobDataMap jobDataMap = jobDetail.getJobDataMap(); // 任务执行时, 打印一条消息 System.out.println(&quot;Executing &quot; + jobKey + &quot; : &quot; + jobDataMap.getString(&quot;msg&quot;)); &#125; &#125;&#125; pom.xml 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; log4j.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;http://toolkit.alibaba-inc.com/dtd/log4j/log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&apos;http://jakarta.apache.org/log4j/&apos;&gt; &lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%n%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;org.quartz&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;WARN&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 与 spring 整合整合示例清单1234567891011121314151617181920212223242526package org.fanlychie.cron;import org.quartz.JobKey;import org.quartz.JobDetail;import org.quartz.JobDataMap;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.springframework.scheduling.quartz.QuartzJobBean;public class MyJob extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; JobDetail jobDetail = context.getJobDetail(); JobKey jobKey = jobDetail.getKey(); JobDataMap jobDataMap = jobDetail.getJobDataMap(); // 任务执行时, 打印一条消息 System.out.println(&quot;Executing &quot; + jobKey + &quot; : &quot; + jobDataMap.getString(&quot;msg&quot;)); &#125;&#125; pom.xml 12345678910111213141516171819202122232425262728293031323334&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; beans.xml 12345678910111213141516171819202122232425&lt;bean id=&quot;jobDetail&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;MY-JOB&quot; /&gt; &lt;property name=&quot;jobClass&quot; value=&quot;org.fanlychie.cron.MyJob&quot; /&gt; &lt;property name=&quot;jobDataAsMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;msg&quot;&gt; &lt;value&gt;Hello World！&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;durability&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;cronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;jobDetail&quot; /&gt; &lt;property name=&quot;cronExpression&quot; value=&quot;0/5 * * * * ?&quot; /&gt;&lt;/bean&gt;&lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;cronTrigger&quot; /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; log4j.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;http://toolkit.alibaba-inc.com/dtd/log4j/log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&apos;http://jakarta.apache.org/log4j/&apos;&gt; &lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%n%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;org.quartz&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;WARN&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.springframework&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;WARN&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 测试清单 123456789public class CronTest &#123; public static void main(String[] args) throws Throwable &#123; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"图形验证码","date":"2015-10-31T07:49:37.000Z","path":"post/java-identifying-code.html","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class CaptchaServlet extends HttpServlet &#123; // 验证码宽度 private static int width = 80; // 验证码高度 private static int height = 28; // 验证码字符长度 private static int captchaCharLength = 4; // 验证码的字符集 private static char[] captchaChars = \"ABCEHKN23456789PRSTXYZ\".toCharArray(); // 验证码的字符集大小 private static int captchaCharsSize = captchaChars.length; // 验证码存储在 session 的键名 private static final String CAPTCHA_KEY = \"_CAPTCHA_SESSION_KEY_\"; private static final long serialVersionUID = 5438961220479548231L; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; response.setHeader(\"Cache-Control\", \"no-store\"); response.setHeader(\"Pragma\", \"no-cache\"); response.setDateHeader(\"Expires\", 0); response.setContentType(\"image/jpeg\"); String captchaText = generateRandomCode(); BufferedImage image = generateImage(captchaText); HttpSession session = request.getSession(); session.setAttribute(CAPTCHA_KEY, captchaText); try (OutputStream out = response.getOutputStream()) &#123; ImageIO.write(image, \"jpg\", out); &#125; &#125; /** * 生成随机码字符串 */ private String generateRandomCode() &#123; Random random = ThreadLocalRandom.current(); StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; captchaCharLength; i++) &#123; builder.append(captchaChars[random.nextInt(captchaCharsSize)]); &#125; return builder.toString(); &#125; /** * 生成验证码图片 * * @param captchaText * 验证码字符串 * @return BufferedImage */ private BufferedImage generateImage(String captchaText) &#123; BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics2D graphics = (Graphics2D) image.getGraphics(); // 设置背景颜色 graphics.setColor(Color.WHITE); graphics.fillRect(0, 0, width, height); // 设置边框 graphics.setColor(Color.GRAY); graphics.drawRect(0, 0, width - 1, height - 1); // 设置字体 graphics.setColor(Color.BLACK); graphics.setFont(new Font(\"Calibri\", Font.BOLD, height - 6)); // 平滑不锯齿 graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); int length = captchaText.length(); char[] chars = captchaText.toCharArray(); // 绘制验证码字符 for (int i = 0; i &lt; length; i++) &#123; graphics.drawChars(chars, i, 1, ((width - 8) / length) * i + 7, height / 2 + length / 2 + 6); &#125; graphics.dispose(); return image; &#125;&#125; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;CaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.servlet.CaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;CaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/captcha&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; JSP 1&lt;img src=\"captcha\" onclick=\"this.src+=''\" style=\"cursor:pointer;\" title=\"看不清？换一个\"&gt; 干扰线 在 graphics.dispose(); 前调用 drawLine(graphics); 12345678910111213141516171819202122232425262728293031323334353637383940private void drawLine(Graphics2D graphics) &#123; Point2D[] point2ds = getPoints(.1f, .3f, .5f, .9f); graphics.setRenderingHints(new RenderingHints( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)); graphics.setColor(Color.BLACK); graphics.setStroke(new BasicStroke(2)); for (int i = 0; i &lt; point2ds.length - 1; i++) &#123; graphics.drawLine( (int) point2ds[i].getX(), (int) point2ds[i].getY(), (int) point2ds[i + 1].getX(), (int) point2ds[i + 1].getY()); &#125;&#125;private Point2D[] getPoints(float f1, float f2, float f3, float f4) &#123; Random rand = ThreadLocalRandom.current(); CubicCurve2D curve2d = new CubicCurve2D.Float( width * f1, (height * (rand.nextInt(8) + 2)) * .1f, width * f2, (height * (rand.nextInt(8) + 2)) * .1f, width * f3, (height * (rand.nextInt(8) + 2)) * .1f, width * f4, (height * (rand.nextInt(8) + 2)) * .1f); PathIterator iterator = curve2d.getPathIterator(null, 3); Point2D point2ds[] = new Point2D[200]; int count = 0; float[] coords = new float[6]; while (!iterator.isDone()) &#123; switch (iterator.currentSegment(coords)) &#123; case PathIterator.SEG_MOVETO: case PathIterator.SEG_LINETO: point2ds[count] = new Point2D.Float(coords[0], coords[1]); &#125; count++; iterator.next(); &#125; Point2D[] points = new Point2D[count]; System.arraycopy(point2ds, 0, points, 0, count); return points;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"memcached 客户端","date":"2015-10-25T08:07:48.000Z","path":"post/memcached-client.html","text":"常用客户端一：memcached java client12345&lt;dependency&gt; &lt;groupId&gt;com.whalin&lt;/groupId&gt; &lt;artifactId&gt;Memcached-Java-Client&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt; 客户端代码 12345678910111213141516171819202122232425262728293031323334353637public class MemcachedJavaClientTest &#123; public static void main(String[] args) &#123; SockIOPool pool = SockIOPool.getInstance(&quot;memcachedPool&quot;); pool.setServers(new String[]&#123;&quot;192.168.1.102:11211&quot;, &quot;192.168.1.103:11211&quot;&#125;); pool.setInitConn(20); pool.setMinConn(10); pool.setMaxConn(50); pool.setMaintSleep(5000); pool.setNagle(false); pool.setAliveCheck(false); pool.setSocketTO(3000); pool.setSocketConnectTO(5000); pool.initialize(); MemCachedClient client = new MemCachedClient(&quot;memcachedPool&quot;); client.set(&quot;client_message&quot;, &quot;Memcached Java Client&quot;); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125; &#125; 与 spring 集成 123456789101112131415161718192021222324252627282930313233343536373839&lt;context:property-placeholder location=&quot;classpath:memcached.properties&quot; /&gt;&lt;bean class=&quot;com.whalin.MemCached.SockIOPool&quot; factory-method=&quot;getInstance&quot; init-method=&quot;initialize&quot; destroy-method=&quot;shutDown&quot; lazy-init=&quot;false&quot;&gt; &lt;constructor-arg value=&quot;memcachedPool&quot; /&gt; &lt;property name=&quot;servers&quot;&gt; &lt;list&gt; &lt;value&gt;$&#123;memcached.servers&#125;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;initConn&quot;&gt; &lt;value&gt;$&#123;memcached.initConn&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;minConn&quot;&gt; &lt;value&gt;$&#123;memcached.minConn&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;maxConn&quot;&gt; &lt;value&gt;$&#123;memcached.maxConn&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;maintSleep&quot;&gt; &lt;value&gt;$&#123;memcached.maintSleep&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;nagle&quot;&gt; &lt;value&gt;$&#123;memcached.nagle&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;aliveCheck&quot;&gt; &lt;value&gt;$&#123;memcached.aliveCheck&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;socketTO&quot;&gt; &lt;value&gt;$&#123;memcached.socketTO&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;socketConnectTO&quot;&gt; &lt;value&gt;$&#123;memcached.socketConnectTO&#125;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=&quot;com.whalin.MemCached.MemCachedClient&quot;&gt; &lt;constructor-arg value=&quot;memcachedPool&quot; /&gt;&lt;/bean&gt; memcached.properties 配置项 123456789101112131415161718# 服务器地址memcached.servers = 192.168.1.102:11211,192.168.1.103:11211# 初始化连接的数目memcached.initConn = 20# 最小的连接数memcached.minConn = 10# 最大的连接数memcached.maxConn = 50# 自查线程周期休眠时间memcached.maintSleep = 5000# 关闭 Nagle 算法memcached.nagle = false# 不检查连接是否有效memcached.aliveCheck = false# Socket 阻塞读取数据的超时时间memcached.socketTO = 3000# Socket 阻塞读取数据的超时时间memcached.socketConnectTO = 5000 客户端测试 123456789101112131415161718@ContextConfiguration(&quot;/beans.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class)public class MemcachedJavaClientTest extends AbstractJUnit4SpringContextTests &#123; @Test public void testSet() &#123; MemCachedClient client = applicationContext.getBean(MemCachedClient.class); client.set(&quot;client_message&quot;, &quot;Memcached Java Client&quot;); &#125; @Test public void testGet() &#123; MemCachedClient client = applicationContext.getBean(MemCachedClient.class); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125; &#125; 常用客户端二：spymemcached12345&lt;dependency&gt; &lt;groupId&gt;net.spy&lt;/groupId&gt; &lt;artifactId&gt;spymemcached&lt;/artifactId&gt; &lt;version&gt;2.11.6&lt;/version&gt;&lt;/dependency&gt; 客户端代码 1234567891011121314151617181920212223242526272829303132333435public class SpyMemcachedJavaClientTest &#123; public static void main(String[] args) throws Throwable &#123; ConnectionFactoryBuilder builder = new ConnectionFactoryBuilder(); builder.setDaemon(true); builder.setFailureMode(FailureMode.Redistribute); builder.setHashAlg(DefaultHashAlgorithm.KETAMA_HASH); builder.setLocatorType(Locator.CONSISTENT); builder.setUseNagleAlgorithm(false); builder.setOpTimeout(3000); builder.setProtocol(Protocol.BINARY); builder.setTranscoder(new SerializingTranscoder()); String servers = &quot;192.168.1.102:11211,192.168.1.103:11211&quot;; MemcachedClient client = new MemcachedClient(builder.build(), AddrUtil.getAddresses(servers)); client.set(&quot;client_message&quot;, 0, &quot;spymemcached&quot;); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125;&#125; 与 spring 集成 12345678910111213141516171819202122232425262728293031&lt;context:property-placeholder location=&quot;classpath:spymemcached.properties&quot; /&gt;&lt;bean class=&quot;net.spy.memcached.spring.MemcachedClientFactoryBean&quot;&gt; &lt;property name=&quot;servers&quot;&gt; &lt;value&gt;$&#123;memcached.servers&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;daemon&quot;&gt; &lt;value&gt;$&#123;memcached.daemon&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;failureMode&quot;&gt; &lt;value&gt;$&#123;memcached.failureMode&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;hashAlg&quot;&gt; &lt;value type=&quot;net.spy.memcached.DefaultHashAlgorithm&quot;&gt;$&#123;memcached.hashAlg&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;locatorType&quot;&gt; &lt;value&gt;$&#123;memcached.locatorType&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;useNagleAlgorithm&quot;&gt; &lt;value&gt;$&#123;memcached.useNagleAlgorithm&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;protocol&quot;&gt; &lt;value&gt;$&#123;memcached.protocol&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;opTimeout&quot;&gt; &lt;value&gt;$&#123;memcached.opTimeout&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;transcoder&quot;&gt; &lt;bean class=&quot;net.spy.memcached.transcoders.SerializingTranscoder&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; spymemcached.properties 配置项 12345678910111213141516# 服务器地址memcached.servers = 192.168.1.102:11211,192.168.1.103:11211# 设置 IO 线程的守护进程memcached.daemon = true# 发生故障重新分配连接memcached.failureMode = Redistribute# 一致性哈希算法memcached.hashAlg = KETAMA_HASH# 定位器类型memcached.locatorType = CONSISTENT# 关闭 Nagle 算法memcached.useNagleAlgorithm = false# 使用二进制协议memcached.protocol = BINARY# 操作超时时间memcached.opTimeout = 3000 客户端测试 123456789101112131415161718@ContextConfiguration(&quot;/beans.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class)public class SpyMemcachedJavaClientTest extends AbstractJUnit4SpringContextTests &#123; @Test public void testSet() &#123; MemcachedClient client = applicationContext.getBean(MemcachedClient.class); client.set(&quot;client_message&quot;, 0, &quot;spymemcached&quot;); &#125; @Test public void testGet() &#123; MemcachedClient client = applicationContext.getBean(MemcachedClient.class); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125; &#125; 常用客户端三：xmemcached12345&lt;dependency&gt; &lt;groupId&gt;com.googlecode.xmemcached&lt;/groupId&gt; &lt;artifactId&gt;xmemcached&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 客户端代码 123456789101112131415161718192021222324252627282930313233public class XMemcachedJavaClientTest &#123; public static void main(String[] args) throws Throwable &#123; List&lt;InetSocketAddress&gt; list = AddrUtil.getAddresses(&quot;192.168.1.102:11211 192.168.1.103:11211&quot;); XMemcachedClientBuilder builder = new XMemcachedClientBuilder(list, new int[] &#123; 1, 1 &#125;); builder.setConnectionPoolSize(1); builder.setFailureMode(true); builder.setOpTimeout(3000); builder.setConnectTimeout(5000); builder.setCommandFactory(new TextCommandFactory()); builder.setSessionLocator(new KetamaMemcachedSessionLocator()); builder.setTranscoder(new SerializingTranscoder()); MemcachedClient client = builder.build(); client.set(&quot;client_message&quot;, 0, &quot;xmemcached&quot;); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125;&#125; 与 spring 集成 12345678910111213141516171819202122232425262728293031323334&lt;context:property-placeholder location=&quot;classpath:xmemcached.properties&quot; /&gt;&lt;bean class=&quot;net.rubyeye.xmemcached.utils.XMemcachedClientFactoryBean&quot;&gt; &lt;property name=&quot;servers&quot;&gt; &lt;value&gt;$&#123;memcached.servers&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;weights&quot;&gt; &lt;list&gt; &lt;value&gt;$&#123;memcached.server1&#125;&lt;/value&gt; &lt;value&gt;$&#123;memcached.server2&#125;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;failureMode&quot;&gt; &lt;value&gt;$&#123;memcached.failureMode&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;opTimeout&quot;&gt; &lt;value&gt;$&#123;memcached.opTimeout&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;connectTimeout&quot;&gt; &lt;value&gt;$&#123;memcached.connectTimeout&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;connectionPoolSize&quot;&gt; &lt;value&gt;$&#123;memcached.connectionPoolSize&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;commandFactory&quot;&gt; &lt;bean class=&quot;net.rubyeye.xmemcached.command.TextCommandFactory&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;sessionLocator&quot;&gt; &lt;bean class=&quot;net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;transcoder&quot;&gt; &lt;bean class=&quot;net.rubyeye.xmemcached.transcoders.SerializingTranscoder&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; xmemcached.properties 配置项 1234567891011121314# 服务器地址memcached.servers = 192.168.1.102:11211 192.168.1.103:11211# 权重设置memcached.server1 = 1# 权重设置memcached.server2 = 1# 连接池大小memcached.connectionPoolSize = 1# 宕机警报memcached.failureMode = true# 连接超时memcached.connectTimeout = 5000# 等待超时memcached.opTimeout = 3000 客户端测试 123456789101112131415161718@ContextConfiguration(&quot;/beans.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class)public class XMemcachedJavaClientTest extends AbstractJUnit4SpringContextTests &#123; @Test public void testSet() throws Throwable &#123; MemcachedClient client = applicationContext.getBean(MemcachedClient.class); client.set(&quot;client_message&quot;, 0, &quot;xmemcached&quot;); &#125; @Test public void testGet() throws Throwable &#123; MemcachedClient client = applicationContext.getBean(MemcachedClient.class); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125; &#125;","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"Memcached","slug":"Memcached","permalink":"http://yoursite.com/tags/Memcached/"}]},{"title":"memcached 命令","date":"2015-10-25T03:15:23.000Z","path":"post/memcached- command.html","text":"连接服务器使用 telnet 客户端工具可以连接到 memcached 服务器。 1telnet 192.168.1.102 11211 第一次进来需要摸黑输入，可以敲个回车，同时忽略 ERROR 消息。 set 语法123set key flags exptime bytesvalue 参数 描述 key 键的名称 flags 32位无符号整数，用于存储键值对的额外信息 exptime 缓存过期时间（单位秒），0 表示永不过期 bytes 缓存的 value 值的字节数，不是键的字节数 value 缓存的 value 值，在新的一行赋予 作用：若 key 不存在，则存储该键值对；若 key 已经存在，则更新该 key 的 value 值。 示例： 12345set name 0 0 9fanlychieSTORED STORED 表示成功，ERROR 表示错误。 get 语法1get key 作用：获取 key 映射的 value 值。 示例： 1234567get nameVALUE name 0 9fanlychieEND “VALUE name 0 9” 0 是 flags 的值，9 是 value 的字节数。 add 语法123add key flags exptime bytesvalue 参数含义参考 set 语法参数。 作用：添加一个新的键，如果该键已经存在，则返回 NOT_STORED。 示例： 12345add sex 0 0 4maleSTORED append 语法123append key flags exptime bytesvalue 参数含义参考 set 语法参数。 作用：追加新的值到一个现有的键映射的值中，如果键不存在，则返回 NOT_STORED。 示例： 1234567get sexVALUE sex 0 4maleEND 12345append sex 0 0 3abcSTORED 1234567get sexVALUE sex 0 4maleabcEND replace 语法123replace key flags exptime bytesvalue 参数含义参考 set 语法参数。 作用：替换一个现有的键映射的值，如果键不存在，则返回 NOT_STORED。 示例： 1234567get sexVALUE sex 0 4maleabcEND 12345replace sex 0 0 4maleSTORED 1234567get sexVALUE sex 0 4maleEND delete 语法1delete key 作用：删除缓存。若 key 不存在，则返回 NOT_FOUND；成功则返回 DELETE。 示例： 123delete sexDELETE incr 语法1incr key increment_value 作用：使键映射的值增长。 示例： 12345set age 0 0 221STORED 123incr age 122 decr 语法1decr key increment_value 作用：使键映射的值减小。 示例： 12345set age 0 0 221STORED 123decr age 120 stats 语法1stats 作用：统计服务器信息。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107statsSTAT pid 32586STAT uptime 1887STAT time 1445786677STAT version 1.4.24STAT libevent 2.0.22-stableSTAT pointer_size 64STAT rusage_user 0.085986STAT rusage_system 0.249962STAT curr_connections 10STAT total_connections 11STAT connection_structures 11STAT reserved_fds 20STAT cmd_get 12STAT cmd_set 20STAT cmd_flush 0STAT cmd_touch 0STAT get_hits 7STAT get_misses 5STAT delete_misses 0STAT delete_hits 1STAT incr_misses 0STAT incr_hits 1STAT decr_misses 0STAT decr_hits 1STAT cas_misses 0STAT cas_hits 0STAT cas_badval 0STAT touch_hits 0STAT touch_misses 0STAT auth_cmds 0STAT auth_errors 0STAT bytes_read 986STAT bytes_written 4495STAT limit_maxbytes 134217728STAT accepting_conns 1STAT listen_disabled_num 0STAT threads 4STAT conn_yields 0STAT hash_power_level 16STAT hash_bytes 524288STAT hash_is_expanding 0STAT malloc_fails 0STAT bytes 220STAT curr_items 3STAT total_items 6STAT expired_unfetched 0STAT evicted_unfetched 0STAT evictions 0STAT reclaimed 0STAT crawler_reclaimed 0STAT crawler_items_checked 0STAT lrutail_reflocked 0END 消息 描述 pid Memcache 进程 ID uptime 服务器已运行秒数 time 服务器当前 Unix 时间戳 version Memcache 版本 pointer_size 操作系统指针大小 curr_connections 当前连接数量 total_connections Memcached 运行以来连接总数 connection_structures Memcached 分配的连接结构数量 cmd_get get 命令请求次数 cmd_set set 命令请求次数 cmd_flush flush 命令请求次数 get_hits get 命令命中次数 get_misses get 命令未命中次数 delete_misses delete 命令未命中次数 delete_hits delete 命令命中次数 incr_misses incr 命令未命中次数 incr_hits incr 命令命中次数 decr_misses decr 命令未命中次数 decr_hits decr 命令命中次数 cas_misses cas 命令未命中次数 cas_hits cas 命令命中次数 cas_badval 使用擦拭次数 auth_cmds 认证命令处理的次数 auth_errors 认证失败数目 bytes_read 读取总字节数 bytes_written 发送总字节数 limit_maxbytes 分配的内存总大小（字节） accepting_conns 接受新的连接 listen_disabled_num 失效的监听数 threads 当前线程数 conn_yields 连接操作主动放弃数目 bytes 当前存储占用的字节数 curr_items 当前存储的数据总数 total_items 启动以来存储的数据总数 evictions LRU 释放的对象数目 unix 时间戳转换（java） 1234567891011public static void main(String[] args) &#123; Date date = new Date(1445786677L * 1000); DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String dateStr = format.format(date); System.out.println(dateStr); &#125; stats items 语法1stats items 作用：统计分配的项信息。 示例： 1234567891011121314151617181920212223242526272829stats itemsSTAT items:1:number 3STAT items:1:age 1794STAT items:1:evicted 0STAT items:1:evicted_nonzero 0STAT items:1:evicted_time 0STAT items:1:outofmemory 0STAT items:1:tailrepairs 0STAT items:1:reclaimed 0STAT items:1:expired_unfetched 0STAT items:1:evicted_unfetched 0STAT items:1:crawler_reclaimed 0STAT items:1:crawler_items_checked 0STAT items:1:lrutail_reflocked 0END “STAT items:1:number 3”，1 是 slab_id，3 表示总共有 3 条缓存数据。 stats cachedump 语法1stats cachedump slab_id limit_num 参数 描述 slab_id slab 编号 limit_num 返回的记录条数，0 表示不限制，即所有 作用：返回指定编号的 slab 中键的信息列表。 示例： 123456789stats cachedump 1 0ITEM sex [4 b; 1445784730 s]ITEM age [2 b; 1445784730 s]ITEM name [9 b; 1445784730 s]END “ITEM sex [4 b; 1445784730 s]”，sex 为键的名称，4 为键映射的 value 值的字节数，1445784730 为过期时间。 flush_all 语法1flush_all 作用：清除所有缓存数据。 示例： 123flush_allOK","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"Memcached","slug":"Memcached","permalink":"http://yoursite.com/tags/Memcached/"}]},{"title":"memcached 安装","date":"2015-10-18T15:36:47.000Z","path":"post/memcached-setup.html","text":"Memcached 是一个高性能的分布式内存对象缓存系统，用于动态 Web 应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached 是基于一个存储 key / value 的 hashmap。 安装环境 CentOS 6.5 libevent-2.0.22-stable.tar.gz memcached-1.4.24.tar.gz 安装 libeventmemcached 依赖 libevent 库，检查 libevent 是否已安装 1# rpm -qa | grep libevent 到 libevent 官网下载所需版本的安装文件 123456789# tar zxvf libevent-2.0.22-stable.tar.gz# cd libevent-2.0.22-stable# ./configure --prefix=/usr/local/libevent# make# make install 安装 memcached到 memcached 官网下载所需版本的安装文件 123456789# tar zxvf memcached-1.4.24.tar.gz# cd memcached-1.4.24# ./configure --prefix=/usr/local/memcached --with-libevent=/usr/local/libevent/# make# make install 启动 memcached1# /usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211 -c 1024 –P /tmp/memcached.pid 启动参数 描述 -d 启动一个守护进程 -m 分配给 memcached 的内存大小，单位 MB -u 启动 memcached 的用户 -c 最大运行的并发连接数 -p 设置 memcached 监听的端口 -P 设置保存 memcached 的 pid 文件 查看 memcached1# ps -ef | grep memcached 关闭 memcached12345# ps -ef | grep memcachedroot 9291 1 0 09:09 ? 00:00:00 /usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211 -c 1024 –P /tmp/memcached.pid# kill -9 9291 防火墙开启 11211 端口1# vi /etc/sysconfig/iptables 加入如下一行配置 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 11211 -j ACCEPT 重启防火墙服务 1# service iptables restart","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"Memcached","slug":"Memcached","permalink":"http://yoursite.com/tags/Memcached/"}]}]